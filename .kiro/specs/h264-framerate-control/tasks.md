# H264帧率控制 - 实施任务列表

## 任务概述

本任务列表定义了实现H264帧率控制系统的具体开发任务。任务按照依赖关系和优先级排序，确保增量式开发和及时验证。

**当前代码状态分析**:
- ✅ PlaybackSource已实现基础倍速播放（简单延迟控制）
- ✅ 前端UnifiedMSEPlayer和WebCodecsPlayer已实现基本播放
- ✅ fMP4Converter已实现基础转换，保持时间戳
- ❌ 缺少精确的帧率检测机制（SPS解析、时间戳分析）
- ❌ 缺少精确的时间戳管理（单调性、微秒级精度）
- ❌ 缺少精确的帧率控制（基于帧数的发送间隔计算）
- ❌ 缺少前端帧调度器（WebCodecs手动控制显示时机）
- ❌ 缺少帧率监控和统计

## 任务列表

### 1. 平台端：实现帧率检测器

创建FrameRateDetector组件，实现自动帧率检测功能。

- [ ] 1.1 创建FrameRateDetector基础结构和模块
  - 在`platform-server/src/streaming/`创建`framerate/`目录
  - 创建`framerate/mod.rs`并导出子模块
  - 创建`framerate/detector.rs`文件
  - 定义FrameRateDetector结构体和FrameRateInfo数据模型
  - 定义DetectionMethod枚举（FromSPS, FromTimestamp, Default）
  - 实现基本的构造函数和getter方法
  - 在`streaming/mod.rs`中添加framerate模块导出
  - _需求: 1.1, 1.3_

- [ ] 1.2 实现时间戳分析帧率检测（优先实现，无需外部库）
  - 实现`add_timestamp_sample`方法收集时间戳样本
  - 实现`detect_from_timestamps`方法
  - 使用VecDeque存储最近10-20个时间戳样本
  - 计算相邻帧的时间间隔
  - 计算平均间隔并推导帧率：fps = 1.0 / avg_interval
  - 实现置信度评估（基于间隔方差）
  - 处理边界情况（样本不足、间隔异常）
  - _需求: 1.2_

- [ ]* 1.2.1 编写时间戳分析属性测试
  - **属性2: 时间戳分析帧率计算**
  - **验证: 需求 1.2**
  - 生成随机时间戳序列（模拟不同帧率）
  - 验证计算的帧率与实际帧率误差<5%

- [ ] 1.3 实现SPS解析帧率检测（可选，需要H.264解析库）
  - 评估是否需要添加h264-reader或类似crate
  - 实现`detect_from_sps`方法
  - 解析H.264 SPS NAL单元
  - 提取VUI参数中的time_scale和num_units_in_tick
  - 计算帧率：fps = time_scale / (2 * num_units_in_tick)
  - 处理SPS解析错误和缺失VUI的情况
  - 如果解析库复杂度过高，可暂时跳过此功能
  - _需求: 1.1_

- [ ]* 1.3.1 编写SPS解析属性测试
  - **属性1: 帧率检测准确性**
  - **验证: 需求 1.1**
  - 生成包含不同帧率的SPS数据
  - 验证解析的帧率与实际帧率误差<1%

- [ ] 1.4 实现帧率变化检测和默认值回退
  - 实现`has_frame_rate_changed`方法
  - 比较新旧帧率，检测显著变化（>10%）
  - 实现帧率变化通知机制
  - 实现默认帧率回退（30 FPS）
  - _需求: 1.4, 9.1_

- [ ] 1.5 集成帧率检测到流处理
  - 在LiveStreamSource中添加FrameRateDetector字段
  - 在PlaybackSource中添加FrameRateDetector字段
  - 在接收/读取视频分片时调用帧率检测
  - 将检测到的帧率更新到StreamInfo的frame_rate字段
  - 在get_info方法中返回检测到的帧率
  - _需求: 1.3_

- [ ]* 1.5.1 编写帧率元数据属性测试
  - **属性3: 帧率元数据完整性**
  - **验证: 需求 1.3**
  - 验证流元数据包含有效帧率信息（fps > 0）

### 2. 平台端：实现时间戳管理器

创建TimestampManager组件，实现精确的时间戳管理。

- [ ] 2.1 创建TimestampManager基础结构
  - 在`platform-server/src/streaming/framerate/`创建`timestamp.rs`
  - 定义TimestampManager结构体
  - 字段：base_timestamp, last_timestamp, frame_duration_us, clock_rate
  - 实现构造函数，接受帧率参数
  - 实现时间戳格式转换方法（90kHz ↔ 微秒）
  - 使用u64存储微秒级时间戳，确保精度
  - _需求: 4.5_

- [ ] 2.2 实现时间戳生成和验证
  - 实现`generate_next_timestamp`方法
  - 根据帧率计算帧持续时间（微秒）
  - 生成单调递增的时间戳
  - 实现`validate_timestamp`方法
  - 检查时间戳单调性（新时间戳 > 上一个时间戳）
  - 检测时间戳不连续（间隔异常）
  - _需求: 4.2, 4.3_

- [ ]* 2.2.1 编写时间戳单调性属性测试
  - **属性8: 时间戳单调递增**
  - **验证: 需求 4.3**
  - 生成随机帧序列
  - 验证所有时间戳严格单调递增

- [ ] 2.3 实现时间戳不连续处理
  - 实现`handle_discontinuity`方法
  - 检测时间戳跳跃（>5秒或<0）
  - 重新同步时间戳基准
  - 记录不连续事件到日志
  - 在3帧内完成重新同步
  - _需求: 9.2_

- [ ]* 2.3.1 编写时间戳不连续恢复属性测试
  - **属性16: 时间戳不连续恢复**
  - **验证: 需求 9.2**
  - 模拟时间戳不连续
  - 验证系统在3帧内重新同步

- [ ]* 2.4 编写时间戳精度属性测试
  - **属性10: 时间戳精度保证**
  - **验证: 需求 4.5**
  - 验证时间戳操作精度<1微秒
  - 测试格式转换的精度损失

### 3. 平台端：实现帧率控制器

创建FrameRatePacer组件，实现精确的发送速率控制。

- [ ] 3.1 创建FrameRatePacer基础结构
  - 在`platform-server/src/streaming/framerate/`创建`pacer.rs`
  - 定义FrameRatePacer结构体
  - 字段：target_fps, playback_rate, last_send_time
  - 实现构造函数，接受目标帧率
  - 实现`new`方法和基本getter方法
  - _需求: 2.1_

- [ ] 3.2 实现发送间隔计算和倍速支持
  - 实现`calculate_send_delay`方法
  - 根据目标帧率计算基础帧间隔：1.0 / target_fps
  - 考虑分片包含的帧数（如果可用）
  - 实现`set_playback_rate`方法
  - 调整发送间隔：adjusted_delay = base_delay / playback_rate
  - 验证倍速范围（0.25x到4x）
  - 公式：delay = (frames_in_segment / target_fps) / playback_rate 秒
  - _需求: 2.1, 2.4, 6.1, 6.5_

- [ ]* 3.2.1 编写发送间隔计算属性测试
  - **属性4: 发送间隔计算正确性**
  - **验证: 需求 2.1, 2.4**
  - 生成随机帧率和帧数
  - 验证计算的间隔误差<1ms

- [ ]* 3.2.2 编写倍速播放属性测试
  - **属性6: 倍速播放间隔调整**
  - **验证: 需求 2.3, 6.1**
  - 测试不同倍速下的间隔调整
  - 验证误差<5%

- [ ] 3.3 实现异步等待机制
  - 实现`wait_for_next_frame`方法
  - 使用tokio::time::sleep精确等待
  - 记录实际发送时间（使用Instant）
  - 处理已经超时的情况（不等待）
  - _需求: 2.1_

- [ ] 3.4 实现网络自适应调整（可选）
  - 实现`adjust_for_network`方法
  - 根据带宽和缓冲情况动态调整速率
  - 在网络拥塞时降低发送速率
  - 此功能可在后续迭代中完善
  - _需求: 2.5, 8.1_

- [ ] 3.5 集成帧率控制到PlaybackSource
  - 在PlaybackSource中添加FrameRatePacer字段
  - 在构造函数中初始化FrameRatePacer（使用检测到的帧率）
  - 在`next_segment`方法中调用`wait_for_next_frame`
  - 替换现有的简单延迟逻辑（删除旧的tokio::time::sleep）
  - 在`set_rate`方法中更新FrameRatePacer的倍速
  - _需求: 2.3_

- [ ] 3.6 集成帧率控制到LiveStreamSource（可选）
  - 评估是否需要在直通模式添加速率控制
  - 如果需要，在LiveStreamSource中添加FrameRatePacer
  - 确保不影响低延迟特性（延迟增加<10ms）
  - 可能只在缓冲过多时使用
  - _需求: 2.2_

- [ ]* 3.6.1 编写直通模式延迟属性测试
  - **属性5: 直通模式低延迟保持**
  - **验证: 需求 2.2**
  - 测试添加帧率控制后的延迟增加
  - 验证增加<10ms

### 4. 平台端：审查和验证fMP4时间戳保持

确保H.264到fMP4转换时保持时间戳信息。

- [x] 4.1 审查现有fMP4转换器
  - 已检查`platform-server/src/streaming/fmp4_converter.rs`
  - 确认时间戳处理逻辑：使用segment.timestamp计算decode_time
  - 公式：decode_time = (segment.timestamp * timescale) as u64
  - 时间戳已在tfdt box中正确设置
  - 结论：现有实现已保持时间戳，无需修改
  - _需求: 4.4_

- [ ]* 4.2 编写fMP4时间戳保真属性测试
  - **属性9: fMP4转换时间戳保真**
  - **验证: 需求 4.4**
  - 测试转换前后时间戳差异
  - 验证差异为0（考虑timescale转换）
  - 验证时间戳精度不损失

### 5. 前端：实现帧调度器（WebCodecs）

创建FrameScheduler组件，实现精确的帧显示时机控制。

- [ ] 5.1 创建FrameScheduler基础结构
  - 在`web-frontend/src/utils/`创建`frameScheduler.ts`
  - 定义FrameScheduler类
  - 字段：targetFps, baseTime, frameQueue, droppedFrames
  - 实现构造函数，接受目标帧率
  - 实现帧队列管理（使用数组存储{frame, pts}）
  - _需求: 3.1, 3.3_

- [ ] 5.2 实现帧显示时机计算和调度
  - 实现`addFrame`方法，将帧加入队列
  - 实现`shouldDisplayFrame`方法
  - 根据PTS和当前时间（performance.now）判断是否显示
  - 实现`calculateDisplayDelay`方法
  - 计算延迟：delay = (pts - currentTime)
  - 实现`scheduleNextFrame`私有方法
  - 使用setTimeout或requestAnimationFrame调度显示
  - _需求: 3.3, 3.4_

- [ ]* 5.2.1 编写帧显示时机属性测试
  - **属性7: WebCodecs帧显示时机**
  - **验证: 需求 3.3, 3.4**
  - 测试实际显示时间与目标时间的误差
  - 验证误差<16ms（1帧@60fps）

- [ ] 5.3 实现过早和过晚帧处理
  - 检测过早到达的帧（提前>100ms）
  - 延迟显示直到正确时间（使用setTimeout）
  - 检测过晚到达的帧（延迟>50ms）
  - 立即显示或跳过（根据延迟程度）
  - 记录丢帧统计到droppedFrames字段
  - 实现`getStats`方法返回统计信息
  - _需求: 3.4, 3.5_

- [ ] 5.4 集成FrameScheduler到WebCodecsPlayer
  - 在WebCodecsPlayer中导入FrameScheduler
  - 创建FrameScheduler实例（使用检测到的帧率或默认30fps）
  - 在VideoDecoder的output回调中调用`addFrame`
  - 不再立即显示帧，而是由FrameScheduler调度
  - 实现`displayFrame`方法供FrameScheduler调用
  - 更新FPS计算逻辑
  - _需求: 3.3_

### 6. 前端：实现帧率监控器

创建FrameRateMonitor组件，实现实时FPS监控和统计。

- [ ] 6.1 创建FrameRateMonitor基础结构
  - 在`web-frontend/src/utils/`创建`frameRateMonitor.ts`
  - 定义FrameRateMonitor类
  - 字段：frameTimestamps, windowSize, targetFps, droppedFrames, duplicatedFrames
  - 实现构造函数，接受目标帧率
  - 使用数组存储帧时间戳（滑动窗口）
  - _需求: 7.1_

- [ ] 6.2 实现实时FPS计算
  - 实现`recordFrame`方法
  - 记录当前时间戳（performance.now）
  - 维护滑动窗口（保留最近60帧或1秒的数据）
  - 实现`getCurrentFps`方法
  - 计算FPS：(帧数 - 1) / (最后时间戳 - 第一时间戳) * 1000
  - 确保更新间隔<1秒
  - _需求: 7.1_

- [ ]* 6.2.1 编写FPS计算属性测试
  - **属性13: FPS计算实时性**
  - **验证: 需求 7.1**
  - 验证FPS计算延迟<1秒

- [ ] 6.3 实现统计数据收集和速度偏差检测
  - 实现`getStats`方法
  - 计算平均FPS（所有采样的平均值）
  - 计算最小FPS和最大FPS
  - 返回丢帧和重复帧次数
  - 实现`detectSpeedDeviation`方法
  - 比较实际FPS与目标FPS
  - 计算速度误差百分比：(actual - target) / target * 100
  - _需求: 5.3, 7.2, 7.3, 7.4_

- [ ]* 6.3.1 编写统计数据属性测试
  - **属性14: 统计数据准确性**
  - **验证: 需求 7.2**
  - 验证平均FPS计算准确性
  - 误差<0.1

- [ ]* 6.3.2 编写播放速度误差属性测试
  - **属性11: 播放速度误差上界**
  - **验证: 需求 5.5**
  - 验证播放速度误差<±5%

- [ ] 6.4 集成FrameRateMonitor到播放器
  - 在WebCodecsPlayer中导入FrameRateMonitor
  - 创建FrameRateMonitor实例
  - 在帧显示时调用`recordFrame`
  - 定期更新FPS显示（使用现有的fps state）
  - 在UnifiedMSEPlayer中添加FrameRateMonitor（可选）
  - 在video元素的timeupdate事件中调用recordFrame
  - _需求: 7.1_

### 7. 前端：实现帧率监控UI（可选）

创建用户界面显示帧率信息和统计数据。

- [ ] 7.1 增强现有播放器UI显示帧率信息
  - 在WebCodecsPlayer中添加更多帧率统计显示
  - 显示目标FPS（从服务器获取或默认值）
  - 显示速度误差百分比
  - 显示丢帧统计（如果FrameScheduler实现）
  - 在UnifiedMSEPlayer中添加类似的统计显示
  - 使用现有的player-info样式
  - _需求: 7.1, 7.2_

- [ ] 7.2 实现帧率统计API（可选）
  - 在`platform-server/src/http3/handlers.rs`中添加帧率统计端点
  - 创建GET /api/v1/stream/{session_id}/framerate端点
  - 从StreamSource获取帧率信息
  - 返回JSON格式的帧率检测信息和统计数据
  - 此功能可在后续迭代中实现
  - _需求: 7.5_

### 8. 实现自适应帧率调整（后续迭代）

实现根据网络和性能自动调整帧率的功能。此部分可在核心功能完成后实现。

- [ ] 8.1 实现网络带宽监控
  - 在平台端监控网络带宽使用
  - 检测带宽不足情况
  - 可使用现有的延迟监控基础设施
  - _需求: 8.1_

- [ ] 8.2 实现CPU负载监控（前端）
  - 在前端监控解码性能
  - 检测高CPU负载情况（通过帧丢失率）
  - 可能无法直接获取CPU使用率
  - _需求: 8.2_

- [ ] 8.3 实现自适应帧率调整逻辑
  - 当带宽不足时降低帧率
  - 当CPU负载高时降低帧率
  - 当条件改善时逐步恢复帧率
  - 在FrameRatePacer中实现调整逻辑
  - _需求: 8.1, 8.2, 8.3_

- [ ] 8.4 实现帧率调整通知
  - 通知用户当前帧率状态
  - 显示调整原因
  - 在UI中显示自适应状态
  - _需求: 8.4_

### 9. 实现错误处理和恢复

实现完善的错误处理和自动恢复机制。大部分已在前面任务中包含。

- [x] 9.1 实现默认帧率回退
  - 已在任务1.4中包含
  - 当无法检测帧率时使用30 FPS
  - 记录回退事件到日志
  - _需求: 9.1_

- [ ]* 9.1.1 编写默认帧率回退测试
  - **属性15: 默认帧率回退**
  - **验证: 需求 9.1**
  - 测试无法检测帧率时的行为

- [ ] 9.2 实现帧率突变平滑过渡
  - 在FrameRatePacer中实现平滑过渡
  - 检测帧率突变（变化>20%）
  - 在10帧内逐步调整发送间隔到新帧率
  - 使用线性插值或指数平滑
  - _需求: 9.3_

- [ ] 9.3 增强播放卡顿处理
  - UnifiedMSEPlayer已有智能缓冲管理
  - 检查是否需要额外的卡顿检测
  - 可能需要在缓冲不足时通知用户
  - _需求: 9.4_

- [ ] 9.4 实现详细错误日志
  - 在所有帧率相关组件中添加tracing日志
  - 记录帧率检测事件（info级别）
  - 记录帧率变化（info级别）
  - 记录错误和异常（warn/error级别）
  - 包含时间戳、帧率、错误原因
  - _需求: 9.5_

### 10. 实现配置管理（后续迭代）

实现可配置的帧率控制参数。此部分可在核心功能完成后实现。

- [ ] 10.1 创建配置结构
  - 定义FrameRateConfig结构体
  - 字段：target_fps, tolerance_percent, sync_strategy, adaptive_enabled
  - 定义SyncStrategy枚举（DropFrames, DuplicateFrames, AdjustSpeed）
  - 实现Default trait
  - 可从配置文件或环境变量加载
  - _需求: 10.1, 10.2, 10.3, 10.4_

- [ ] 10.2 实现配置热更新
  - 在FrameRatePacer中添加`update_config`方法
  - 支持运行时更新目标帧率和倍速
  - 确保不中断播放（平滑过渡）
  - 在PlaybackSource中添加配置更新接口
  - _需求: 10.5_

- [ ]* 10.2.1 编写配置热更新属性测试
  - **属性17: 配置热更新无中断**
  - **验证: 需求 10.5**
  - 测试配置更新时播放不中断（无明显卡顿）

- [ ] 10.3 创建配置API（可选）
  - 在`platform-server/src/http3/handlers.rs`中添加配置端点
  - 创建POST /api/v1/stream/{session_id}/framerate/config端点
  - 支持更新帧率控制配置
  - 返回更新结果
  - _需求: 10.1, 10.2, 10.3, 10.4_

### 11. 集成测试（手动测试为主）

进行端到端的集成测试。由于涉及完整系统，主要通过手动测试验证。

- [ ] 11.1 手动测试直通播放帧率控制
  - 启动device-simulator和platform-server
  - 启动直通播放会话
  - 在浏览器中观察播放效果
  - 验证帧率检测（查看日志）
  - 验证播放速度正确（视觉检查）
  - 使用延迟监控验证延迟增加<10ms
  - _需求: 2.2_

- [ ] 11.2 手动测试录像回放帧率控制
  - 准备测试录像文件
  - 启动录像回放会话
  - 验证帧率检测（查看日志或UI）
  - 验证播放速度正确
  - 测试倍速播放（0.5x, 1x, 2x, 4x）
  - 验证倍速切换流畅
  - _需求: 2.3, 6.1_

- [ ]* 11.2.1 编写倍速时间戳属性测试
  - **属性12: 倍速时间戳相对关系**
  - **验证: 需求 6.2**
  - 验证倍速播放时时间戳相对关系不变

- [ ] 11.3 手动测试帧率变化处理
  - 使用可变帧率的测试视频
  - 或在运行时切换视频源
  - 验证系统检测并适应新帧率
  - 检查日志中的帧率变化事件
  - _需求: 1.4, 9.3_

- [ ] 11.4 手动测试时间戳不连续处理
  - 使用包含时间戳跳跃的测试视频
  - 或模拟网络中断后恢复
  - 验证系统重新同步
  - 检查日志中的不连续处理事件
  - _需求: 9.2_

### 12. 性能测试和优化（后续迭代）

进行性能测试并优化。在核心功能完成后进行。

- [ ] 12.1 进行帧率检测性能测试
  - 测试时间戳分析延迟（主要实现）
  - 测试SPS解析延迟（如果实现）
  - 验证延迟<1秒
  - 使用Rust的criterion进行基准测试
  - _需求: 性能需求_

- [ ] 12.2 进行时间戳计算性能测试
  - 测试时间戳生成和转换性能
  - 验证精度达到微秒级
  - 测试格式转换的开销
  - _需求: 4.5_

- [ ] 12.3 进行帧率控制性能测试
  - 测试发送间隔计算性能
  - 测试tokio::time::sleep的精度
  - 验证实际播放速度误差<±5%
  - 使用实际视频流测试
  - _需求: 5.5_

- [ ] 12.4 进行CPU占用测试
  - 使用性能分析工具（如perf, flamegraph）
  - 测试帧率控制的CPU占用
  - 对比添加帧率控制前后的CPU使用
  - 验证增加<2%
  - _需求: 性能需求_

- [ ] 12.5 优化性能瓶颈
  - 根据性能测试结果识别瓶颈
  - 使用缓存优化SPS解析（如果实现）
  - 使用预计算优化时间戳转换
  - 前端使用requestAnimationFrame优化帧显示
  - 考虑使用更高效的数据结构
  - _需求: 性能需求_

### 13. 文档和示例（最后完成）

更新文档并创建示例。

- [ ] 13.1 更新系统设计文档
  - 在`docs/系统文档/系统架构设计文档.md`中添加帧率控制章节
  - 更新架构图（如果需要）
  - 说明帧率检测、时间戳管理、速率控制的实现
  - _需求: 所有需求_

- [ ] 13.2 编写API文档（如果实现了API）
  - 在`docs/系统文档/API接口文档.md`中添加帧率相关API
  - 文档化帧率统计API（如果实现）
  - 文档化帧率配置API（如果实现）
  - 包含请求/响应示例
  - _需求: 7.5, 10.1_

- [ ] 13.3 创建使用示例和测试指南
  - 在`docs/测试指南/`中创建帧率控制测试指南
  - 说明如何测试帧率检测
  - 说明如何测试倍速播放
  - 提供测试视频文件的准备方法
  - 创建配置示例（如果实现了配置功能）
  - _需求: 所有需求_

## 任务依赖关系和推荐顺序

### 核心实现路径（推荐按此顺序）

```
阶段1: 平台端基础设施
1.1 → 1.2 → 1.4 → 1.5 (帧率检测器 - 时间戳分析为主)
  ↓
2.1 → 2.2 → 2.3 (时间戳管理器)
  ↓
3.1 → 3.2 → 3.3 → 3.5 (帧率控制器 + 集成到PlaybackSource)

阶段2: 前端播放控制
5.1 → 5.2 → 5.3 → 5.4 (帧调度器 - WebCodecs)
  ↓
6.1 → 6.2 → 6.3 → 6.4 (帧率监控器)
  ↓
7.1 (增强UI显示)

阶段3: 测试和验证
11.1 → 11.2 (手动集成测试)
  ↓
9.2 → 9.4 (错误处理完善)

阶段4: 可选功能（后续迭代）
1.3 (SPS解析 - 如果需要)
3.4, 3.6 (网络自适应)
8.x (自适应帧率调整)
10.x (配置管理)
12.x (性能测试和优化)
13.x (文档)
```

### 并行开发建议

- **平台端和前端可并行开发**：
  - 一个开发者实现任务1-3（平台端）
  - 另一个开发者实现任务5-6（前端）
  
- **最小可测试版本**：
  - 完成1.1-1.5, 2.1-2.3, 3.1-3.5后，可进行基本的录像回放测试
  - 完成5.1-5.4后，可测试WebCodecs的精确帧显示

### 关键依赖

- 任务3（帧率控制器）依赖任务1（帧率检测）
- 任务5（帧调度器）可独立开发，不依赖平台端
- 任务6（帧率监控）可独立开发
- 任务11（集成测试）需要所有核心功能完成

## 里程碑

### 里程碑 1: 平台端核心功能完成（任务1-3）
- [ ] 帧率检测器实现（时间戳分析）
- [ ] 时间戳管理器实现
- [ ] 帧率控制器实现
- [ ] 集成到PlaybackSource
- **验收**: 录像回放能够按照检测到的帧率正确播放，支持倍速

### 里程碑 2: 前端播放控制完成（任务5-7）
- [ ] 帧调度器实现（WebCodecs）
- [ ] 帧率监控器实现
- [ ] UI增强显示帧率信息
- **验收**: WebCodecs播放器能够精确控制帧显示时机，FPS稳定

### 里程碑 3: 基础功能验证（任务11部分）
- [ ] 直通播放手动测试通过
- [ ] 录像回放手动测试通过
- [ ] 倍速播放测试通过
- **验收**: 播放速度误差<±5%，延迟增加<10ms

### 里程碑 4: 错误处理和稳定性（任务9）
- [ ] 帧率突变平滑过渡
- [ ] 详细错误日志
- [ ] 边界情况处理
- **验收**: 系统在各种异常情况下稳定运行

### 里程碑 5: 可选功能和优化（任务8, 10, 12, 13）
- [ ] 自适应帧率调整（可选）
- [ ] 配置管理（可选）
- [ ] 性能测试和优化
- [ ] 文档更新
- **验收**: 系统性能达标，文档完整

## 验收标准

### 核心功能验收（必须完成）

系统核心功能将被认为完成，当且仅当：

1. ✅ 能够自动检测视频流帧率（主要通过时间戳分析）
2. ✅ 平台端能够按照检测到的帧率控制分片发送
3. ✅ 前端播放器能够按照正确帧率显示视频
4. ✅ 时间戳管理准确，精度达到微秒级
5. ✅ 播放速度稳定，误差<±5%
6. ✅ 支持倍速播放（0.25x-4x）
7. ✅ 提供基本的帧率监控和统计
8. ✅ 基本错误处理完善，播放稳定
9. ✅ 通过手动集成测试

### 可选功能验收（后续迭代）

以下功能可在后续迭代中完成：

- SPS解析帧率检测
- 自适应帧率调整
- 配置管理和热更新
- 性能测试和优化
- 完整的API文档

## 注意事项

### 测试相关
- 标记为 `*` 的任务为可选测试任务，可根据时间安排决定是否实施
- 属性测试使用proptest (Rust) 或 fast-check (TypeScript) 框架
- 集成测试主要通过手动测试，需要启动完整的系统环境
- 性能测试在后续迭代中进行

### 实现建议
- **优先实现时间戳分析**：比SPS解析更简单，不需要额外的H.264解析库
- **渐进式开发**：先实现基础功能，再添加可选功能
- **保持低延迟**：确保添加帧率控制后延迟增加<10ms
- **代码复用**：利用现有的PlaybackSource和UnifiedMSEPlayer基础
- **日志记录**：在所有关键点添加tracing日志，便于调试

### 集成注意事项
- 帧率控制应该与现有的统一低延迟流系统无缝集成
- 不要破坏现有的直通播放和录像回放功能
- 确保向后兼容（如果帧率检测失败，使用默认值）
- 前端和后端可以独立开发和测试

### 性能目标
- 帧率检测延迟 < 1秒
- 时间戳精度 ≥ 1微秒
- 播放速度误差 < ±5%
- 帧显示时机误差 < ±16ms
- CPU占用增加 < 2%

## 变更历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| v1.0 | 2025-12-14 | 初始版本 | 系统架构团队 |
