# ç›´é€šæ’­æ”¾åŠŸèƒ½è¯¦ç»†æŠ€æœ¯å®ç°æ–¹æ¡ˆ

## æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| åŠŸèƒ½åç§° | ç›´é€šæ’­æ”¾ï¼ˆLive Streamingï¼‰æŠ€æœ¯å®ç°æ–¹æ¡ˆ |
| åˆ›å»ºæ—¥æœŸ | 2025-12-13 |
| ç‰ˆæœ¬ | v1.0 |
| çŠ¶æ€ | å®æ–½ä¸­ |

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†ç›´é€šæ’­æ”¾åŠŸèƒ½çš„æŠ€æœ¯å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬è®¾å¤‡ç«¯å±å¹•å½•åˆ¶ã€H.264ç¼–ç ã€ä¿¡ä»¤æµç¨‹ã€æ•°æ®ä¼ è¾“å’Œå‰ç«¯æ’­æ”¾çš„å®Œæ•´æµç¨‹ã€‚

## æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        è®¾å¤‡ç«¯ (Device)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ Screen       â”‚â”€â”€â–¶â”‚ H.264        â”‚â”€â”€â–¶â”‚ Live Stream  â”‚       â”‚
â”‚  â”‚ Capturer     â”‚   â”‚ Encoder      â”‚   â”‚ Generator    â”‚       â”‚
â”‚  â”‚ (scrap)      â”‚   â”‚ (ffmpeg)     â”‚   â”‚              â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                 â”‚               â”‚
â”‚                                                 â–¼               â”‚
â”‚                                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚                                         â”‚ QUIC Client  â”‚        â”‚
â”‚                                         â”‚ (å‘é€åˆ†ç‰‡)   â”‚        â”‚
â”‚                                         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚ QUIC
                                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å¹³å°ç«¯ (Platform)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ QUIC Server  â”‚â”€â”€â–¶â”‚ Live Stream  â”‚â”€â”€â–¶â”‚ Unified      â”‚       â”‚
â”‚  â”‚ (æ¥æ”¶åˆ†ç‰‡)   â”‚   â”‚ Source       â”‚   â”‚ Stream       â”‚       â”‚
â”‚  â”‚              â”‚   â”‚              â”‚   â”‚ Handler      â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                 â”‚               â”‚
â”‚                                                 â–¼               â”‚
â”‚                                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚                                         â”‚ HTTP3/SSE    â”‚        â”‚
â”‚                                         â”‚ Transport    â”‚        â”‚
â”‚                                         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚ HTTP3/SSE
                                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯ (Frontend)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ EventSource  â”‚â”€â”€â–¶â”‚ Unified MSE  â”‚â”€â”€â–¶â”‚ Video        â”‚       â”‚
â”‚  â”‚ (SSE Client) â”‚   â”‚ Player       â”‚   â”‚ Element      â”‚       â”‚
â”‚  â”‚              â”‚   â”‚              â”‚   â”‚              â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ç¬¬ä¸€é˜¶æ®µï¼šè®¾å¤‡ç«¯å±å¹•å½•åˆ¶å’Œç¼–ç 

### ä»»åŠ¡ 0.1: æ·»åŠ ä¾èµ–

**ç›®æ ‡**ï¼šåœ¨è®¾å¤‡æ¨¡æ‹Ÿå™¨ä¸­æ·»åŠ å±å¹•å½•åˆ¶å’ŒH.264ç¼–ç æ‰€éœ€çš„ä¾èµ–ã€‚

**ä¿®æ”¹æ–‡ä»¶**ï¼š`device-simulator/Cargo.toml`

**æ·»åŠ ä¾èµ–**ï¼š
```toml
[dependencies]
# ç°æœ‰ä¾èµ–...

# å±å¹•æ•è·
scrap = "0.5"

# H.264ç¼–ç ï¼ˆæ–¹æ¡ˆ1ï¼šffmpegï¼‰
ffmpeg-next = "6.0"

# æˆ–è€… H.264ç¼–ç ï¼ˆæ–¹æ¡ˆ2ï¼šopenh264ï¼Œæ›´è½»é‡ï¼‰
# openh264 = "0.5"

# å›¾åƒå¤„ç†
image = "0.24"

# å¸§ç‡æ§åˆ¶
tokio-util = { version = "0.7", features = ["time"] }
```

**ç³»ç»Ÿä¾èµ–**ï¼š
- **Linux**: `sudo apt-get install libavcodec-dev libavformat-dev libavutil-dev libswscale-dev`
- **macOS**: `brew install ffmpeg`
- **Windows**: ä¸‹è½½ffmpegé¢„ç¼–è¯‘åº“

### ä»»åŠ¡ 0.2: å®ç°å±å¹•æ•è·æ¨¡å—

**ç›®æ ‡**ï¼šå®ç°è·¨å¹³å°çš„å±å¹•æ•è·åŠŸèƒ½ã€‚

**åˆ›å»ºæ–‡ä»¶**ï¼š`device-simulator/src/video/screen_capture.rs`

**æ ¸å¿ƒç»“æ„**ï¼š
```rust
use scrap::{Capturer, Display};
use std::io::ErrorKind;
use std::time::Duration;

pub struct ScreenCapturer {
    capturer: Capturer,
    width: usize,
    height: usize,
    frame_interval: Duration,
}

impl ScreenCapturer {
    /// åˆ›å»ºå±å¹•æ•è·å™¨
    /// 
    /// # å‚æ•°
    /// - fps: ç›®æ ‡å¸§ç‡ï¼ˆé»˜è®¤30ï¼‰
    pub fn new(fps: u32) -> Result<Self, Box<dyn std::error::Error>> {
        // è·å–ä¸»æ˜¾ç¤ºå™¨
        let display = Display::primary()?;
        let capturer = Capturer::new(display)?;
        
        let width = capturer.width();
        let height = capturer.height();
        let frame_interval = Duration::from_secs_f64(1.0 / fps as f64);
        
        Ok(Self {
            capturer,
            width,
            height,
            frame_interval,
        })
    }

    
    /// æ•è·ä¸€å¸§
    /// 
    /// # è¿”å›
    /// - Ok(Some(frame)): æˆåŠŸæ•è·å¸§
    /// - Ok(None): å¸§æœªå‡†å¤‡å¥½ï¼ˆéœ€è¦é‡è¯•ï¼‰
    /// - Err: æ•è·é”™è¯¯
    pub fn capture_frame(&mut self) -> Result<Option<Vec<u8>>, Box<dyn std::error::Error>> {
        match self.capturer.frame() {
            Ok(frame) => {
                // è½¬æ¢BGRAåˆ°RGB
                let rgb_frame = self.bgra_to_rgb(&frame);
                Ok(Some(rgb_frame))
            }
            Err(e) if e.kind() == ErrorKind::WouldBlock => {
                // å¸§æœªå‡†å¤‡å¥½
                Ok(None)
            }
            Err(e) => Err(Box::new(e)),
        }
    }
    
    /// å°†BGRAæ ¼å¼è½¬æ¢ä¸ºRGBæ ¼å¼
    fn bgra_to_rgb(&self, bgra: &[u8]) -> Vec<u8> {
        let mut rgb = Vec::with_capacity(self.width * self.height * 3);
        
        for chunk in bgra.chunks(4) {
            rgb.push(chunk[2]); // R
            rgb.push(chunk[1]); // G
            rgb.push(chunk[0]); // B
        }
        
        rgb
    }
    
    pub fn width(&self) -> usize {
        self.width
    }
    
    pub fn height(&self) -> usize {
        self.height
    }
    
    pub fn frame_interval(&self) -> Duration {
        self.frame_interval
    }
}
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨`scrap`åº“è¿›è¡Œè·¨å¹³å°å±å¹•æ•è·
- æ”¯æŒé…ç½®å¸§ç‡ï¼ˆé»˜è®¤30fpsï¼‰
- å¤„ç†`WouldBlock`é”™è¯¯ï¼ˆå¸§æœªå‡†å¤‡å¥½ï¼‰
- è½¬æ¢BGRAåˆ°RGBæ ¼å¼ï¼ˆffmpegéœ€è¦ï¼‰


### ä»»åŠ¡ 0.3: å®ç°H.264ç¼–ç å™¨æ¨¡å—

**ç›®æ ‡**ï¼šä½¿ç”¨ffmpegå®ç°ä½å»¶è¿ŸH.264ç¼–ç ã€‚

**åˆ›å»ºæ–‡ä»¶**ï¼š`device-simulator/src/video/h264_encoder.rs`

**æ ¸å¿ƒç»“æ„**ï¼š
```rust
use ffmpeg_next as ffmpeg;
use ffmpeg::codec;
use ffmpeg::format::Pixel;
use ffmpeg::software::scaling::{context::Context, flag::Flags};
use ffmpeg::util::frame::video::Video;

pub struct H264Encoder {
    encoder: ffmpeg::encoder::Video,
    scaler: Context,
    frame_count: i64,
    time_base: ffmpeg::Rational,
}

impl H264Encoder {
    /// åˆ›å»ºH.264ç¼–ç å™¨
    /// 
    /// # å‚æ•°
    /// - width: è§†é¢‘å®½åº¦
    /// - height: è§†é¢‘é«˜åº¦
    /// - fps: å¸§ç‡
    /// - bitrate: ç›®æ ‡ç ç‡ï¼ˆbpsï¼‰
    pub fn new(
        width: u32,
        height: u32,
        fps: u32,
        bitrate: usize,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        ffmpeg::init()?;
        
        // åˆ›å»ºç¼–ç å™¨
        let codec = ffmpeg::encoder::find(codec::Id::H264)
            .ok_or("H264 codec not found")?;
        
        let mut encoder = codec.video()?;
        encoder.set_width(width);
        encoder.set_height(height);
        encoder.set_format(Pixel::YUV420P);
        encoder.set_bit_rate(bitrate);
        encoder.set_time_base(ffmpeg::Rational::new(1, fps as i32));
        encoder.set_frame_rate(Some(ffmpeg::Rational::new(fps as i32, 1)));

        
        // ä½å»¶è¿Ÿé…ç½®
        encoder.set_gop(fps); // GOP = 1ç§’
        encoder.set_max_b_frames(0); // ç¦ç”¨Bå¸§
        
        // è®¾ç½®ç¼–ç å‚æ•°ï¼ˆä½å»¶è¿Ÿä¼˜åŒ–ï¼‰
        let mut dict = ffmpeg::Dictionary::new();
        dict.set("preset", "ultrafast"); // æœ€å¿«ç¼–ç é€Ÿåº¦
        dict.set("tune", "zerolatency"); // é›¶å»¶è¿Ÿè°ƒä¼˜
        dict.set("profile", "baseline"); // baseline profile
        
        let encoder = encoder.open_with(dict)?;
        
        // åˆ›å»ºç¼©æ”¾å™¨ï¼ˆRGB -> YUV420Pï¼‰
        let scaler = Context::get(
            Pixel::RGB24,
            width,
            height,
            Pixel::YUV420P,
            width,
            height,
            Flags::BILINEAR,
        )?;
        
        Ok(Self {
            encoder,
            scaler,
            frame_count: 0,
            time_base: ffmpeg::Rational::new(1, fps as i32),
        })
    }
    
    /// ç¼–ç ä¸€å¸§
    /// 
    /// # å‚æ•°
    /// - rgb_data: RGB24æ ¼å¼çš„å¸§æ•°æ®
    /// 
    /// # è¿”å›
    /// - ç¼–ç åçš„H.264æ•°æ®åŒ…ï¼ˆå¯èƒ½ä¸ºç©ºï¼Œå› ä¸ºç¼–ç å™¨å¯èƒ½ç¼“å†²ï¼‰
    pub fn encode_frame(
        &mut self,
        rgb_data: &[u8],
    ) -> Result<Vec<Vec<u8>>, Box<dyn std::error::Error>> {
        // åˆ›å»ºRGBå¸§
        let mut rgb_frame = Video::new(Pixel::RGB24, self.encoder.width(), self.encoder.height());
        rgb_frame.data_mut(0).copy_from_slice(rgb_data);
        
        // è½¬æ¢ä¸ºYUV420P
        let mut yuv_frame = Video::new(Pixel::YUV420P, self.encoder.width(), self.encoder.height());
        self.scaler.run(&rgb_frame, &mut yuv_frame)?;
        
        // è®¾ç½®æ—¶é—´æˆ³
        yuv_frame.set_pts(Some(self.frame_count));
        self.frame_count += 1;
        
        // ç¼–ç 
        self.encoder.send_frame(&yuv_frame)?;
        
        // æ¥æ”¶ç¼–ç åçš„æ•°æ®åŒ…
        let mut packets = Vec::new();
        loop {
            let mut packet = ffmpeg::Packet::empty();
            match self.encoder.receive_packet(&mut packet) {
                Ok(_) => {
                    packets.push(packet.data().unwrap().to_vec());
                }
                Err(ffmpeg::Error::Other { errno: 11 }) => break, // EAGAIN
                Err(e) => return Err(Box::new(e)),
            }
        }
        
        Ok(packets)
    }
    
    /// åˆ·æ–°ç¼–ç å™¨ï¼ˆè·å–ç¼“å†²çš„å¸§ï¼‰
    pub fn flush(&mut self) -> Result<Vec<Vec<u8>>, Box<dyn std::error::Error>> {
        self.encoder.send_eof()?;
        
        let mut packets = Vec::new();
        loop {
            let mut packet = ffmpeg::Packet::empty();
            match self.encoder.receive_packet(&mut packet) {
                Ok(_) => {
                    packets.push(packet.data().unwrap().to_vec());
                }
                Err(_) => break,
            }
        }
        
        Ok(packets)
    }
}
```

**å…³é”®é…ç½®**ï¼š
- **preset=ultrafast**: æœ€å¿«ç¼–ç é€Ÿåº¦
- **tune=zerolatency**: é›¶å»¶è¿Ÿè°ƒä¼˜
- **profile=baseline**: å…¼å®¹æ€§æœ€å¥½
- **max_b_frames=0**: ç¦ç”¨Bå¸§ï¼ˆé™ä½å»¶è¿Ÿï¼‰
- **GOP=30**: 1ç§’ä¸€ä¸ªå…³é”®å¸§ï¼ˆ30fpsï¼‰


### ä»»åŠ¡ 0.4: å®ç°å®æ—¶æµç”Ÿæˆå™¨

**ç›®æ ‡**ï¼šæ•´åˆå±å¹•æ•è·å’ŒH.264ç¼–ç ï¼Œç”Ÿæˆå®æ—¶è§†é¢‘æµã€‚

**åˆ›å»ºæ–‡ä»¶**ï¼š`device-simulator/src/video/live_stream_generator.rs`

**æ ¸å¿ƒç»“æ„**ï¼š
```rust
use super::screen_capture::ScreenCapturer;
use super::h264_encoder::H264Encoder;
use common::VideoSegment;
use tokio::sync::mpsc;
use tokio::time::{interval, Duration};
use uuid::Uuid;

pub struct LiveStreamGenerator {
    capturer: ScreenCapturer,
    encoder: H264Encoder,
    session_id: Uuid,
    is_running: bool,
}

impl LiveStreamGenerator {
    /// åˆ›å»ºå®æ—¶æµç”Ÿæˆå™¨
    pub fn new(
        session_id: Uuid,
        fps: u32,
        bitrate: usize,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let capturer = ScreenCapturer::new(fps)?;
        let width = capturer.width() as u32;
        let height = capturer.height() as u32;
        
        let encoder = H264Encoder::new(width, height, fps, bitrate)?;
        
        Ok(Self {
            capturer,
            encoder,
            session_id,
            is_running: false,
        })
    }
    
    /// å¯åŠ¨å®æ—¶æµ
    /// 
    /// # è¿”å›
    /// - è§†é¢‘åˆ†ç‰‡æ¥æ”¶å™¨
    pub async fn start_streaming(
        &mut self,
    ) -> Result<mpsc::Receiver<VideoSegment>, Box<dyn std::error::Error>> {
        if self.is_running {
            return Err("Stream already running".into());
        }
        
        self.is_running = true;
        let (tx, rx) = mpsc::channel(100);
        
        // å¯åŠ¨æ•è·å’Œç¼–ç ä»»åŠ¡
        self.spawn_capture_task(tx).await?;
        
        Ok(rx)
    }

    
    async fn spawn_capture_task(
        &mut self,
        tx: mpsc::Sender<VideoSegment>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let frame_interval = self.capturer.frame_interval();
        let mut interval_timer = interval(frame_interval);
        let session_id = self.session_id;
        
        let mut frame_count = 0u64;
        let mut timestamp = 0.0f64;
        let frame_duration = frame_interval.as_secs_f64();
        
        tokio::spawn(async move {
            loop {
                interval_timer.tick().await;
                
                // æ•è·å±å¹•å¸§
                let rgb_frame = match self.capturer.capture_frame() {
                    Ok(Some(frame)) => frame,
                    Ok(None) => continue, // å¸§æœªå‡†å¤‡å¥½
                    Err(e) => {
                        tracing::error!("Screen capture error: {}", e);
                        break;
                    }
                };
                
                // ç¼–ç å¸§
                let packets = match self.encoder.encode_frame(&rgb_frame) {
                    Ok(packets) => packets,
                    Err(e) => {
                        tracing::error!("Encoding error: {}", e);
                        continue;
                    }
                };
                
                // å‘é€ç¼–ç åçš„æ•°æ®åŒ…
                for packet in packets {
                    let is_keyframe = frame_count % 30 == 0; // æ¯30å¸§ä¸€ä¸ªå…³é”®å¸§
                    
                    let segment = VideoSegment {
                        segment_id: Uuid::new_v4(),
                        session_id,
                        timestamp,
                        duration: frame_duration,
                        data: packet,
                        flags: if is_keyframe { 1 } else { 0 },
                    };
                    
                    if tx.send(segment).await.is_err() {
                        tracing::warn!("Receiver dropped, stopping stream");
                        break;
                    }
                }
                
                frame_count += 1;
                timestamp += frame_duration;
            }
            
            tracing::info!("Live stream generator stopped");
        });
        
        Ok(())
    }
    
    /// åœæ­¢å®æ—¶æµ
    pub fn stop_streaming(&mut self) {
        self.is_running = false;
        // é€šé“å…³é—­ä¼šè‡ªåŠ¨åœæ­¢ä»»åŠ¡
    }
}
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨`tokio::time::interval`ç²¾ç¡®æ§åˆ¶å¸§ç‡
- å¼‚æ­¥æ•è·å’Œç¼–ç ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
- é€šè¿‡`mpsc::channel`ä¼ é€’è§†é¢‘åˆ†ç‰‡
- è‡ªåŠ¨æ ‡è®°å…³é”®å¸§ï¼ˆæ¯30å¸§ï¼‰


## ç¬¬äºŒé˜¶æ®µï¼šä¿¡ä»¤æµç¨‹å®ç°

### ä»»åŠ¡ 0.5: è®¾å¤‡ç«¯å¤„ç†ç›´é€šæ’­æ”¾ä¿¡ä»¤

**ç›®æ ‡**ï¼šè®¾å¤‡ç«¯æ¥æ”¶å¹¶å¤„ç†å¹³å°çš„ç›´é€šæ’­æ”¾å¯åŠ¨è¯·æ±‚ã€‚

**ä¿®æ”¹æ–‡ä»¶**ï¼š`device-simulator/src/device_service.rs`

**æ·»åŠ æ¶ˆæ¯ç±»å‹**ï¼ˆåœ¨`common/src/protocol.rs`ï¼‰ï¼š
```rust
pub enum MessageType {
    // ç°æœ‰ç±»å‹...
    StartLiveStream = 0x10,  // æ–°å¢ï¼šå¯åŠ¨ç›´é€šæ’­æ”¾
    StopLiveStream = 0x11,   // æ–°å¢ï¼šåœæ­¢ç›´é€šæ’­æ”¾
}

#[derive(Serialize, Deserialize, Debug)]
pub struct StartLiveStreamRequest {
    pub quality_preference: String,  // "low_latency" | "high_quality"
    pub target_latency_ms: u32,
    pub target_fps: u32,
    pub target_bitrate: usize,
}
```

**åœ¨`device_service.rs`ä¸­æ·»åŠ å¤„ç†é€»è¾‘**ï¼š
```rust
use crate::video::LiveStreamGenerator;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct DeviceService {
    // ç°æœ‰å­—æ®µ...
    live_generator: Arc<Mutex<Option<LiveStreamGenerator>>>,
}

impl DeviceService {
    async fn handle_control_messages(
        connection: quinn::Connection,
        video_dir: std::path::PathBuf,
        device_id: String,
    ) -> Result<()> {
        loop {
            match connection.accept_bi().await {
                Ok((mut send, mut recv)) => {
                    // ... ç°æœ‰ä»£ç  ...
                    
                    match msg.message_type {
                        // ç°æœ‰å¤„ç†...
                        
                        MessageType::StartLiveStream => {
                            info!("ğŸ“¡ Received start live stream request");
                            
                            // è§£æè¯·æ±‚
                            let request = bincode::deserialize::<StartLiveStreamRequest>(
                                &msg.payload
                            ).unwrap_or_else(|_| StartLiveStreamRequest {
                                quality_preference: "low_latency".to_string(),
                                target_latency_ms: 100,
                                target_fps: 30,
                                target_bitrate: 2_000_000, // 2 Mbps
                            });
                            
                            info!("  FPS: {}", request.target_fps);
                            info!("  Bitrate: {} bps", request.target_bitrate);
                            
                            // åˆ›å»ºå®æ—¶æµç”Ÿæˆå™¨
                            let mut generator = LiveStreamGenerator::new(
                                msg.session_id,
                                request.target_fps,
                                request.target_bitrate,
                            ).unwrap();
                            
                            // å¯åŠ¨æµ
                            let mut receiver = generator.start_streaming().await.unwrap();
                            
                            // å‘é€ç¡®è®¤å“åº”
                            let _ = send.write_all(b"OK").await;
                            let _ = send.finish().await;
                            
                            // å¯åŠ¨åˆ†ç‰‡å‘é€ä»»åŠ¡
                            let conn_clone = conn.clone();
                            tokio::spawn(async move {
                                while let Some(segment) = receiver.recv().await {
                                    // é€šè¿‡QUICå•å‘æµå‘é€åˆ†ç‰‡
                                    if let Ok(mut stream) = conn_clone.open_uni().await {
                                        let data = bincode::serialize(&segment).unwrap();
                                        let _ = stream.write_all(&data).await;
                                        let _ = stream.finish().await;
                                    }
                                }
                                info!("âœ“ Live stream ended");
                            });
                        }
                        
                        MessageType::StopLiveStream => {
                            info!("â¹ï¸ Received stop live stream request");
                            // åœæ­¢æµç”Ÿæˆå™¨
                            // TODO: å®ç°åœæ­¢é€»è¾‘
                            let _ = send.write_all(b"OK").await;
                            let _ = send.finish().await;
                        }
                        
                        _ => {
                            debug!("Unhandled message type: {:?}", msg.message_type);
                        }
                    }
                }
                Err(e) => {
                    warn!("Accept bi-stream error: {}", e);
                    break;
                }
            }
        }
        Ok(())
    }
}
```

**å…³é”®ç‚¹**ï¼š
- æ¥æ”¶`StartLiveStream`ä¿¡ä»¤
- åˆ›å»ºå¹¶å¯åŠ¨`LiveStreamGenerator`
- é€šè¿‡QUICå•å‘æµæŒç»­å‘é€è§†é¢‘åˆ†ç‰‡
- å‘é€ç¡®è®¤å“åº”ç»™å¹³å°


### ä»»åŠ¡ 0.6: å¹³å°ç«¯å‘é€ç›´é€šæ’­æ”¾ä¿¡ä»¤

**ç›®æ ‡**ï¼šå¹³å°ç«¯å‘è®¾å¤‡å‘é€ç›´é€šæ’­æ”¾å¯åŠ¨ä¿¡ä»¤ï¼Œå¹¶åˆ›å»ºLiveStreamSourceã€‚

**ä¿®æ”¹æ–‡ä»¶**ï¼š`platform-server/src/http3/handlers.rs`

**å®Œå–„`unified_stream_start`å‡½æ•°**ï¼š
```rust
pub async fn unified_stream_start(
    State(handler): State<Arc<UnifiedStreamHandler>>,
    State((device_manager, _, _, _)): State<AppState>,
    Json(req): Json<UnifiedStreamStartRequest>,
) -> Result<Json<ApiResponse<UnifiedStreamStartResponse>>, StatusCode> {
    let mode = req.mode.to_lowercase();
    
    let config = if let Some(cfg) = req.config {
        StreamConfig {
            low_latency: cfg.low_latency_mode.unwrap_or(true),
            target_latency_ms: cfg.target_latency_ms.unwrap_or(100),
            ..Default::default()
        }
    } else {
        StreamConfig::default()
    };

    let source: Box<dyn crate::streaming::StreamSource> = match mode.as_str() {
        "live" => {
            // ç›´é€šæ’­æ”¾æ¨¡å¼
            let device_id = req.source.device_id
                .ok_or(StatusCode::BAD_REQUEST)?;
            
            // æ£€æŸ¥è®¾å¤‡æ˜¯å¦åœ¨çº¿
            if !device_manager.is_device_online(&device_id) {
                return Err(StatusCode::SERVICE_UNAVAILABLE);
            }

            // è·å–è®¾å¤‡è¿æ¥
            let connection = device_manager
                .get_connection(&device_id)
                .ok_or(StatusCode::NOT_FOUND)?;

            // åˆ›å»ºä¼šè¯ID
            let session_id = Uuid::new_v4();

            // æ„å»ºStartLiveStreamè¯·æ±‚
            let live_request = common::StartLiveStreamRequest {
                quality_preference: "low_latency".to_string(),
                target_latency_ms: config.target_latency_ms,
                target_fps: 30,
                target_bitrate: 2_000_000, // 2 Mbps
            };

            let request_data = bincode::serialize(&live_request)
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

            // å‘é€ä¿¡ä»¤åˆ°è®¾å¤‡
            let signal_msg = ProtocolMessage {
                message_type: MessageType::StartLiveStream,
                payload: request_data,
                sequence_number: 1,
                timestamp: SystemTime::now(),
                session_id,
            };

            let data = bincode::serialize(&signal_msg)
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

            // æ‰“å¼€åŒå‘æµ
            let (mut send, mut recv) = connection
                .open_bi()
                .await
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

            // å‘é€è¯·æ±‚
            send.write_all(&data)
                .await
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
            send.finish()
                .await
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

            // ç­‰å¾…ç¡®è®¤
            let _ = recv
                .read_to_end(1024)
                .await
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

            tracing::info!("âœ“ Live stream started on device: {}", device_id);

            // åˆ›å»ºLiveStreamSource
            // æ³¨æ„ï¼šéœ€è¦ä¼ é€’ä¸€ä¸ªchannelæ¥æ”¶å™¨ï¼Œç”¨äºæ¥æ”¶ä»QUICæ¥çš„åˆ†ç‰‡
            let (segment_tx, segment_rx) = tokio::sync::mpsc::channel(100);
            
            // æ³¨å†Œåˆ°QUICæœåŠ¡å™¨ï¼Œæ¥æ”¶è¯¥session_idçš„åˆ†ç‰‡
            // TODO: å®ç°QUICåˆ†ç‰‡æ¥æ”¶æ³¨å†Œæœºåˆ¶ï¼ˆä»»åŠ¡0.7ï¼‰
            
            let live_source = LiveStreamSource::new(device_id, segment_rx);
            Box::new(live_source)
        }
        "playback" => {
            // å½•åƒå›æ”¾æ¨¡å¼ï¼ˆç°æœ‰ä»£ç ï¼‰
            // ...
        }
        _ => {
            return Err(StatusCode::BAD_REQUEST);
        }
    };

    // å¯åŠ¨æµä¼šè¯
    let session_id = handler
        .start_stream(source, config.clone())
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // æ„å»ºå“åº”
    let response = UnifiedStreamStartResponse {
        session_id: session_id.to_string(),
        stream_url: format!("/api/v1/stream/{}/segments", session_id),
        control_url: format!("/api/v1/stream/{}/control", session_id),
        estimated_latency_ms: config.target_latency_ms,
    };

    Ok(Json(ApiResponse::success(response)))
}
```

**å…³é”®ç‚¹**ï¼š
- å‘è®¾å¤‡å‘é€`StartLiveStream` QUICä¿¡ä»¤
- ç­‰å¾…è®¾å¤‡ç¡®è®¤å“åº”
- åˆ›å»º`LiveStreamSource`å¹¶ä¼ é€’åˆ†ç‰‡æ¥æ”¶å™¨
- éœ€è¦å®ç°QUICåˆ†ç‰‡æ¥æ”¶æ³¨å†Œæœºåˆ¶ï¼ˆä¸‹ä¸€ä»»åŠ¡ï¼‰


### ä»»åŠ¡ 0.7: å¹³å°ç«¯QUICå®æ—¶åˆ†ç‰‡æ¥æ”¶

**ç›®æ ‡**ï¼šå¹³å°ç«¯ä»QUICæ¥æ”¶è®¾å¤‡å‘é€çš„å®æ—¶è§†é¢‘åˆ†ç‰‡ï¼Œå¹¶è½¬å‘åˆ°LiveStreamSourceã€‚

**ä¿®æ”¹æ–‡ä»¶**ï¼š`platform-server/src/quic/server.rs`

**æ·»åŠ åˆ†ç‰‡è·¯ç”±æœºåˆ¶**ï¼š
```rust
use tokio::sync::mpsc;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

/// QUICåˆ†ç‰‡è·¯ç”±å™¨
/// 
/// è´Ÿè´£å°†æ¥æ”¶åˆ°çš„è§†é¢‘åˆ†ç‰‡è·¯ç”±åˆ°å¯¹åº”çš„ä¼šè¯
pub struct SegmentRouter {
    routes: Arc<RwLock<HashMap<Uuid, mpsc::Sender<VideoSegment>>>>,
}

impl SegmentRouter {
    pub fn new() -> Self {
        Self {
            routes: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// æ³¨å†Œä¼šè¯è·¯ç”±
    pub async fn register_session(
        &self,
        session_id: Uuid,
        sender: mpsc::Sender<VideoSegment>,
    ) {
        let mut routes = self.routes.write().await;
        routes.insert(session_id, sender);
        tracing::info!("âœ“ Registered segment route for session: {}", session_id);
    }
    
    /// å–æ¶ˆæ³¨å†Œä¼šè¯è·¯ç”±
    pub async fn unregister_session(&self, session_id: &Uuid) {
        let mut routes = self.routes.write().await;
        routes.remove(session_id);
        tracing::info!("âœ“ Unregistered segment route for session: {}", session_id);
    }
    
    /// è·¯ç”±åˆ†ç‰‡åˆ°å¯¹åº”ä¼šè¯
    pub async fn route_segment(&self, segment: VideoSegment) -> Result<(), String> {
        let routes = self.routes.read().await;
        
        if let Some(sender) = routes.get(&segment.session_id) {
            sender.send(segment).await
                .map_err(|e| format!("Failed to send segment: {}", e))?;
            Ok(())
        } else {
            Err(format!("No route found for session: {}", segment.session_id))
        }
    }
}

/// QUICæœåŠ¡å™¨ï¼ˆä¿®æ”¹ç°æœ‰å®ç°ï¼‰
pub struct QuicServer {
    // ç°æœ‰å­—æ®µ...
    segment_router: Arc<SegmentRouter>,
}

impl QuicServer {
    pub fn new(/* ... */) -> Self {
        Self {
            // ç°æœ‰å­—æ®µ...
            segment_router: Arc::new(SegmentRouter::new()),
        }
    }
    
    pub fn get_segment_router(&self) -> Arc<SegmentRouter> {
        self.segment_router.clone()
    }
    
    /// å¤„ç†è®¾å¤‡è¿æ¥ï¼ˆä¿®æ”¹ç°æœ‰æ–¹æ³•ï¼‰
    async fn handle_connection(
        connection: quinn::Connection,
        segment_router: Arc<SegmentRouter>,
    ) {
        tracing::info!("New device connection from: {}", connection.remote_address());
        
        // å¤„ç†å•å‘æµï¼ˆè§†é¢‘åˆ†ç‰‡ï¼‰
        let router = segment_router.clone();
        tokio::spawn(async move {
            loop {
                match connection.accept_uni().await {
                    Ok(mut recv) => {
                        // è¯»å–åˆ†ç‰‡æ•°æ®
                        match recv.read_to_end(10 * 1024 * 1024).await {
                            Ok(data) => {
                                // è§£æVideoSegment
                                match bincode::deserialize::<VideoSegment>(&data) {
                                    Ok(segment) => {
                                        tracing::debug!(
                                            "ğŸ“¦ Received segment for session: {}",
                                            segment.session_id
                                        );
                                        
                                        // è·¯ç”±åˆ†ç‰‡
                                        if let Err(e) = router.route_segment(segment).await {
                                            tracing::warn!("Failed to route segment: {}", e);
                                        }
                                    }
                                    Err(e) => {
                                        tracing::error!("Failed to deserialize segment: {}", e);
                                    }
                                }
                            }
                            Err(e) => {
                                tracing::error!("Failed to read uni stream: {}", e);
                                break;
                            }
                        }
                    }
                    Err(e) => {
                        tracing::warn!("Accept uni stream error: {}", e);
                        break;
                    }
                }
            }
        });
        
        // å¤„ç†åŒå‘æµï¼ˆæ§åˆ¶ä¿¡ä»¤ï¼‰
        // ... ç°æœ‰ä»£ç  ...
    }
}
```

**åœ¨`unified_stream_start`ä¸­æ³¨å†Œè·¯ç”±**ï¼š
```rust
// åˆ›å»ºLiveStreamSource
let (segment_tx, segment_rx) = tokio::sync::mpsc::channel(100);

// æ³¨å†Œåˆ°QUICæœåŠ¡å™¨
let quic_server = /* è·å–QUICæœåŠ¡å™¨å®ä¾‹ */;
let router = quic_server.get_segment_router();
router.register_session(session_id, segment_tx).await;

let live_source = LiveStreamSource::new(device_id, segment_rx);
```

**å…³é”®ç‚¹**ï¼š
- å®ç°`SegmentRouter`ç®¡ç†ä¼šè¯è·¯ç”±
- ç›‘å¬QUICå•å‘æµæ¥æ”¶è§†é¢‘åˆ†ç‰‡
- æ ¹æ®`session_id`è·¯ç”±åˆ†ç‰‡åˆ°å¯¹åº”çš„`LiveStreamSource`
- è‡ªåŠ¨å¤„ç†ä¼šè¯æ³¨å†Œå’Œå–æ¶ˆæ³¨å†Œ


### ä»»åŠ¡ 0.8: å®Œå–„é›¶ç¼“å†²è½¬å‘æœºåˆ¶

**ç›®æ ‡**ï¼šå®ç°<5msçš„å¹³å°ç«¯å¤„ç†å»¶è¿Ÿï¼Œè¾¹æ¥æ”¶è¾¹è½¬å‘ã€‚

**ä¿®æ”¹æ–‡ä»¶**ï¼š`platform-server/src/streaming/handler.rs`

**å®Œå–„`UnifiedStreamHandler`**ï¼š
```rust
impl UnifiedStreamHandler {
    /// å¯åŠ¨æµä¼šè¯ï¼ˆä¿®æ”¹ç°æœ‰æ–¹æ³•ï¼‰
    pub async fn start_stream(
        &self,
        source: Box<dyn StreamSource>,
        config: StreamConfig,
    ) -> Result<Uuid, StreamError> {
        let session_id = Uuid::new_v4();
        
        // åˆ›å»ºå¹¿æ’­é€šé“ï¼ˆç”¨äºå¤šå®¢æˆ·ç«¯è®¢é˜…ï¼‰
        let (broadcast_tx, _) = broadcast::channel(1000);
        
        // åˆ›å»ºä¼šè¯
        let session = StreamSession {
            session_id,
            source,
            config,
            state: StreamState::Initializing,
            stats: StreamStats::default(),
            created_at: SystemTime::now(),
            broadcast_tx: broadcast_tx.clone(),
        };
        
        self.sessions.insert(session_id, session);
        
        // å¯åŠ¨é›¶ç¼“å†²è½¬å‘ä»»åŠ¡
        self.start_forwarding_task(session_id).await?;
        
        Ok(session_id)
    }
    
    /// å¯åŠ¨é›¶ç¼“å†²è½¬å‘ä»»åŠ¡
    async fn start_forwarding_task(&self, session_id: Uuid) -> Result<(), StreamError> {
        let sessions = self.sessions.clone();
        
        tokio::spawn(async move {
            tracing::info!("ğŸš€ Starting forwarding task for session: {}", session_id);
            
            loop {
                // è·å–ä¼šè¯
                let mut session = match sessions.get_mut(&session_id) {
                    Some(s) => s,
                    None => {
                        tracing::warn!("Session not found: {}", session_id);
                        break;
                    }
                };
                
                // ä»StreamSourceè·å–ä¸‹ä¸€ä¸ªåˆ†ç‰‡
                let segment = match session.source.next_segment().await {
                    Ok(Some(seg)) => seg,
                    Ok(None) => {
                        // æµç»“æŸ
                        tracing::info!("Stream ended for session: {}", session_id);
                        session.state = StreamState::Stopped;
                        break;
                    }
                    Err(e) => {
                        tracing::error!("Error reading segment: {}", e);
                        session.state = StreamState::Error(e.to_string());
                        break;
                    }
                };
                
                // è®°å½•æ¥æ”¶æ—¶é—´
                let receive_time = std::time::Instant::now();
                
                // ç«‹å³å¹¿æ’­åˆ°æ‰€æœ‰è®¢é˜…è€…ï¼ˆé›¶ç¼“å†²è½¬å‘ï¼‰
                if let Err(e) = session.broadcast_tx.send(segment.clone()) {
                    tracing::warn!("No active subscribers: {}", e);
                }
                
                // è®¡ç®—å¤„ç†å»¶è¿Ÿ
                let processing_latency = receive_time.elapsed();
                
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                session.stats.total_segments += 1;
                session.stats.total_bytes += segment.data.len() as u64;
                session.stats.current_latency_ms = processing_latency.as_secs_f64() * 1000.0;
                
                // å¦‚æœå¤„ç†å»¶è¿Ÿ>5msï¼Œè®°å½•è­¦å‘Š
                if processing_latency.as_millis() > 5 {
                    tracing::warn!(
                        "âš ï¸ High processing latency: {}ms (session: {})",
                        processing_latency.as_millis(),
                        session_id
                    );
                }
                
                // æ›´æ–°çŠ¶æ€
                if session.state == StreamState::Initializing {
                    session.state = StreamState::Streaming;
                }
            }
            
            tracing::info!("âœ“ Forwarding task stopped for session: {}", session_id);
        });
        
        Ok(())
    }
}
```

**å…³é”®ä¼˜åŒ–**ï¼š
- ä½¿ç”¨`broadcast::channel`å®ç°å¤šå®¢æˆ·ç«¯é›¶æ‹·è´å¹¿æ’­
- è¾¹æ¥æ”¶è¾¹è½¬å‘ï¼Œæ— é¢å¤–ç¼“å†²
- è®°å½•å¤„ç†å»¶è¿Ÿï¼Œè¶…è¿‡5msæ—¶å‘Šè­¦
- å¼‚æ­¥ä»»åŠ¡ä¸é˜»å¡ä¸»çº¿ç¨‹


### ä»»åŠ¡ 0.9: ç«¯åˆ°ç«¯é›†æˆæµ‹è¯•

**ç›®æ ‡**ï¼šéªŒè¯ç›´é€šæ’­æ”¾åŠŸèƒ½çš„å®Œæ•´æµç¨‹å’Œå»¶è¿ŸæŒ‡æ ‡ã€‚

**æµ‹è¯•æ­¥éª¤**ï¼š

1. **å¯åŠ¨è®¾å¤‡æ¨¡æ‹Ÿå™¨**ï¼š
```bash
cd device-simulator
cargo run -- --device-id device_001 --server-addr 127.0.0.1:8443
```

2. **å¯åŠ¨å¹³å°æœåŠ¡å™¨**ï¼š
```bash
cd platform-server
cargo run
```

3. **å¯åŠ¨å‰ç«¯**ï¼š
```bash
cd web-frontend
npm run dev
```

4. **æµ‹è¯•ç›´é€šæ’­æ”¾**ï¼š
   - åœ¨å‰ç«¯é€‰æ‹©è®¾å¤‡
   - ç‚¹å‡»"å¼€å§‹ç›´é€šæ’­æ”¾"
   - è§‚å¯Ÿè§†é¢‘æ˜¯å¦æ­£å¸¸æ’­æ”¾
   - æ£€æŸ¥å»¶è¿ŸæŒ‡æ ‡

5. **éªŒè¯å»¶è¿Ÿ**ï¼š
```rust
// åœ¨å¹³å°ç«¯æ·»åŠ å»¶è¿Ÿæµ‹è¯•ä»£ç 
#[tokio::test]
async fn test_end_to_end_latency() {
    // å¯åŠ¨æ¨¡æ‹Ÿè®¾å¤‡
    let device = start_mock_device().await;
    
    // å¯åŠ¨ç›´é€šæ’­æ”¾
    let session_id = start_live_stream("device_001").await.unwrap();
    
    // è®¢é˜…åˆ†ç‰‡
    let mut receiver = subscribe_segments(session_id).await.unwrap();
    
    // æµ‹é‡å»¶è¿Ÿ
    let mut latencies = Vec::new();
    for _ in 0..100 {
        let segment = receiver.recv().await.unwrap();
        
        // è®¡ç®—ç«¯åˆ°ç«¯å»¶è¿Ÿ
        let capture_time = segment.timestamp; // è®¾å¤‡ç«¯æ•è·æ—¶é—´
        let receive_time = SystemTime::now(); // å¹³å°ç«¯æ¥æ”¶æ—¶é—´
        let latency = receive_time.duration_since(UNIX_EPOCH).unwrap().as_secs_f64() - capture_time;
        
        latencies.push(latency * 1000.0); // è½¬æ¢ä¸ºæ¯«ç§’
    }
    
    // è®¡ç®—å¹³å‡å»¶è¿Ÿ
    let avg_latency = latencies.iter().sum::<f64>() / latencies.len() as f64;
    let max_latency = latencies.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
    
    println!("Average latency: {:.2}ms", avg_latency);
    println!("Max latency: {:.2}ms", max_latency);
    
    // éªŒè¯å»¶è¿Ÿ<100ms
    assert!(avg_latency < 100.0, "Average latency too high: {:.2}ms", avg_latency);
    assert!(max_latency < 200.0, "Max latency too high: {:.2}ms", max_latency);
}
```

6. **æµ‹è¯•æ’­æ”¾æ§åˆ¶**ï¼š
   - æµ‹è¯•æš‚åœåŠŸèƒ½
   - æµ‹è¯•æ¢å¤åŠŸèƒ½
   - æµ‹è¯•åœæ­¢åŠŸèƒ½

7. **å‹åŠ›æµ‹è¯•**ï¼š
   - æµ‹è¯•å¤šå®¢æˆ·ç«¯å¹¶å‘è§‚çœ‹
   - æµ‹è¯•é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§
   - æµ‹è¯•ç½‘ç»œæŠ–åŠ¨æƒ…å†µ

**éªŒæ”¶æ ‡å‡†**ï¼š
- âœ… è§†é¢‘èƒ½å¤Ÿæ­£å¸¸æ’­æ”¾
- âœ… ç«¯åˆ°ç«¯å»¶è¿Ÿ<100ms
- âœ… å¹³å°ç«¯å¤„ç†å»¶è¿Ÿ<5ms
- âœ… æ”¯æŒæš‚åœ/æ¢å¤æ§åˆ¶
- âœ… æ”¯æŒå¤šå®¢æˆ·ç«¯å¹¶å‘è§‚çœ‹
- âœ… é•¿æ—¶é—´è¿è¡Œæ— å†…å­˜æ³„æ¼

## å»¶è¿Ÿä¼˜åŒ–å»ºè®®

### 1. è®¾å¤‡ç«¯ä¼˜åŒ–
- ä½¿ç”¨ç¡¬ä»¶ç¼–ç å™¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
- å‡å°GOPå¤§å°ï¼ˆæ›´é¢‘ç¹çš„å…³é”®å¸§ï¼‰
- ä½¿ç”¨æ›´å¿«çš„ç¼–ç preset

### 2. ç½‘ç»œä¼˜åŒ–
- ä½¿ç”¨QUICçš„0-RTTè¿æ¥
- å¯ç”¨QUICçš„å¿«é€Ÿé‡ä¼ 
- ä¼˜åŒ–MTUå¤§å°

### 3. å¹³å°ç«¯ä¼˜åŒ–
- ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯
- å‡å°‘åºåˆ—åŒ–/ååºåˆ—åŒ–å¼€é”€
- ä½¿ç”¨æ›´é«˜æ•ˆçš„æ•°æ®ç»“æ„

### 4. å‰ç«¯ä¼˜åŒ–
- å‡å°MSEç¼“å†²åŒºå¤§å°
- ä½¿ç”¨ä½å»¶è¿Ÿæ’­æ”¾æ¨¡å¼
- åŠæ—¶æ¸…ç†æ—§ç¼“å†²

## æ•…éšœæ’æŸ¥

### é—®é¢˜1ï¼šç¼–ç å™¨åˆå§‹åŒ–å¤±è´¥
**åŸå› **ï¼šffmpegåº“æœªå®‰è£…æˆ–ç‰ˆæœ¬ä¸å…¼å®¹
**è§£å†³**ï¼š
```bash
# Linux
sudo apt-get install libavcodec-dev libavformat-dev libavutil-dev libswscale-dev

# macOS
brew install ffmpeg

# Windows
# ä¸‹è½½ffmpegé¢„ç¼–è¯‘åº“å¹¶é…ç½®ç¯å¢ƒå˜é‡
```

### é—®é¢˜2ï¼šå±å¹•æ•è·å¤±è´¥
**åŸå› **ï¼šæƒé™ä¸è¶³æˆ–æ˜¾ç¤ºå™¨é…ç½®é—®é¢˜
**è§£å†³**ï¼š
- Linux: ç¡®ä¿æœ‰X11è®¿é—®æƒé™
- macOS: åœ¨ç³»ç»Ÿåå¥½è®¾ç½®ä¸­æˆäºˆå±å¹•å½•åˆ¶æƒé™
- Windows: ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ

### é—®é¢˜3ï¼šå»¶è¿Ÿè¿‡é«˜
**åŸå› **ï¼šç¼–ç å‚æ•°é…ç½®ä¸å½“æˆ–ç½‘ç»œé—®é¢˜
**è§£å†³**ï¼š
- æ£€æŸ¥ç¼–ç presetï¼ˆä½¿ç”¨ultrafastï¼‰
- æ£€æŸ¥tuneå‚æ•°ï¼ˆä½¿ç”¨zerolatencyï¼‰
- æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿå’Œä¸¢åŒ…ç‡
- å‡å°GOPå¤§å°
- é™ä½åˆ†è¾¨ç‡æˆ–ç ç‡

### é—®é¢˜4ï¼šè§†é¢‘å¡é¡¿
**åŸå› **ï¼šå¸§ç‡ä¸ç¨³å®šæˆ–ç¼“å†²ç­–ç•¥ä¸å½“
**è§£å†³**ï¼š
- ç¡®ä¿å¸§ç‡æ§åˆ¶ç²¾ç¡®ï¼ˆä½¿ç”¨tokio::time::intervalï¼‰
- è°ƒæ•´å‰ç«¯ç¼“å†²ç­–ç•¥
- æ£€æŸ¥CPUå ç”¨ç‡

## æ€»ç»“

æœ¬å®æ–½æ–¹æ¡ˆè¯¦ç»†æè¿°äº†ç›´é€šæ’­æ”¾åŠŸèƒ½çš„å®Œæ•´å®ç°æµç¨‹ï¼ŒåŒ…æ‹¬ï¼š

1. **è®¾å¤‡ç«¯**ï¼šå±å¹•å½•åˆ¶ã€H.264ç¼–ç ã€å®æ—¶æµç”Ÿæˆ
2. **ä¿¡ä»¤æµç¨‹**ï¼šå¹³å°â†’è®¾å¤‡çš„å¯åŠ¨ä¿¡ä»¤ï¼Œè®¾å¤‡â†’å¹³å°çš„ç¡®è®¤å“åº”
3. **æ•°æ®ä¼ è¾“**ï¼šQUICå®æ—¶åˆ†ç‰‡ä¼ è¾“ï¼Œé›¶ç¼“å†²è½¬å‘
4. **å‰ç«¯æ’­æ”¾**ï¼šMSEæ’­æ”¾å™¨ï¼Œæ™ºèƒ½ç¼“å†²ç­–ç•¥

é€šè¿‡éµå¾ªæœ¬æ–¹æ¡ˆï¼Œå¯ä»¥å®ç°ç«¯åˆ°ç«¯å»¶è¿Ÿ<100msçš„ä½å»¶è¿Ÿç›´é€šæ’­æ”¾åŠŸèƒ½ã€‚

## ä¸‹ä¸€æ­¥

1. å¼€å§‹æ‰§è¡Œä»»åŠ¡0.1ï¼šæ·»åŠ å±å¹•å½•åˆ¶ä¾èµ–
2. æŒ‰é¡ºåºå®Œæˆä»»åŠ¡0.2-0.9
3. è¿›è¡Œç«¯åˆ°ç«¯é›†æˆæµ‹è¯•
4. æ ¹æ®æµ‹è¯•ç»“æœè¿›è¡Œä¼˜åŒ–è°ƒæ•´

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-12-13  
**ä½œè€…**: ç³»ç»Ÿæ¶æ„å›¢é˜Ÿ
