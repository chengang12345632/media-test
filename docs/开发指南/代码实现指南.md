# HTTP3/QUICè§†é¢‘æµä¼ è¾“ç³»ç»Ÿ - ä»£ç å®ç°æŒ‡å—

## æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£ç‰ˆæœ¬ | v1.0 |
| åˆ›å»ºæ—¥æœŸ | 2025-12-12 |
| ç›®æ ‡è¯»è€… | å¼€å‘äººå‘˜ |
| å‰ç½®æ–‡æ¡£ | ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£ã€å¼€å‘æ‰‹å†Œ |

## ç›®å½•

1. [å®ç°è·¯çº¿å›¾](#å®ç°è·¯çº¿å›¾)
2. [éœ€è¦è¡¥å……çš„å†…å®¹](#éœ€è¦è¡¥å……çš„å†…å®¹)
3. [é¡¹ç›®åˆå§‹åŒ–](#é¡¹ç›®åˆå§‹åŒ–)
4. [æ ¸å¿ƒæ¨¡å—å®ç°é¡ºåº](#æ ¸å¿ƒæ¨¡å—å®ç°é¡ºåº)
5. [è¯¦ç»†å®ç°æ¸…å•](#è¯¦ç»†å®ç°æ¸…å•)
6. [æµ‹è¯•ç­–ç•¥](#æµ‹è¯•ç­–ç•¥)
7. [å¼€å‘é‡Œç¨‹ç¢‘](#å¼€å‘é‡Œç¨‹ç¢‘)

---

## å®ç°è·¯çº¿å›¾

### æ€»ä½“æ—¶é—´è§„åˆ’

```
é˜¶æ®µ1: é¡¹ç›®åˆå§‹åŒ– (1å‘¨)
    â†“
é˜¶æ®µ2: å¹³å°ç«¯æ ¸å¿ƒ (3å‘¨)
    â†“
é˜¶æ®µ3: è®¾å¤‡ç«¯å®ç° (2å‘¨)
    â†“
é˜¶æ®µ4: å‰ç«¯å¼€å‘ (2å‘¨)
    â†“
é˜¶æ®µ5: é›†æˆæµ‹è¯• (1å‘¨)
    â†“
é˜¶æ®µ6: ä¼˜åŒ–å’Œæ–‡æ¡£ (1å‘¨)

æ€»è®¡: 10å‘¨ (çº¦2.5ä¸ªæœˆ)
```

### äººå‘˜é…ç½®å»ºè®®

| è§’è‰² | äººæ•° | ä¸»è¦èŒè´£ |
|------|------|---------|
| åç«¯å·¥ç¨‹å¸ˆ | 2äºº | å¹³å°ç«¯å’Œè®¾å¤‡ç«¯å¼€å‘ |
| å‰ç«¯å·¥ç¨‹å¸ˆ | 1äºº | Webå‰ç«¯å¼€å‘ |
| æµ‹è¯•å·¥ç¨‹å¸ˆ | 1äºº | æµ‹è¯•ç”¨ä¾‹å’Œè‡ªåŠ¨åŒ–æµ‹è¯• |
| æ¶æ„å¸ˆ | 1äºº | æŠ€æœ¯æŒ‡å¯¼å’Œä»£ç å®¡æŸ¥ |

---

## éœ€è¦è¡¥å……çš„å†…å®¹

### 1. é¡¹ç›®é…ç½®æ–‡ä»¶

#### 1.1 Cargoå·¥ä½œç©ºé—´é…ç½®

**æ–‡ä»¶**: `Cargo.toml` (æ ¹ç›®å½•)

```toml
[workspace]
members = [
    "platform-server",
    "device-simulator",
    "common",
]

[workspace.package]
version = "1.0.0"
edition = "2021"
authors = ["Your Team <team@example.com>"]
license = "MIT"

[workspace.dependencies]
# QUICç›¸å…³
quinn = "0.10"
rustls = "0.21"
rcgen = "0.11"

# HTTP3ç›¸å…³
h3 = "0.0.3"
h3-quinn = "0.0.4"

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.35", features = ["full"] }
tokio-util = "0.7"

# Webæ¡†æ¶
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
bincode = "1.3"

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "1.0"

# å…¶ä»–å·¥å…·
uuid = { version = "1.6", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
bytes = "1.5"
futures = "0.3"
```

#### 1.2 å¹³å°ç«¯é…ç½®

**æ–‡ä»¶**: `platform-server/Cargo.toml`

```toml
[package]
name = "platform-server"
version.workspace = true
edition.workspace = true

[dependencies]
# å·¥ä½œç©ºé—´ä¾èµ–
quinn.workspace = true
h3.workspace = true
h3-quinn.workspace = true
tokio.workspace = true
axum.workspace = true
serde.workspace = true
serde_json.workspace = true
tracing.workspace = true
anyhow.workspace = true
uuid.workspace = true

# æœ¬åœ°ä¾èµ–
common = { path = "../common" }

# ç‰¹å®šä¾èµ–
dashmap = "5.5"
lru = "0.12"
walkdir = "2.4"
config = "0.13"
```

#### 1.3 è®¾å¤‡ç«¯é…ç½®

**æ–‡ä»¶**: `device-simulator/Cargo.toml`

```toml
[package]
name = "device-simulator"
version.workspace = true
edition.workspace = true

[dependencies]
# å·¥ä½œç©ºé—´ä¾èµ–
quinn.workspace = true
tokio.workspace = true
serde.workspace = true
tracing.workspace = true
anyhow.workspace = true
uuid.workspace = true

# æœ¬åœ°ä¾èµ–
common = { path = "../common" }

# ç‰¹å®šä¾èµ–
mp4 = "0.14"
h264-reader = "0.7"
```

#### 1.4 å‰ç«¯é…ç½®

**æ–‡ä»¶**: `web-frontend/package.json`

```json
{
  "name": "video-streaming-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.3.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0",
    "eslint": "^8.55.0",
    "prettier": "^3.1.0"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext ts,tsx",
    "format": "prettier --write src"
  }
}
```

### 2. å…±äº«ä»£ç åº“

éœ€è¦åˆ›å»ºä¸€ä¸ª `common` åŒ…ï¼ŒåŒ…å«å…±äº«çš„ç±»å‹å®šä¹‰å’Œå·¥å…·å‡½æ•°ã€‚

**æ–‡ä»¶**: `common/Cargo.toml`

```toml
[package]
name = "common"
version.workspace = true
edition.workspace = true

[dependencies]
serde.workspace = true
uuid.workspace = true
bytes.workspace = true
thiserror.workspace = true
```

**æ–‡ä»¶**: `common/src/lib.rs`

```rust
pub mod types;
pub mod protocol;
pub mod error;
pub mod utils;

pub use types::*;
pub use protocol::*;
pub use error::*;
```

### 3. æ ¸å¿ƒç±»å‹å®šä¹‰

**æ–‡ä»¶**: `common/src/types.rs`

```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use std::time::SystemTime;

/// è§†é¢‘åˆ†ç‰‡
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoSegment {
    pub stream_type: u8,
    pub segment_id: Uuid,
    pub timestamp: f64,
    pub duration: f64,
    pub frame_count: u32,
    pub flags: u8,
    pub data_length: u32,
    pub data: Vec<u8>,
}

/// åè®®æ¶ˆæ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtocolMessage {
    pub message_type: MessageType,
    pub payload: Vec<u8>,
    pub sequence_number: u64,
    pub timestamp: SystemTime,
    pub session_id: Uuid,
}

/// æ¶ˆæ¯ç±»å‹
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[repr(u8)]
pub enum MessageType {
    SessionStart = 0x01,
    SessionEnd = 0x02,
    SeekRequest = 0x03,
    RateChange = 0x04,
    PauseRequest = 0x05,
    ResumeRequest = 0x06,
    ErrorReport = 0x07,
    StatsRequest = 0x08,
    StatusResponse = 0x09,
    PlaybackControl = 0x0C,
    FileListQuery = 0x0D,
    FileListResponse = 0x0E,
    FileRequest = 0x0B,
}

/// è®¾å¤‡ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceInfo {
    pub device_id: String,
    pub device_name: String,
    pub device_type: DeviceType,
    pub connection_status: ConnectionStatus,
    pub connection_time: SystemTime,
    pub last_heartbeat: SystemTime,
    pub capabilities: DeviceCapabilities,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceType {
    Camera,
    Recorder,
    Simulator,
    Gateway,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConnectionStatus {
    Online,
    Offline,
    Reconnecting,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceCapabilities {
    pub max_resolution: String,
    pub supported_formats: Vec<String>,
    pub max_bitrate: u64,
    pub supports_playback_control: bool,
    pub supports_recording: bool,
}

/// å½•åƒä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecordingInfo {
    pub file_id: String,
    pub device_id: String,
    pub file_name: String,
    pub file_path: String,
    pub file_size: u64,
    pub duration: f64,
    pub format: String,
    pub resolution: String,
    pub bitrate: u64,
    pub frame_rate: f64,
    pub created_time: SystemTime,
    pub modified_time: SystemTime,
}
```


### 4. é”™è¯¯å¤„ç†

**æ–‡ä»¶**: `common/src/error.rs`

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum VideoStreamError {
    #[error("QUIC connection error: {0}")]
    QuicError(#[from] quinn::ConnectionError),
    
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
    
    #[error("Serialization error: {0}")]
    SerdeError(#[from] serde_json::Error),
    
    #[error("Device not found: {0}")]
    DeviceNotFound(String),
    
    #[error("Recording not found: {0}")]
    RecordingNotFound(String),
    
    #[error("Session expired: {0}")]
    SessionExpired(String),
    
    #[error("Invalid parameter: {0}")]
    InvalidParameter(String),
    
    #[error("Protocol error: {0}")]
    ProtocolError(String),
}

pub type Result<T> = std::result::Result<T, VideoStreamError>;
```

---

## é¡¹ç›®åˆå§‹åŒ–

### æ­¥éª¤1: åˆ›å»ºé¡¹ç›®ç»“æ„

```bash
# åˆ›å»ºæ ¹ç›®å½•
mkdir video-streaming-demo
cd video-streaming-demo

# åˆ›å»ºå·¥ä½œç©ºé—´
cargo new --lib common
cargo new --bin platform-server
cargo new --bin device-simulator

# åˆ›å»ºå‰ç«¯é¡¹ç›®
npm create vite@latest web-frontend -- --template react-ts

# åˆ›å»ºå…¶ä»–ç›®å½•
mkdir -p recordings logs test-videos docs
```

### æ­¥éª¤2: é…ç½®Git

**æ–‡ä»¶**: `.gitignore`

```gitignore
# Rust
target/
Cargo.lock
**/*.rs.bk

# Node
node_modules/
dist/
.env.local

# æ—¥å¿—å’Œæ•°æ®
logs/
recordings/
test-videos/
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
```

### æ­¥éª¤3: é…ç½®å¼€å‘å·¥å…·

**æ–‡ä»¶**: `.vscode/settings.json`

```json
{
  "rust-analyzer.checkOnSave.command": "clippy",
  "rust-analyzer.cargo.features": "all",
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[rust]": {
    "editor.defaultFormatter": "rust-lang.rust-analyzer"
  },
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  }
}
```

**æ–‡ä»¶**: `rustfmt.toml`

```toml
edition = "2021"
max_width = 100
tab_spaces = 4
use_small_heuristics = "Max"
```

---

## æ ¸å¿ƒæ¨¡å—å®ç°é¡ºåº

### é˜¶æ®µ1: åŸºç¡€è®¾æ–½ (ç¬¬1å‘¨)

#### 1.1 å…±äº«ç±»å‹å®šä¹‰
- [ ] `common/src/types.rs` - æ ¸å¿ƒæ•°æ®ç»“æ„
- [ ] `common/src/protocol.rs` - åè®®å®šä¹‰
- [ ] `common/src/error.rs` - é”™è¯¯ç±»å‹
- [ ] `common/src/utils.rs` - å·¥å…·å‡½æ•°

#### 1.2 é…ç½®ç®¡ç†
- [ ] `platform-server/src/config.rs` - å¹³å°ç«¯é…ç½®
- [ ] `device-simulator/src/config.rs` - è®¾å¤‡ç«¯é…ç½®

#### 1.3 æ—¥å¿—ç³»ç»Ÿ
- [ ] `platform-server/src/logging.rs` - æ—¥å¿—åˆå§‹åŒ–
- [ ] `device-simulator/src/logging.rs` - æ—¥å¿—åˆå§‹åŒ–

### é˜¶æ®µ2: å¹³å°ç«¯æ ¸å¿ƒ (ç¬¬2-4å‘¨)

#### 2.1 QUICæœåŠ¡å™¨ (ç¬¬2å‘¨)
- [ ] `platform-server/src/quic/server.rs` - QUICæœåŠ¡å™¨
- [ ] `platform-server/src/quic/connection.rs` - è¿æ¥ç®¡ç†
- [ ] `platform-server/src/quic/stream.rs` - æµç®¡ç†

**å®ç°è¦ç‚¹**:
```rust
// platform-server/src/quic/server.rs
use quinn::{Endpoint, ServerConfig};

pub struct QuicServer {
    endpoint: Endpoint,
    connections: Arc<DashMap<Uuid, Connection>>,
}

impl QuicServer {
    pub async fn new(config: ServerConfig, addr: SocketAddr) -> Result<Self> {
        let endpoint = Endpoint::server(config, addr)?;
        Ok(Self {
            endpoint,
            connections: Arc::new(DashMap::new()),
        })
    }
    
    pub async fn run(&self) -> Result<()> {
        while let Some(conn) = self.endpoint.accept().await {
            let connections = self.connections.clone();
            tokio::spawn(async move {
                if let Err(e) = handle_connection(conn, connections).await {
                    error!("Connection error: {}", e);
                }
            });
        }
        Ok(())
    }
}

async fn handle_connection(
    conn: quinn::Connecting,
    connections: Arc<DashMap<Uuid, Connection>>,
) -> Result<()> {
    let connection = conn.await?;
    let session_id = Uuid::new_v4();
    
    info!("New connection: {}", session_id);
    
    // å¤„ç†åŒå‘æµï¼ˆæ§åˆ¶ä¿¡ä»¤ï¼‰
    tokio::spawn(handle_bi_streams(connection.clone(), session_id));
    
    // å¤„ç†å•å‘æµï¼ˆè§†é¢‘æ•°æ®ï¼‰
    tokio::spawn(handle_uni_streams(connection.clone(), session_id));
    
    connections.insert(session_id, connection);
    
    Ok(())
}
```

#### 2.2 HTTP3æœåŠ¡å™¨ (ç¬¬2å‘¨)
- [ ] `platform-server/src/http3/server.rs` - HTTP3æœåŠ¡å™¨
- [ ] `platform-server/src/http3/handlers.rs` - è¯·æ±‚å¤„ç†å™¨
- [ ] `platform-server/src/http3/routes.rs` - è·¯ç”±å®šä¹‰

**å®ç°è¦ç‚¹**:
```rust
// platform-server/src/http3/server.rs
use axum::{Router, routing::{get, post, delete}};

pub fn create_router() -> Router {
    Router::new()
        // è®¾å¤‡ç®¡ç†
        .route("/api/v1/devices", get(handlers::get_devices))
        .route("/api/v1/devices/:device_id", get(handlers::get_device_detail))
        
        // å½•åƒç®¡ç†
        .route("/api/v1/devices/:device_id/recordings", 
               get(handlers::get_recordings))
        
        // ç›´é€šæ’­æ”¾
        .route("/api/v1/devices/:device_id/live-stream", 
               post(handlers::start_live_stream))
        .route("/api/v1/stream/:session_id", 
               delete(handlers::stop_stream))
        
        // å½•åƒå›æ”¾
        .route("/api/v1/recordings/:file_id/playback", 
               post(handlers::start_playback))
        .route("/api/v1/playback/:session_id/control", 
               post(handlers::playback_control))
        
        // CORSå’Œæ—¥å¿—ä¸­é—´ä»¶
        .layer(tower_http::cors::CorsLayer::permissive())
        .layer(tower_http::trace::TraceLayer::new_for_http())
}
```

#### 2.3 åè®®è½¬æ¢å™¨ (ç¬¬3å‘¨)
- [ ] `platform-server/src/protocol/converter.rs` - åè®®è½¬æ¢
- [ ] `platform-server/src/protocol/quic_to_http3.rs` - QUICâ†’HTTP3
- [ ] `platform-server/src/protocol/http3_to_quic.rs` - HTTP3â†’QUIC

**å®ç°è¦ç‚¹**:
```rust
// platform-server/src/protocol/converter.rs
pub struct ProtocolConverter {
    quic_sessions: Arc<DashMap<Uuid, QUICSession>>,
    http3_clients: Arc<DashMap<String, HTTP3Client>>,
}

impl ProtocolConverter {
    pub async fn convert_quic_to_http3(
        &self,
        segment: VideoSegment,
        target_clients: Vec<String>,
    ) -> Result<()> {
        // 1. æ„å»ºHTTP3è¯·æ±‚
        let http3_segment = self.build_http3_segment(&segment)?;
        
        // 2. å¹¶å‘åˆ†å‘åˆ°æ‰€æœ‰å®¢æˆ·ç«¯
        let tasks: Vec<_> = target_clients
            .iter()
            .map(|client_id| {
                let segment = http3_segment.clone();
                let clients = self.http3_clients.clone();
                async move {
                    if let Some(client) = clients.get(client_id) {
                        client.send_segment(segment).await
                    } else {
                        Err(VideoStreamError::InvalidParameter(
                            format!("Client not found: {}", client_id)
                        ))
                    }
                }
            })
            .collect();
        
        futures::future::try_join_all(tasks).await?;
        
        Ok(())
    }
}
```

#### 2.4 è®¾å¤‡ç®¡ç†å™¨ (ç¬¬3å‘¨)
- [ ] `platform-server/src/device/manager.rs` - è®¾å¤‡ç®¡ç†
- [ ] `platform-server/src/device/registry.rs` - è®¾å¤‡æ³¨å†Œè¡¨
- [ ] `platform-server/src/device/heartbeat.rs` - å¿ƒè·³æ£€æµ‹

#### 2.5 å½•åƒç®¡ç†å™¨ (ç¬¬3å‘¨)
- [ ] `platform-server/src/recording/manager.rs` - å½•åƒç®¡ç†
- [ ] `platform-server/src/recording/scanner.rs` - æ–‡ä»¶æ‰«æ
- [ ] `platform-server/src/recording/metadata.rs` - å…ƒæ•°æ®è§£æ

**å®ç°è¦ç‚¹**:
```rust
// platform-server/src/recording/scanner.rs
use walkdir::WalkDir;

pub struct RecordingScanner {
    storage_root: PathBuf,
    cache: Arc<DashMap<String, RecordingInfo>>,
}

impl RecordingScanner {
    pub async fn scan_device_recordings(
        &self,
        device_id: &str,
    ) -> Result<Vec<RecordingInfo>> {
        let device_path = self.storage_root.join(device_id);
        let mut recordings = Vec::new();
        
        for entry in WalkDir::new(device_path)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            if entry.file_type().is_file() {
                if let Some(ext) = entry.path().extension() {
                    if ext == "h264" || ext == "mp4" {
                        let info = self.parse_recording(entry.path()).await?;
                        recordings.push(info);
                    }
                }
            }
        }
        
        recordings.sort_by(|a, b| b.created_time.cmp(&a.created_time));
        Ok(recordings)
    }
}
```

#### 2.6 åˆ†å‘ç®¡ç†å™¨ (ç¬¬4å‘¨)
- [ ] `platform-server/src/distribution/manager.rs` - åˆ†å‘ç®¡ç†
- [ ] `platform-server/src/distribution/subscriber.rs` - è®¢é˜…ç®¡ç†
- [ ] `platform-server/src/distribution/quality.rs` - è´¨é‡é€‚é…

#### 2.7 å»¶è¿Ÿç›‘æ§å™¨ (ç¬¬4å‘¨)
- [ ] `platform-server/src/latency/monitor.rs` - å»¶è¿Ÿç›‘æ§
- [ ] `platform-server/src/latency/statistics.rs` - ç»Ÿè®¡åˆ†æ
- [ ] `platform-server/src/latency/alert.rs` - å‘Šè­¦ç®¡ç†

### é˜¶æ®µ3: è®¾å¤‡ç«¯å®ç° (ç¬¬5-6å‘¨)

#### 3.1 QUICå®¢æˆ·ç«¯ (ç¬¬5å‘¨)
- [ ] `device-simulator/src/quic/client.rs` - QUICå®¢æˆ·ç«¯
- [ ] `device-simulator/src/quic/connection.rs` - è¿æ¥ç®¡ç†
- [ ] `device-simulator/src/quic/reconnect.rs` - é‡è¿æœºåˆ¶

**å®ç°è¦ç‚¹**:
```rust
// device-simulator/src/quic/client.rs
pub struct QuicClient {
    endpoint: Endpoint,
    connection: Option<Connection>,
    config: ClientConfig,
}

impl QuicClient {
    pub async fn connect(&mut self, server_addr: SocketAddr) -> Result<()> {
        let conn = self.endpoint
            .connect(server_addr, "localhost")?
            .await?;
        
        self.connection = Some(conn);
        
        // å‘é€SessionStartæ¶ˆæ¯
        self.send_session_start().await?;
        
        Ok(())
    }
    
    pub async fn send_segment(&mut self, segment: VideoSegment) -> Result<()> {
        let conn = self.connection.as_ref()
            .ok_or(VideoStreamError::ProtocolError("Not connected".into()))?;
        
        let mut stream = conn.open_uni().await?;
        
        // åºåˆ—åŒ–å¹¶å‘é€
        let data = bincode::serialize(&segment)?;
        stream.write_all(&data).await?;
        stream.finish().await?;
        
        Ok(())
    }
}
```

#### 3.2 è§†é¢‘æ–‡ä»¶è¯»å–å™¨ (ç¬¬5å‘¨)
- [ ] `device-simulator/src/video/reader.rs` - æ–‡ä»¶è¯»å–
- [ ] `device-simulator/src/video/h264_parser.rs` - H.264è§£æ
- [ ] `device-simulator/src/video/mp4_parser.rs` - MP4è§£æ

**å®ç°è¦ç‚¹**:
```rust
// device-simulator/src/video/reader.rs
pub struct VideoFileReader {
    file_path: PathBuf,
    file_handle: tokio::fs::File,
    format: VideoFormat,
    current_position: u64,
}

impl VideoFileReader {
    pub async fn read_next_frame(&mut self) -> Result<Option<VideoFrame>> {
        match self.format {
            VideoFormat::H264 => self.read_h264_frame().await,
            VideoFormat::MP4 => self.read_mp4_frame().await,
        }
    }
}
```

#### 3.3 åˆ†ç‰‡å™¨ (ç¬¬5å‘¨)
- [ ] `device-simulator/src/segmenter/mod.rs` - åˆ†ç‰‡å™¨
- [ ] `device-simulator/src/segmenter/frame.rs` - å¸§çº§åˆ†ç‰‡
- [ ] `device-simulator/src/segmenter/gop.rs` - GOPåˆ†ç‰‡

#### 3.4 æ’­æ”¾æ§åˆ¶å™¨ (ç¬¬6å‘¨)
- [ ] `device-simulator/src/controller/playback.rs` - æ’­æ”¾æ§åˆ¶
- [ ] `device-simulator/src/controller/seek.rs` - å®šä½æ§åˆ¶
- [ ] `device-simulator/src/controller/rate.rs` - é€Ÿç‡æ§åˆ¶

#### 3.5 å…³é”®å¸§ç´¢å¼• (ç¬¬6å‘¨)
- [ ] `device-simulator/src/index/keyframe.rs` - å…³é”®å¸§ç´¢å¼•
- [ ] `device-simulator/src/index/builder.rs` - ç´¢å¼•æ„å»º
- [ ] `device-simulator/src/index/search.rs` - ç´¢å¼•æŸ¥æ‰¾

**å®ç°è¦ç‚¹**:
```rust
// device-simulator/src/index/keyframe.rs
pub struct KeyframeIndex {
    entries: Vec<KeyframeEntry>,
    total_duration: f64,
}

#[derive(Debug, Clone)]
pub struct KeyframeEntry {
    pub timestamp: f64,
    pub file_offset: u64,
    pub frame_size: u32,
}

impl KeyframeIndex {
    pub fn find_nearest_keyframe(&self, position: f64) -> Option<&KeyframeEntry> {
        self.entries
            .iter()
            .rev()
            .find(|entry| entry.timestamp <= position)
    }
}
```

#### 3.6 ä¸Šä¼ å™¨ (ç¬¬6å‘¨)
- [ ] `device-simulator/src/uploader/mod.rs` - ä¸Šä¼ å™¨
- [ ] `device-simulator/src/uploader/scheduler.rs` - è°ƒåº¦å™¨
- [ ] `device-simulator/src/uploader/stats.rs` - ç»Ÿè®¡

### é˜¶æ®µ4: å‰ç«¯å¼€å‘ (ç¬¬7-8å‘¨)

#### 4.1 HTTP3å®¢æˆ·ç«¯ (ç¬¬7å‘¨)
- [ ] `web-frontend/src/services/http3Client.ts` - HTTP3å®¢æˆ·ç«¯
- [ ] `web-frontend/src/services/api.ts` - APIå°è£…
- [ ] `web-frontend/src/services/websocket.ts` - WebSocketç®¡ç†

**å®ç°è¦ç‚¹**:
```typescript
// web-frontend/src/services/http3Client.ts
export class HTTP3Client {
  private baseUrl: string;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  async get<T>(path: string): Promise<ApiResponse<T>> {
    const response = await fetch(`${this.baseUrl}${path}`);
    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }
    return response.json();
  }
  
  async post<T>(path: string, data: any): Promise<ApiResponse<T>> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }
    return response.json();
  }
}
```

#### 4.2 è§†é¢‘æ’­æ”¾å™¨ç»„ä»¶ (ç¬¬7å‘¨)
- [ ] `web-frontend/src/components/VideoPlayer.tsx` - æ’­æ”¾å™¨
- [ ] `web-frontend/src/components/ControlPanel.tsx` - æ§åˆ¶é¢æ¿
- [ ] `web-frontend/src/components/ProgressBar.tsx` - è¿›åº¦æ¡

**å®ç°è¦ç‚¹**:
```typescript
// web-frontend/src/components/VideoPlayer.tsx
export const VideoPlayer: React.FC<VideoPlayerProps> = ({ sessionId }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [mediaSource, setMediaSource] = useState<MediaSource | null>(null);
  const [sourceBuffer, setSourceBuffer] = useState<SourceBuffer | null>(null);
  
  useEffect(() => {
    const ms = new MediaSource();
    setMediaSource(ms);
    
    if (videoRef.current) {
      videoRef.current.src = URL.createObjectURL(ms);
    }
    
    ms.addEventListener('sourceopen', () => {
      const sb = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
      setSourceBuffer(sb);
    });
  }, []);
  
  // æ¥æ”¶è§†é¢‘åˆ†ç‰‡
  useEffect(() => {
    if (!sourceBuffer) return;
    
    const ws = new WebSocket(`wss://localhost:8443/api/v1/stream/${sessionId}/events`);
    
    ws.onmessage = async (event) => {
      const message = JSON.parse(event.data);
      if (message.event_type === 'segment_received') {
        // è·å–è§†é¢‘åˆ†ç‰‡
        const segment = await fetchSegment(sessionId, message.data.segment_id);
        if (!sourceBuffer.updating) {
          sourceBuffer.appendBuffer(segment);
        }
      }
    };
    
    return () => ws.close();
  }, [sourceBuffer, sessionId]);
  
  return (
    <div className="video-player">
      <video ref={videoRef} controls />
      <ControlPanel sessionId={sessionId} />
    </div>
  );
};
```

#### 4.3 è®¾å¤‡ç®¡ç†ç»„ä»¶ (ç¬¬7å‘¨)
- [ ] `web-frontend/src/components/DeviceList.tsx` - è®¾å¤‡åˆ—è¡¨
- [ ] `web-frontend/src/components/DeviceCard.tsx` - è®¾å¤‡å¡ç‰‡
- [ ] `web-frontend/src/components/DeviceDetail.tsx` - è®¾å¤‡è¯¦æƒ…

#### 4.4 å½•åƒç®¡ç†ç»„ä»¶ (ç¬¬8å‘¨)
- [ ] `web-frontend/src/components/RecordingList.tsx` - å½•åƒåˆ—è¡¨
- [ ] `web-frontend/src/components/RecordingCard.tsx` - å½•åƒå¡ç‰‡
- [ ] `web-frontend/src/components/RecordingPlayer.tsx` - å½•åƒæ’­æ”¾å™¨

#### 4.5 çŠ¶æ€ç®¡ç† (ç¬¬8å‘¨)
- [ ] `web-frontend/src/hooks/useDevices.ts` - è®¾å¤‡çŠ¶æ€
- [ ] `web-frontend/src/hooks/useRecordings.ts` - å½•åƒçŠ¶æ€
- [ ] `web-frontend/src/hooks/usePlayback.ts` - æ’­æ”¾çŠ¶æ€

#### 4.6 æ€§èƒ½ç›‘æ§ç»„ä»¶ (ç¬¬8å‘¨)
- [ ] `web-frontend/src/components/PerformanceMonitor.tsx` - æ€§èƒ½ç›‘æ§
- [ ] `web-frontend/src/components/LatencyChart.tsx` - å»¶è¿Ÿå›¾è¡¨
- [ ] `web-frontend/src/components/BufferStatus.tsx` - ç¼“å†²çŠ¶æ€


---

## è¯¦ç»†å®ç°æ¸…å•

### å¹³å°ç«¯å®Œæ•´æ¸…å•

```
platform-server/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                          âœ… å¿…é¡»
â”‚   â”œâ”€â”€ config.rs                        âœ… å¿…é¡»
â”‚   â”œâ”€â”€ logging.rs                       âœ… å¿…é¡»
â”‚   â”‚
â”‚   â”œâ”€â”€ quic/                            âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ server.rs                    # QUICæœåŠ¡å™¨
â”‚   â”‚   â”œâ”€â”€ connection.rs                # è¿æ¥ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ stream.rs                    # æµç®¡ç†
â”‚   â”‚   â””â”€â”€ config.rs                    # QUICé…ç½®
â”‚   â”‚
â”‚   â”œâ”€â”€ http3/                           âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ server.rs                    # HTTP3æœåŠ¡å™¨
â”‚   â”‚   â”œâ”€â”€ handlers.rs                  # è¯·æ±‚å¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ routes.rs                    # è·¯ç”±å®šä¹‰
â”‚   â”‚   â””â”€â”€ middleware.rs                # ä¸­é—´ä»¶
â”‚   â”‚
â”‚   â”œâ”€â”€ protocol/                        âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ converter.rs                 # åè®®è½¬æ¢å™¨
â”‚   â”‚   â”œâ”€â”€ quic_to_http3.rs            # QUICâ†’HTTP3
â”‚   â”‚   â””â”€â”€ http3_to_quic.rs            # HTTP3â†’QUIC
â”‚   â”‚
â”‚   â”œâ”€â”€ device/                          âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ manager.rs                   # è®¾å¤‡ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ registry.rs                  # è®¾å¤‡æ³¨å†Œè¡¨
â”‚   â”‚   â””â”€â”€ heartbeat.rs                 # å¿ƒè·³æ£€æµ‹
â”‚   â”‚
â”‚   â”œâ”€â”€ recording/                       âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ manager.rs                   # å½•åƒç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ scanner.rs                   # æ–‡ä»¶æ‰«æå™¨
â”‚   â”‚   â”œâ”€â”€ metadata.rs                  # å…ƒæ•°æ®è§£æ
â”‚   â”‚   â””â”€â”€ cache.rs                     # å…ƒæ•°æ®ç¼“å­˜
â”‚   â”‚
â”‚   â”œâ”€â”€ distribution/                    âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ manager.rs                   # åˆ†å‘ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ subscriber.rs                # è®¢é˜…ç®¡ç†
â”‚   â”‚   â””â”€â”€ quality.rs                   # è´¨é‡é€‚é…
â”‚   â”‚
â”‚   â”œâ”€â”€ latency/                         âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ monitor.rs                   # å»¶è¿Ÿç›‘æ§å™¨
â”‚   â”‚   â”œâ”€â”€ statistics.rs                # ç»Ÿè®¡åˆ†æ
â”‚   â”‚   â””â”€â”€ alert.rs                     # å‘Šè­¦ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ playback/                        âš ï¸ å¯é€‰ï¼ˆå›æ”¾åŠŸèƒ½ï¼‰
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ handler.rs                   # å›æ”¾å¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ session.rs                   # å›æ”¾ä¼šè¯
â”‚   â”‚   â””â”€â”€ control.rs                   # æ’­æ”¾æ§åˆ¶
â”‚   â”‚
â”‚   â”œâ”€â”€ cache/                           âš ï¸ å¯é€‰ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ segment_cache.rs             # åˆ†ç‰‡ç¼“å­˜
â”‚   â”‚   â””â”€â”€ lru.rs                       # LRUç­–ç•¥
â”‚   â”‚
â”‚   â””â”€â”€ utils/                           âœ… å¿…é¡»
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ time.rs                      # æ—¶é—´å·¥å…·
â”‚       â””â”€â”€ metrics.rs                   # æŒ‡æ ‡æ”¶é›†
â”‚
â””â”€â”€ config.toml                          âœ… å¿…é¡»
```

### è®¾å¤‡ç«¯å®Œæ•´æ¸…å•

```
device-simulator/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                          âœ… å¿…é¡»
â”‚   â”œâ”€â”€ config.rs                        âœ… å¿…é¡»
â”‚   â”œâ”€â”€ logging.rs                       âœ… å¿…é¡»
â”‚   â”‚
â”‚   â”œâ”€â”€ quic/                            âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ client.rs                    # QUICå®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ connection.rs                # è¿æ¥ç®¡ç†
â”‚   â”‚   â””â”€â”€ reconnect.rs                 # é‡è¿æœºåˆ¶
â”‚   â”‚
â”‚   â”œâ”€â”€ video/                           âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ reader.rs                    # æ–‡ä»¶è¯»å–å™¨
â”‚   â”‚   â”œâ”€â”€ h264_parser.rs              # H.264è§£æ
â”‚   â”‚   â””â”€â”€ mp4_parser.rs               # MP4è§£æ
â”‚   â”‚
â”‚   â”œâ”€â”€ segmenter/                       âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ frame.rs                     # å¸§çº§åˆ†ç‰‡
â”‚   â”‚   â”œâ”€â”€ gop.rs                       # GOPåˆ†ç‰‡
â”‚   â”‚   â””â”€â”€ fixed.rs                     # å›ºå®šåˆ†ç‰‡
â”‚   â”‚
â”‚   â”œâ”€â”€ controller/                      âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ playback.rs                  # æ’­æ”¾æ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ seek.rs                      # å®šä½æ§åˆ¶
â”‚   â”‚   â””â”€â”€ rate.rs                      # é€Ÿç‡æ§åˆ¶
â”‚   â”‚
â”‚   â”œâ”€â”€ index/                           âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ keyframe.rs                  # å…³é”®å¸§ç´¢å¼•
â”‚   â”‚   â”œâ”€â”€ builder.rs                   # ç´¢å¼•æ„å»º
â”‚   â”‚   â””â”€â”€ search.rs                    # ç´¢å¼•æŸ¥æ‰¾
â”‚   â”‚
â”‚   â”œâ”€â”€ uploader/                        âœ… æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ scheduler.rs                 # ä¸Šä¼ è°ƒåº¦å™¨
â”‚   â”‚   â”œâ”€â”€ stats.rs                     # ç»Ÿè®¡ä¿¡æ¯
â”‚   â”‚   â””â”€â”€ adaptive.rs                  # è‡ªé€‚åº”ä¼ è¾“
â”‚   â”‚
â”‚   â””â”€â”€ utils/                           âœ… å¿…é¡»
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ network.rs                   # ç½‘ç»œå·¥å…·
â”‚
â”œâ”€â”€ config.toml                          âœ… å¿…é¡»
â””â”€â”€ test-videos/                         âœ… å¿…é¡»ï¼ˆæµ‹è¯•è§†é¢‘ï¼‰
```

### å‰ç«¯å®Œæ•´æ¸…å•

```
web-frontend/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ index.html
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.tsx                         âœ… å¿…é¡»
â”‚   â”œâ”€â”€ App.tsx                          âœ… å¿…é¡»
â”‚   â”‚
â”‚   â”œâ”€â”€ components/                      âœ… æ ¸å¿ƒç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ VideoPlayer.tsx              # è§†é¢‘æ’­æ”¾å™¨
â”‚   â”‚   â”œâ”€â”€ ControlPanel.tsx             # æ§åˆ¶é¢æ¿
â”‚   â”‚   â”œâ”€â”€ ProgressBar.tsx              # è¿›åº¦æ¡
â”‚   â”‚   â”œâ”€â”€ DeviceList.tsx               # è®¾å¤‡åˆ—è¡¨
â”‚   â”‚   â”œâ”€â”€ DeviceCard.tsx               # è®¾å¤‡å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ RecordingList.tsx            # å½•åƒåˆ—è¡¨
â”‚   â”‚   â”œâ”€â”€ RecordingCard.tsx            # å½•åƒå¡ç‰‡
â”‚   â”‚   â””â”€â”€ PerformanceMonitor.tsx       # æ€§èƒ½ç›‘æ§
â”‚   â”‚
â”‚   â”œâ”€â”€ services/                        âœ… æ ¸å¿ƒæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ http3Client.ts               # HTTP3å®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ api.ts                       # APIå°è£…
â”‚   â”‚   â””â”€â”€ websocket.ts                 # WebSocketç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/                           âœ… è‡ªå®šä¹‰Hooks
â”‚   â”‚   â”œâ”€â”€ useDevices.ts                # è®¾å¤‡çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ useRecordings.ts             # å½•åƒçŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ usePlayback.ts               # æ’­æ”¾çŠ¶æ€
â”‚   â”‚   â””â”€â”€ useWebSocket.ts              # WebSocketçŠ¶æ€
â”‚   â”‚
â”‚   â”œâ”€â”€ types/                           âœ… ç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ api.ts                       # APIç±»å‹
â”‚   â”‚   â”œâ”€â”€ device.ts                    # è®¾å¤‡ç±»å‹
â”‚   â”‚   â”œâ”€â”€ recording.ts                 # å½•åƒç±»å‹
â”‚   â”‚   â””â”€â”€ playback.ts                  # æ’­æ”¾ç±»å‹
â”‚   â”‚
â”‚   â””â”€â”€ utils/                           âœ… å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ format.ts                    # æ ¼å¼åŒ–å·¥å…·
â”‚       â””â”€â”€ time.ts                      # æ—¶é—´å·¥å…·
â”‚
â””â”€â”€ .env                                 âœ… å¿…é¡»ï¼ˆç¯å¢ƒé…ç½®ï¼‰
```

---

## æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

#### å¹³å°ç«¯æµ‹è¯•

```rust
// platform-server/tests/protocol_converter_test.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_quic_to_http3_conversion() {
        let converter = ProtocolConverter::new();
        let segment = create_test_segment();
        
        let result = converter
            .convert_quic_to_http3(segment, vec!["client1".to_string()])
            .await;
        
        assert!(result.is_ok());
    }
    
    #[tokio::test]
    async fn test_http3_to_quic_conversion() {
        let converter = ProtocolConverter::new();
        let control = create_test_control();
        
        let result = converter
            .convert_http3_to_quic(control, Uuid::new_v4())
            .await;
        
        assert!(result.is_ok());
    }
}
```

#### è®¾å¤‡ç«¯æµ‹è¯•

```rust
// device-simulator/tests/segmenter_test.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_frame_segmentation() {
        let segmenter = FrameSegmenter::new();
        let video_data = load_test_video();
        
        let segments = segmenter.segment(video_data).await.unwrap();
        
        assert!(!segments ç³»ç»Ÿæ¶æ„å›¢é˜Ÿ
 
**ç»´æŠ¤è€…**:5-12-12 *æœ€åæ›´æ–°**: 202 
*æ¡£ç‰ˆæœ¬**: v1.0 --

**æ–‡
-.md)
å¿«é€Ÿå¼€å§‹æŒ‡å— [å¿«é€Ÿå¼€å§‹æŒ‡å—](./)
- ğŸš€ å¿«é€Ÿå¼€å§‹:å†Œ.mdå¼€å‘æ‰‹ä¾‹: [å¼€å‘æ‰‹å†Œ](./ä»£ç ç¤ºd)
- ğŸ’» è®¾è®¡æ–‡æ¡£.mæ¶æ„æ„è®¾è®¡æ–‡æ¡£](../ç³»ç»Ÿ [ç³»ç»Ÿæ¶
- ğŸ“– å‚è€ƒæ–‡æ¡£:## è·å–å¸®åŠ©


#ç å®¡æŸ¥å’Œæµ‹è¯•è¿›è¡Œä»£ æ¯å‘¨*:*æŒç»­é›†æˆ*åŠ¡å™¨å¼€å‘
4. *å¹³å°ç«¯QUICæœäºŒå‘¨**: å¼€å§‹3. **ç¬¬ç¡€è®¾æ–½
ç°å…±äº«ç±»å‹å’ŒåŸº. **ç¬¬ä¸€å‘¨**: å®å’Œé…ç½®æ–‡ä»¶
2**: åˆ›å»ºé¡¹ç›®ç»“æ„
1. **ç«‹å³å¼€å§‹## ä¸‹ä¸€æ­¥è¡ŒåŠ¨

#VPç‰ˆæœ¬
æœŸ**: çº¦10å‘¨å®ŒæˆM**å¼€å‘å‘¨ æ€§èƒ½æµ‹è¯•
4. + é›†æˆæµ‹è¯• +å…ƒæµ‹è¯• è¯•ç­–ç•¥**: å•å‰ç«¯
3. **æµ‹ï¼Œå…ˆåç«¯åé¡ºåº**: å…ˆæ ¸å¿ƒåå¤–å›´. **å®ç°ç©ºé—´ç»„ç»‡ä»£ç 
2: ä½¿ç”¨Cargoå·¥ä½œ. **é¡¹ç›®ç»“æ„**ç‚¹

1
### æ ¸å¿ƒè¦

## æ€»ç»“---
è™‘ï¼ˆè¾“å…¥éªŒè¯ï¼‰

 å®‰å…¨è€ƒéš†ï¼‰
- [ ]è™‘ï¼ˆé¿å…ä¸å¿…è¦çš„å…‹ [ ] æ€§èƒ½è€ƒ] å•å…ƒæµ‹è¯•è¦†ç›–
-è®°å½•é€‚å½“
- [ å®Œæ•´
- [ ] æ—¥å¿—é”™è¯¯å¤„ç†æ–‡æ¡£æ³¨é‡Š
- [ ] æœ‰å…¬å…±APIéƒ½æœ‰ æ‰€
- [ ]æ¸…å•
ä»£ç å®¡æŸ¥

### 4. erver
```atform-sh --bin plaplamegrgo fç”Ÿæˆç«ç„°å›¾
carmegraph
# ä½¿ç”¨flaerf report
er
platform-serv/preleaseget/ ./tarrf record -g
peerfåˆ†æCPUæ€§èƒ½sh
# ä½¿ç”¨p``ba

`èƒ½åˆ†æ

### 3. æ€§`` -x run
`o watchrghè‡ªåŠ¨é‡æ–°ç¼–è¯‘
cargo watc
# ä½¿ç”¨ca080
port 8pcap udp ture.any -w capi o tcpdump -rkæŠ“åŒ…
sudsha
# ä½¿ç”¨Wiren=trace
G=debug,quinT_LO
export RUS å¯ç”¨è¯¦ç»†æ—¥å¿—`bash
#æŠ€å·§

``
### 2. è°ƒè¯•æ­¥æ·»åŠ åŠŸèƒ½
æ ¸å¿ƒçš„ä¼ è¾“é€šé“ï¼Œå†é€**åŸå› **: å…ˆå®ç°


6. å®Œå–„å…¶ä»–åŠŸèƒ½ ç®€å•çš„å‰ç«¯æ’­æ”¾å™¨
5.åè®®è½¬æ¢. åŸºæœ¬çš„Cå®¢æˆ·ç«¯
4è®¾å¤‡ç«¯QUIICæœåŠ¡å™¨
3. nï¼‰
2. å¹³å°ç«¯QUäº«ç±»å‹å®šä¹‰ï¼ˆcommo å…±é¡ºåº**:
1.åº

**æ¨è### 1. å¼€å‘é¡º


## å¼€å‘å»ºè®®-

```

--;
  }
}a)datndBuffer(ppeurceBuffer.ahis.so   t!;
 t()ue.shifhis.que = tt datacons   
    }
 turn;
          reting) {
updauffer.s.sourceB| thi |ferourceBuf !this.s= 0 || ==ue.lengthueis.q   if (theue() {
 rocessQute p 
  priva}
 e();
  rocessQueu   this.p
 );ta.push(dais.queueth
    ffer) {rrayBu(data: AndSegment  appe }
  

 );
    });eue(rocessQu   this.p{
   > nd', () =pdateeistener('uddEventLeBuffer.aourchis.s    
    t );
1E"'
   vc1.42E0odecs="a c 'video/mp4;fer(
     addSourceBufe.mediaSourcs. = thiceBuffer   this.sour  
 );
  );
    }once: true }, { lve, resoeopen'tener('sourcentLisdEvrce.addiaSouhis.me     te) => {
 resolvPromise((  await new 
    
  aSource);RL(this.medijectUeObeatsrc = URL.crement.eoEl.vidthis
    diaSource();w MeaSource = neediis.m   th{
 ialize() nit
  async i] = [];
  Buffer[ayqueue: Arr private ull;
 null = nuffer | rceBr: SousourceBuffe
  private ource;aSe: Medircte mediaSouivar {
  pramPlayeoStre Videexport classä½¿ç”¨æµç¨‹
ourceçš„MediaS// æ­£ç¡®pescript

```ty
**è§£å†³æ–¹æ¡ˆ**:PIçš„æ­£ç¡®ä½¿ç”¨
iaSource A*: Med**éš¾ç‚¹*urce API

. å‰ç«¯MediaSo
### 4
}
```
    }     }
})
             ),
  to_vec(ta.   data: da            false,
  keyframe:s_ i        {
       rame   Ok(VideoF           // æ™®é€šå¸§
         {
    =>   _      }
       
      })     c(),
 _veata: data.to      d     rue,
     rame: t is_keyf              
 ame {k(VideoFr   Oå¸§
                // å…³é”®    Idr => {
 rtitioningtPathouceLayerWie::Sliyp      UnitT
  ype() {nal_unit_t?.al.header()   match n
    
 e); &[], tru(data,Nal::newl = Reft nae> {
    leamult<VideoFr[u8]) -> Resme(data: &264_fra fn parse_h

publ, RefNal};nal::{Na:: h264_readeråº“
use4-reader ä½¿ç”¨h26t
//

```rusçš„å¿«é€Ÿè§£æå™¨ å®ç°è‡ªå®šä¹‰mp4ï¼‰
-ader, ï¼ˆh264-reä½¿ç”¨ç°æœ‰çš„è§£æåº“å†³æ–¹æ¡ˆ**:
- 
**è§£MP4æ ¼å¼çš„è§£æ
64å’Œ
**éš¾ç‚¹**: H.2è§£æ

### 3. è§†é¢‘æ–‡ä»¶
}
```
(());
    Okt?bufs).awaied(&rite_vector.wtream 
    s  ];
   ,
  .data)w(&segmentce::ne   IoSli
     ),headerew(&e::nlic IoS      fs = [
  let buè´å†™å…¥
   ice è¿›è¡Œé›¶æ‹· ä½¿ç”¨ IoSl   
    //gment);
 ader(sed_heself.builader =     let heå†…å­˜å¤åˆ¶
ç›´æ¥ä½¿ç”¨å¼•ç”¨ï¼Œé¿å…> {
    // lt<() Resunt,
) ->oSegmement: &Vide
    seg &self,  ero_copy(
  convert_zfnb async é›¶æ‹·è´è½¬æ¢
pu
// 
```rust- å¼‚æ­¥å¹¶å‘è½¬æ¢
- æ‰¹é‡å¤„ç†åˆ†ç‰‡
æŠ€æœ¯
æ‹·è´
- ä½¿ç”¨é›¶*:*è§£å†³æ–¹æ¡ˆ*è½¬æ¢çš„æ€§èƒ½å¼€é”€

*: QUICâ†”HTTP3ç‚¹**
**éš¾æ€§èƒ½
. åè®®è½¬æ¢
### 2 }
}
```

   onn)      Ok(c    
  );
    nn.clone()cog(), id.to_strindevice_ert(ons.insf.connecti      sel;
  .await?device_id)_connection(tereaonn = self.c       let cå»ºæ–°è¿æ¥
         // åˆ›    

           }   }
         ;
 ())one(conn.clOkn  retur                {
s_active() if conn.i       {
     device_id)ns.get(.connectioonn) = selft Some(c if le
       {Connection> ult< -> Resr,
    )ice_id: &st dev   
    &self,        create(
 get_or_ub async fn    p{
ool nnectionP
impl Coy,
}
nnectStrateg Recoct_strategy:    reconnen>>,
Connectioap<String, rc<DashMnnections: A   coool {
 nnectionPruct Copub sté‡è¿

// å®ç°è¿æ¥æ± å’Œè‡ªåŠ¨*:
```rust*è§£å†³æ–¹æ¡ˆ*å¤

*å»ºç«‹ã€ç»´æŠ¤å’Œæ¢æ¥çš„éš¾ç‚¹**: QUICè¿Cè¿æ¥ç®¡ç†

**QUI
### 1. 
# å…³é”®æŠ€æœ¯éš¾ç‚¹-

#è¾¾æ ‡

--æµ‹è¯•é€šè¿‡
- æ€§èƒ½æµ‹è¯•
- é›†æˆè¯•è¦†ç›–ç‡ > 80%00ms
- å•å…ƒæµ‹å»¶è¿Ÿ < 2:
- ç«¯åˆ°ç«¯æ”¶æ ‡å‡†**

**éªŒæ–‡æ¡£
- âœ… éƒ¨ç½²è„šæœ¬
- âœ… å®Œå–„çš„ å®Œæ•´çš„æµ‹è¯•å¥—ä»¶èƒ½ä¼˜åŒ–
- âœ… âœ… æ€§äº¤ä»˜ç‰©**:
-é¢æµ‹è¯•

**å’Œå…¨ä¼˜åŒ–æ€§èƒ½**: )

**ç›®æ ‡å’Œæµ‹è¯• (ç¬¬9-10å‘¨ç¢‘3: ä¼˜åŒ–

### é‡Œç¨‹æ˜¾ç¤ºå®æ—¶æ€§èƒ½ç»Ÿè®¡ï¼‰
- å€é€Ÿï¼ˆæš‚åœã€æ‹–åŠ¨ã€æ’­æ”¾æ§åˆ¶ æ”¯æŒ
-æŸ¥è¯¢å½•åƒåˆ—è¡¨å¤‡åˆ—è¡¨
- å¯ä»¥ä»¥æŸ¥è¯¢è®¾- å¯*:
éªŒæ”¶æ ‡å‡†*
**èƒ½
æ§åŠŸåˆ¶åŠŸèƒ½
- âœ… æ€§èƒ½ç›‘æ’­æ”¾æ§åƒç®¡ç†åŠŸèƒ½
- âœ… ç†åŠŸèƒ½
- âœ… å½•è®¾å¤‡ç®¡ä»˜ç‰©**:
- âœ… *äº¤

*èƒ½ç›®æ ‡**: å®Œå–„æ ¸å¿ƒåŠŸç¬¬7-8å‘¨)

**å–„ (åŠŸèƒ½å®Œç¢‘2: é‡Œç¨‹
### å»¶è¿Ÿ < 500ms
åˆ°ç«¯
- ç«¯å¯ä»¥æ’­æ”¾è§†é¢‘
- å‰ç«¯
- å¯ä»¥ä¼ è¾“è§†é¢‘åˆ†ç‰‡ç«¯å¹³å°è¿æ¥åˆ°*:
- è®¾å¤‡ç«¯å¯ä»¥ï¼‰

**éªŒæ”¶æ ‡å‡†*ç«¯ï¼ˆæ’­æ”¾å™¨âœ… ç®€å•çš„Webå‰æ¢
- 
- âœ… åŸºæœ¬çš„åè®®è½¬ è®¾å¤‡ç«¯QUICå®¢æˆ·ç«¯ICæœåŠ¡å™¨
- âœ… å¹³å°ç«¯QUä»˜ç‰©**:
- âœ…è¾“åŠŸèƒ½

**äº¤æµä¼ **: å®ç°åŸºæœ¬çš„è§†é¢‘**ç›®æ ‡ (ç¬¬1-6å‘¨)

: MVPç‰ˆæœ¬ é‡Œç¨‹ç¢‘1
### å¼€å‘é‡Œç¨‹ç¢‘

---

##;
}
```
s(200))millifrom_tion::ency < Durat!(avg_lat  asser   < 200ms
å¹³å‡å»¶è¿Ÿ 
    // éªŒè¯
   2;s u3cies.len() a / latenuration>()).sum::<Dr(.ite = latencies_latencyvg    let a   }
    

 tency);.push(lacies  latend();
      apsestart.ellatency =         let 
      rap();
  ).await.unwsegment.idsegment(m.wait_for_    platfor
    / ç­‰å¾…æ¥æ”¶  /     
       ap();
  await.unwrone()).t.clegmen(snd_segmentce.se  deviåˆ†ç‰‡
      // å‘é€  
           w();
   nt::notaart = Ins let st0 {
       .100_ in 0.  for   
    
:new(); Vec:tencies =t la
    let mu) {tency(la_end__end_toync fn test
as]io::test#[tok
.rs_testncys/tests/latee-testrformanc
// pe

```rust æ€§èƒ½æµ‹è¯•
```

###).await;
}ce.shutdown(
    devi.await;down()atform.shutç†
    pl6. æ¸…   //   
 n(), 1);
  received.le assert_eq!(.await;
   ents()_segmt_received.getformplaeived = et rec
    l éªŒè¯å¹³å°ç«¯æ¥æ”¶
    // 5.ap();
    it.unwrawament().st_segd_teenevice.sç‰‡
    dè§†é¢‘åˆ†// 4. å‘é€
    ;
    (2)).awaitrom_secson::feep(Durati:slokio::time:è¿æ¥å»ºç«‹
    t  // 3. ç­‰å¾…
  wait;
    tor().ae_simulastart_devicvice = 
    let de// 2. å¯åŠ¨è®¾å¤‡ç«¯
    ait;
    ).awrm_server(tfo_pla= start platform let    å°ç«¯
// 1. å¯åŠ¨å¹³() {
    streamingnd_nd_to_eest_esync fn to::test]
a
#[tokisnd_test.r/end_to_e-tests/tests integration//ust
``rè¯•

`

### é›†æˆæµ‹``` });
});
ed();
 efin.toBeDces)e.data.deviesponst(rexpec
    cess');s).toBe('suconse.statuesp   expect(r
    
 s');cev1/deviapi/lient.get('/se = await cpononst res
    ct:8443');//localhoshttps:TP3Client(' new HTst client =    con {
async () =>', essfullyices succdevtch 'should fe
  it(, () => {HTTP3Client'describe('
ient';
./http3Cl from '.nt }TTP3Clie{ Hts
import est.Client.ts__/http3testervices/__end/src/s// web-frontpt
``typescri## å‰ç«¯æµ‹è¯•

`
##```

    }
}
rame);[0].is_keyfgmentst!(se  asser());
      ty.is_emp