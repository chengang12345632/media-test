# ç›´é€šæ’­æ”¾å®ç°æ–¹æ¡ˆ

## å®Œæ•´æµç¨‹

### 1. ç”¨æˆ·æ“ä½œ
```
ç”¨æˆ·ç‚¹å‡»"ğŸ”´ ç›´é€šæ’­æ”¾"æŒ‰é’®
```

### 2. å‰ç«¯ â†’ å¹³å°
```typescript
// web-frontend/src/App.tsx
const handleLiveStream = async (deviceId: string) => {
  const response = await fetch('/api/v1/stream/start', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      device_id: deviceId,
      mode: 'live',
      quality_preference: 'low_latency',
      target_latency_ms: 100
    })
  })
  
  const data = await response.json()
  navigate(`/live/${data.session_id}`)
}
```

### 3. å¹³å° â†’ è®¾å¤‡
```rust
// platform-server/src/http3/handlers.rs
pub async fn unified_stream_start() {
  let session_id = Uuid::new_v4();
  
  let message = ProtocolMessage {
    message_type: MessageType::StartLiveStream,
    payload: bincode::serialize(&StartLiveStreamRequest {
      quality_preference: "low_latency",
      target_latency_ms: 100,
      target_fps: 30,
      target_bitrate: 2_000_000,
    }),
    session_id,
    ...
  };
  
  connection.open_bi().await?;
  send.write_all(&bincode::serialize(&message)?).await?;
  
  Json(StartStreamResponse { session_id })
}
```

### 4. è®¾å¤‡æ¥æ”¶æŒ‡ä»¤
```rust
// device-simulator/src/device_service.rs
async fn handle_control_messages() {
  loop {
    let (send, recv) = connection.accept_bi().await?;
    let msg = bincode::deserialize::<ProtocolMessage>(&buf)?;
    
    match msg.message_type {
      MessageType::StartLiveStream => {
        info!("ğŸ“¡ Received start live stream request");
        
        tokio::spawn(async move {
          handle_live_stream_request(
            connection,
            request,
            msg.session_id
          ).await
        });
      }
    }
  }
}
```

### 5. è®¾å¤‡å¼€å§‹å‘é€æ•°æ®æµ
```rust
async fn handle_live_stream_request(
  connection: quinn::Connection,
  request: StartLiveStreamRequest,
  session_id: Uuid,
) {
  let mut generator = LiveStreamGeneratorFile::new(
    session_id,
    request.target_fps,
    request.target_bitrate,
    "test-videos/oceans.mp4"
  )?;
  
  let mut receiver = generator.start_streaming().await?;
  
  while let Some(segment) = receiver.recv().await {
    let mut stream = connection.open_uni().await?;
    stream.write_all(&bincode::serialize(&segment)?).await?;
    stream.finish().await?;
  }
}
```

### 6. å¹³å°æ¥æ”¶å¹¶è½¬å‘
```rust
// platform-server/src/quic/connection.rs
async fn handle_uni_streams() {
  while let Ok(mut recv) = connection.accept_uni().await {
    let buf = recv.read_to_end(10 * 1024 * 1024).await?;
    let segment = bincode::deserialize::<VideoSegment>(&buf)?;
    
    distribution_manager
      .distribute_segment(segment.session_id, segment)
      .await;
  }
}
```

### 7. å‰ç«¯æ¥æ”¶å¹¶æ’­æ”¾
```typescript
// web-frontend/src/components/WebCodecsPlayer.tsx
const startSSEStream = () => {
  const eventSource = new EventSource(`/api/v1/stream/${sessionId}/segments`)
  
  eventSource.onmessage = (event) => {
    const segment = JSON.parse(event.data)
    const h264Data = Uint8Array.from(atob(segment.data), c => c.charCodeAt(0))
    decodeH264Data(h264Data, segment.timestamp)
  }
}

const decodeH264Data = (data: Uint8Array, timestamp: number) => {
  const chunk = new EncodedVideoChunk({
    type: 'key',
    timestamp,
    data: data.buffer
  })
  
  decoder.decode(chunk)
}

const decoder = new VideoDecoder({
  output: (frame: VideoFrame) => {
    ctx.drawImage(frame, 0, 0)
    frame.close()
  }
})
```

---

## åœæ­¢æµç¨‹

### 1. ç”¨æˆ·ç‚¹å‡»"è¿”å›"æŒ‰é’®
```typescript
const handleBack = async () => {
  if (currentSessionId) {
    await fetch(`/api/v1/stream/${currentSessionId}/control`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'stop' })
    })
  }
  navigate('/')
}
```

### 2. å¹³å° â†’ è®¾å¤‡
```rust
pub async fn unified_stream_control() {
  let message = ProtocolMessage {
    message_type: MessageType::StopLiveStream,
    session_id,
    ...
  };
  
  connection.open_bi().await?;
  send.write_all(&bincode::serialize(&message)?).await?;
}
```

### 3. è®¾å¤‡åœæ­¢å‘é€
```rust
async fn stream_file(..., mut stop_rx: watch::Receiver<bool>) {
  loop {
    if *stop_rx.borrow() {
      info!("â¹ï¸ Stop signal received, ending stream");
      break;
    }
    
    // å‘é€åˆ†ç‰‡...
  }
}
```

---

## æ•°æ®æµå‘å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å‰ç«¯   â”‚                    â”‚  å¹³å°   â”‚                    â”‚  è®¾å¤‡   â”‚
â”‚ (3000)  â”‚                    â”‚ (8080)  â”‚                    â”‚ (8443)  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                              â”‚                              â”‚
     â”‚ 1. POST /api/v1/stream/start â”‚                              â”‚
     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                              â”‚
     â”‚                              â”‚                              â”‚
     â”‚                              â”‚ 2. QUIC: StartLiveStream     â”‚
     â”‚                              â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                              â”‚                              â”‚
     â”‚                              â”‚                              â”‚ 3. å¼€å§‹å‘é€
     â”‚                              â”‚                              â”‚    H.264 æ•°æ®
     â”‚                              â”‚                              â”‚
     â”‚                              â”‚ 4. QUIC: VideoSegment        â”‚
     â”‚                              â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚                              â”‚                              â”‚
     â”‚ 5. SSE: /segments            â”‚                              â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                              â”‚
     â”‚                              â”‚                              â”‚
     â”‚ 6. WebCodecs è§£ç             â”‚                              â”‚
     â”‚    Canvas æ¸²æŸ“               â”‚                              â”‚
```

---

## æŠ€æœ¯äº®ç‚¹

### 1. ä½å»¶è¿Ÿç¼–ç é…ç½®
```rust
encoder.set_gop(fps);              // GOP = 1ç§’
encoder.set_max_b_frames(0);       // ç¦ç”¨Bå¸§
dict.set("preset", "ultrafast");   // æœ€å¿«ç¼–ç 
dict.set("tune", "zerolatency");   // é›¶å»¶è¿Ÿè°ƒä¼˜
dict.set("profile", "baseline");   // æœ€ä½³å…¼å®¹æ€§
```

### 2. é›¶ç¼“å†²è½¬å‘æœºåˆ¶
```rust
let forward_start = SystemTime::now();
let send_result = segment_sender.send(segment.clone());
let forward_latency_ms = forward_start.elapsed().as_micros() as f64 / 1000.0;

// ç›®æ ‡: forward_latency_ms < 5ms
if forward_latency_ms > 5.0 {
    warn!("High processing latency: {:.2}ms", forward_latency_ms);
}
```

### 3. æ™ºèƒ½å»¶è¿Ÿç›‘æ§
```rust
stats.update_latency(processing_latency_ms);

if processing_latency_ms > latency_threshold as f64 {
    let alert = LatencyAlert {
        session_id,
        current_latency_ms: processing_latency_ms,
        threshold_ms: latency_threshold,
        timestamp: SystemTime::now(),
        message: format!("Latency exceeded threshold: {:.2}ms > {}ms",
                        processing_latency_ms, latency_threshold),
    };
    alert_sender.send(alert);
}
```

---

## æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ |
|------|--------|
| ç«¯åˆ°ç«¯å»¶è¿Ÿï¼ˆå¹³å‡ï¼‰ | < 100ms |
| ç«¯åˆ°ç«¯å»¶è¿Ÿï¼ˆP95ï¼‰ | < 100ms |
| å¹³å°å¤„ç†å»¶è¿Ÿ | < 5ms |
| å¸§ç‡ | 30 fps |
| ç ç‡ | 2 Mbps |
| CPUå ç”¨ï¼ˆè®¾å¤‡ç«¯ï¼‰ | < 20% |
| CPUå ç”¨ï¼ˆå¹³å°ç«¯ï¼‰ | < 5% |

---

**æ›´æ–°æ—¶é—´**: 2025-12-13
