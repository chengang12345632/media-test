# HTTP3/QUIC视频流传输系统 - 开发手册

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | v1.0 |
| 创建日期 | 2025-12-12 |
| 适用版本 | Demo v1.0 |
| 目标读者 | 开发人员 |

## 目录

1. [开发环境搭建](#开发环境搭建)
2. [项目结构](#项目结构)
3. [核心模块开发](#核心模块开发)
4. [API开发指南](#api开发指南)
5. [前端开发指南](#前端开发指南)
6. [测试指南](#测试指南)
7. [调试技巧](#调试技巧)
8. [代码规范](#代码规范)
9. [性能优化](#性能优化)
10. [常见问题](#常见问题)

---

## 开发环境搭建

### 1. 必备工具

```bash
# Rust工具链
rustup component add rustfmt clippy rust-analyzer

# Node.js工具
npm install -g typescript ts-node eslint prettier

# 开发工具
# - VS Code + Rust Analyzer插件
# - VS Code + ESLint插件
# - VS Code + Prettier插件
# - Postman或Insomnia（API测试）
# - Wireshark（网络分析）
```

### 2. IDE配置

**VS Code配置（.vscode/settings.json）**：
```json
{
  "rust-analyzer.checkOnSave.command": "clippy",
  "rust-analyzer.cargo.features": "all",
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[rust]": {
    "editor.defaultFormatter": "rust-lang.rust-analyzer"
  },
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "files.associations": {
    "*.toml": "toml"
  }
}
```

### 3. Git配置

```bash
# 配置Git钩子
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
# 运行代码格式化
cargo fmt --all
cd web-frontend && npm run format
EOF

chmod +x .git/hooks/pre-commit
```


---

## 项目结构

### 整体架构

```
video-streaming-demo/
├── platform-server/          # 平台端服务器（Rust）
│   ├── src/
│   │   ├── main.rs          # 入口文件
│   │   ├── server.rs        # 服务器核心
│   │   ├── protocol/        # 协议转换
│   │   ├── distribution/    # 分发管理
│   │   ├── recording/       # 录像管理
│   │   ├── latency/         # 延迟监控
│   │   └── types.rs         # 类型定义
│   ├── Cargo.toml
│   └── config.toml
├── device-simulator/         # 设备模拟器（Rust）
│   ├── src/
│   │   ├── main.rs
│   │   ├── uploader.rs      # 上传器
│   │   ├── controller.rs    # 播放控制
│   │   ├── segmenter.rs     # 分片器
│   │   └── types.rs
│   ├── Cargo.toml
│   └── config.toml
├── web-frontend/            # Web前端（React + TypeScript）
│   ├── src/
│   │   ├── App.tsx
│   │   ├── components/      # React组件
│   │   ├── services/        # API服务
│   │   ├── hooks/           # 自定义Hooks
│   │   └── types/           # TypeScript类型
│   ├── package.json
│   └── tsconfig.json
└── docs/                    # 文档
```

### 平台端模块结构

```rust
// platform-server/src/main.rs
mod server;
mod protocol;
mod distribution;
mod recording;
mod latency;
mod types;

use server::PlatformServer;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化日志
    env_logger::init();
    
    // 加载配置
    let config = load_config("config.toml")?;
    
    // 创建服务器
    let server = PlatformServer::new(config).await?;
    
    // 启动服务器
    server.run().await?;
    
    Ok(())
}
```

### 前端组件结构

```typescript
// web-frontend/src/App.tsx
import React from 'react';
import { DeviceList } from './components/DeviceList';
import { VideoPlayer } from './components/VideoPlayer';
import { RecordingList } from './components/RecordingList';

function App() {
  return (
    <div className="App">
      <DeviceList />
      <VideoPlayer />
      <RecordingList />
    </div>
  );
}
```

---

## 核心模块开发

### 1. 协议转换器开发

```rust
// platform-server/src/protocol/converter.rs

use std::collections::HashMap;
use uuid::Uuid;

pub struct ProtocolConverter {
    quic_sessions: HashMap<Uuid, QUICSession>,
    http3_clients: HashMap<String, HTTP3Client>,
}

impl ProtocolConverter {
    pub fn new() -> Self {
        Self {
            quic_sessions: HashMap::new(),
            http3_clients: HashMap::new(),
        }
    }
    
    /// QUIC分片 → HTTP3分片转换
    pub async fn convert_quic_to_http3(
        &mut self,
        quic_segment: QUICVideoSegment,
    ) -> Result<HTTP3VideoSegment, ConversionError> {
        // 1. 解析QUIC分片
        let segment_data = self.parse_quic_segment(&quic_segment)?;
        
        // 2. 构建HTTP3分片
        let http3_segment = HTTP3VideoSegment {
            session_id: segment_data.session_id,
            timestamp: segment_data.timestamp,
            data: segment_data.data,
            headers: self.build_http3_headers(&segment_data),
        };
        
        Ok(http3_segment)
    }
    
    /// HTTP3控制命令 → QUIC控制命令转换
    pub async fn convert_http3_to_quic(
        &mut self,
        http3_control: HTTP3PlaybackControl,
    ) -> Result<QUICControlMessage, ConversionError> {
        // 实现控制命令转换
        todo!()
    }
}
```

### 2. 分发管理器开发

```rust
// platform-server/src/distribution/manager.rs

pub struct DistributionManager {
    active_streams: HashMap<Uuid, StreamInfo>,
    client_subscriptions: HashMap<String, Vec<Uuid>>,
}

impl DistributionManager {
    /// 多路分发核心逻辑
    pub async fn distribute_segment(
        &mut self,
        segment: VideoSegment,
        source_session: Uuid,
    ) -> Result<DistributionResult, DistributionError> {
        // 1. 获取订阅客户端
        let subscribers = self.get_stream_subscribers(source_session)?;
        
        // 2. 并发分发
        let mut tasks = Vec::new();
        for client_id in subscribers {
            let segment_clone = segment.clone();
            tasks.push(tokio::spawn(async move {
                self.send_to_client(&client_id, segment_clone).await
            }));
        }
        
        // 3. 等待所有分发完成
        let results = futures::future::join_all(tasks).await;
        
        Ok(DistributionResult::Success {
            distributed_count: results.len(),
        })
    }
}
```

### 3. 录像管理器开发

```rust
// platform-server/src/recording/manager.rs

pub struct RecordingManager {
    recordings_cache: HashMap<String, RecordingInfo>,
    storage_root: PathBuf,
}

impl RecordingManager {
    /// 扫描文件系统获取录像列表
    pub async fn scan_device_recordings(
        &self,
        device_id: &str,
    ) -> Result<Vec<RecordingInfo>, RecordingError> {
        let device_path = self.storage_root.join(device_id);
        let mut recordings = Vec::new();
        
        // 递归扫描目录
        for entry in walkdir::WalkDir::new(device_path) {
            let entry = entry?;
            if entry.file_type().is_file() {
                if let Some(recording) = self.parse_recording_file(entry.path()).await? {
                    recordings.push(recording);
                }
            }
        }
        
        // 按时间排序
        recordings.sort_by(|a, b| b.created_time.cmp(&a.created_time));
        
        Ok(recordings)
    }
    
    /// 解析录像文件元数据
    async fn parse_recording_file(
        &self,
        file_path: &Path,
    ) -> Result<Option<RecordingInfo>, RecordingError> {
        // 使用ffprobe或自定义解析器提取元数据
        todo!()
    }
}
```

---

## API开发指南

### 1. 添加新的API端点

**步骤1: 定义路由**

```rust
// platform-server/src/server.rs

use axum::{Router, routing::{get, post}};

pub fn create_router() -> Router {
    Router::new()
        // 设备管理
        .route("/api/v1/devices", get(get_devices))
        .route("/api/v1/devices/:device_id", get(get_device_detail))
        
        // 录像管理
        .route("/api/v1/devices/:device_id/recordings", get(get_recordings))
        
        // 直通播放
        .route("/api/v1/devices/:device_id/live-stream", post(start_live_stream))
        
        // 录像回放
        .route("/api/v1/recordings/:file_id/playback", post(start_playback))
        .route("/api/v1/playback/:session_id/control", post(playback_control))
}
```

**步骤2: 实现处理函数**

```rust
// platform-server/src/handlers/devices.rs

use axum::{Json, extract::Path};
use serde::{Deserialize, Serialize};

#[derive(Serialize)]
pub struct DeviceListResponse {
    devices: Vec<DeviceInfo>,
    pagination: Pagination,
}

/// 获取设备列表
pub async fn get_devices(
    Query(params): Query<DeviceListQuery>,
) -> Result<Json<ApiResponse<DeviceListResponse>>, ApiError> {
    // 1. 从设备注册表获取设备列表
    let devices = DEVICE_REGISTRY.get_all_devices().await?;
    
    // 2. 应用过滤和分页
    let filtered_devices = apply_filters(devices, &params);
    let paginated_devices = apply_pagination(filtered_devices, &params);
    
    // 3. 构建响应
    Ok(Json(ApiResponse::success(DeviceListResponse {
        devices: paginated_devices,
        pagination: calculate_pagination(&params),
    })))
}

/// 获取设备详情
pub async fn get_device_detail(
    Path(device_id): Path<String>,
) -> Result<Json<ApiResponse<DeviceInfo>>, ApiError> {
    // 1. 查询设备信息
    let device = DEVICE_REGISTRY
        .get_device(&device_id)
        .await?
        .ok_or(ApiError::DeviceNotFound)?;
    
    // 2. 返回响应
    Ok(Json(ApiResponse::success(device)))
}
```

**步骤3: 定义数据模型**

```rust
// platform-server/src/types/api.rs

#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub status: String,
    pub data: T,
    pub timestamp: String,
}

impl<T> ApiResponse<T> {
    pub fn success(data: T) -> Self {
        Self {
            status: "success".to_string(),
            data,
            timestamp: chrono::Utc::now().to_rfc3339(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApiError {
    pub code: String,
    pub message: String,
    pub details: Option<String>,
}
```

### 2. 错误处理

```rust
// platform-server/src/error.rs

use axum::{
    response::{IntoResponse, Response},
    http::StatusCode,
    Json,
};

#[derive(Debug)]
pub enum ApiError {
    DeviceNotFound,
    RecordingNotFound,
    SessionExpired,
    InvalidParameter(String),
    InternalError(String),
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, code, message) = match self {
            ApiError::DeviceNotFound => (
                StatusCode::NOT_FOUND,
                "DEVICE_NOT_FOUND",
                "设备不存在",
            ),
            ApiError::RecordingNotFound => (
                StatusCode::NOT_FOUND,
                "RECORDING_NOT_FOUND",
                "录像文件不存在",
            ),
            ApiError::SessionExpired => (
                StatusCode::NOT_FOUND,
                "SESSION_EXPIRED",
                "会话已过期",
            ),
            ApiError::InvalidParameter(msg) => (
                StatusCode::BAD_REQUEST,
                "INVALID_PARAMETER",
                &msg,
            ),
            ApiError::InternalError(msg) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "INTERNAL_ERROR",
                &msg,
            ),
        };
        
        let body = Json(serde_json::json!({
            "status": "error",
            "error": {
                "code": code,
                "message": message,
            },
            "timestamp": chrono::Utc::now().to_rfc3339(),
        }));
        
        (status, body).into_response()
    }
}
```

