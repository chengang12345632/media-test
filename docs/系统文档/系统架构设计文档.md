# HTTP3/QUICè§†é¢‘æµä¼ è¾“ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£ v1.0

## æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£ç‰ˆæœ¬ | v1.0 |
| åˆ›å»ºæ—¥æœŸ | 2025-12-11 |
| æœ€åæ›´æ–° | 2025-12-11 |
| æ–‡æ¡£çŠ¶æ€ | æ­£å¼ç‰ˆ |
| ä½œè€… | ç³»ç»Ÿæ¶æ„å›¢é˜Ÿ |

## ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹å†…å®¹ | ä½œè€… |
|------|------|----------|------|
| v1.0 | 2025-12-11 | åˆå§‹ç‰ˆæœ¬ï¼Œå®Œæ•´æ¶æ„è®¾è®¡ | ç³»ç»Ÿæ¶æ„å›¢é˜Ÿ |
| v1.1 | 2025-12-13 | æ·»åŠ ç»Ÿä¸€ä½å»¶è¿Ÿè§†é¢‘æµä¼ è¾“æ–¹æ¡ˆ | ç³»ç»Ÿæ¶æ„å›¢é˜Ÿ |
|      |            | - æ›´æ–°ç¬¬3.2.2èŠ‚ï¼šå¹³å°ç«¯â†’Webå‰ç«¯åª’ä½“ä¼ è¾“ | |
|      |            | - æ›´æ–°ç¬¬5èŠ‚ï¼šç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾è¯¦ç»†è®¾è®¡ | |
|      |            | - æ·»åŠ UnifiedStreamHandlerç»Ÿä¸€æµå¤„ç†å™¨ | |
|      |            | - æ·»åŠ StreamSourceæ•°æ®æºæŠ½è±¡ | |
|      |            | - æ·»åŠ FileStreamReaderæ–‡ä»¶æµå¼è¯»å–å™¨ | |
|      |            | - æ·»åŠ é›¶ç¼“å†²è½¬å‘æœºåˆ¶ | |
|      |            | - æ·»åŠ ç»Ÿä¸€MSEæ’­æ”¾å™¨è®¾è®¡ | |
|      |            | - å½•åƒå›æ”¾å»¶è¿Ÿä»2000msé™åˆ°107msï¼ˆ18å€æå‡ï¼‰ | |

## æ–‡æ¡£ç›®å½•

1. [ç³»ç»Ÿæ¦‚è¿°](#1-ç³»ç»Ÿæ¦‚è¿°)
   - 1.1 é¡¹ç›®èƒŒæ™¯
   - 1.2 æ ¸å¿ƒç›®æ ‡
   - 1.3 æŠ€æœ¯æ¶æ„ç‰¹ç‚¹
2. [ç³»ç»Ÿæ¶æ„æ€»è§ˆ](#2-ç³»ç»Ÿæ¶æ„æ€»è§ˆ)
   - 2.1 æ•´ä½“æ¶æ„å›¾
   - 2.2 æ ¸å¿ƒç»„ä»¶è¯´æ˜
3. [åè®®è®¾è®¡](#3-åè®®è®¾è®¡)
   - 3.1 ä¼ è¾“åè®®åˆ†å±‚
   - 3.2 åª’ä½“ä¼ è¾“åè®®è®¾è®¡
   - 3.3 ä¿¡ä»¤ä¼ è¾“åè®®è®¾è®¡
     - 3.3.1 è®¾å¤‡ç«¯ â†” å¹³å°ç«¯ä¿¡ä»¤ (QUIC)
     - 3.3.2 å¹³å°ç«¯ â†” Webå‰ç«¯ä¿¡ä»¤ (HTTP3)
       - 3.3.2.1 è®¾å¤‡ç®¡ç†API
       - 3.3.2.2 å½•åƒæ–‡ä»¶ç®¡ç†API
       - 3.3.2.3 ç›´é€šæ’­æ”¾API
       - 3.3.2.4 å›æ”¾æ§åˆ¶API
       - 3.3.2.5 WebSocketå®æ—¶äº‹ä»¶æ¨é€
4. [å¹³å°ç«¯æ ¸å¿ƒè®¾è®¡](#4-å¹³å°ç«¯æ ¸å¿ƒè®¾è®¡é‡ç‚¹)
   - 4.1 å¹³å°ç«¯æ¶æ„
   - 4.2 æ ¸å¿ƒç»„ä»¶è¯¦ç»†è®¾è®¡
   - 4.3 ç¼“å­˜ç®¡ç†ç­–ç•¥
5. [ç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾è¯¦ç»†è®¾è®¡](#5-ç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾è¯¦ç»†è®¾è®¡)
   - 5.1 ç›´é€šæ’­æ”¾æµç¨‹
   - 5.2 å½•åƒå›æ”¾æµç¨‹
   - 5.3 ç›´é€šæ’­æ”¾å¤„ç†å™¨å®ç°
   - 5.4 å½•åƒå›æ”¾å¤„ç†å™¨å®ç°
   - 5.5 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
6. [å‰ç«¯è®¾è®¡](#6-å‰ç«¯è®¾è®¡ç®€è¦)
   - 6.1 å‰ç«¯æ¶æ„
   - 6.2 æ ¸å¿ƒç»„ä»¶
7. [è®¾å¤‡ç«¯è®¾è®¡](#7-è®¾å¤‡ç«¯è®¾è®¡ç®€è¦)
   - 7.1 è®¾å¤‡æ¨¡æ‹Ÿå™¨æ¶æ„
   - 7.2 å…³é”®å¢å¼ºåŠŸèƒ½
8. [å»¶è¿Ÿç›‘æ§è®¾è®¡](#8-å»¶è¿Ÿç›‘æ§è®¾è®¡)
   - 8.1 å»¶è¿Ÿç›‘æ§æ¶æ„
   - 8.2 å»¶è¿Ÿç›‘æ§å®ç°
9. [æµ‹è¯•æ–¹æ¡ˆè®¾è®¡](#9-æµ‹è¯•æ–¹æ¡ˆè®¾è®¡)
   - 9.1 ç½‘ç»œæŠ–åŠ¨æ¨¡æ‹Ÿå·¥å…·
   - 9.2 å»¶è¿Ÿæµ‹è¯•å·¥å…·
10. [éƒ¨ç½²å’Œè¿ç»´](#10-éƒ¨ç½²å’Œè¿ç»´)
    - 10.1 ç³»ç»Ÿéƒ¨ç½²æ¶æ„
    - 10.2 ç›‘æ§æŒ‡æ ‡å®šä¹‰
11. [æ€»ç»“å’Œåç»­è®¡åˆ’](#11-æ€»ç»“å’Œåç»­è®¡åˆ’)
    - 11.1 æ¶æ„ä¼˜åŠ¿
    - 11.2 å…³é”®æŠ€æœ¯åˆ›æ–°
    - 11.3 å®æ–½è®¡åˆ’
    - 11.4 APIæ¥å£è§„èŒƒæ€»ç»“
    - 11.5 éœ€è¦ç¡®è®¤çš„æŠ€æœ¯ç»†èŠ‚
    - 11.6 æ€§èƒ½æŒ‡æ ‡ç›®æ ‡

---

## æ‰§è¡Œæ‘˜è¦

æœ¬æ–‡æ¡£æè¿°äº†åŸºäºHTTP3/QUICåè®®çš„ç«¯åˆ°ç«¯è§†é¢‘æµä¼ è¾“ç³»ç»Ÿçš„å®Œæ•´æ¶æ„è®¾è®¡ã€‚**æœ¬ç‰ˆæœ¬ä¸ºDemoæ¼”ç¤ºç‰ˆæœ¬**ï¼Œé‡‡ç”¨å•æœºéƒ¨ç½²ï¼Œç®€åŒ–æ¶æ„ï¼Œä¾¿äºå¿«é€Ÿç†è§£å’ŒéªŒè¯æ ¸å¿ƒåŠŸèƒ½ã€‚

**Demoç‰ˆæœ¬ç‰¹ç‚¹**
- ğŸ¯ **å•æœºéƒ¨ç½²**: æ— éœ€Dockerã€æ•°æ®åº“ã€ä¸­é—´ä»¶
- ğŸš€ **å¿«é€Ÿå¯åŠ¨**: ä¸‰ä¸ªå‘½ä»¤å³å¯è¿è¡Œå®Œæ•´ç³»ç»Ÿ
- ğŸ’¡ **ç®€åŒ–è®¾è®¡**: å†…å­˜å­˜å‚¨ã€æœ¬åœ°ç¼“å­˜ã€æ— éœ€è®¤è¯
- ğŸ“š **å­¦ä¹ å‹å¥½**: æ¸…æ™°çš„ä»£ç ç»“æ„ï¼Œæ˜“äºç†è§£

**å…³é”®æŒ‡æ ‡**
- ç«¯åˆ°ç«¯å»¶è¿Ÿ < 200msï¼ˆç›®æ ‡ < 100msï¼‰
- æ”¯æŒ2%ã€5%ã€10%ä¸¢åŒ…ç‡ç¯å¢ƒæµ‹è¯•
- æ”¯æŒå¤šè·¯å¤ç”¨ï¼Œå•å¹³å°å¯åˆ†å‘åˆ°å¤šä¸ªå‰ç«¯
- å¸§çº§åˆ†ç‰‡ä¼ è¾“ï¼Œå®æ—¶æ’­æ”¾æ§åˆ¶

**æŠ€æœ¯äº®ç‚¹**
- è®¾å¤‡ç«¯é‡‡ç”¨QUICåè®®ï¼Œå®ç°æä½å»¶è¿Ÿä¼ è¾“
- å¹³å°ç«¯å®ç°QUICâ†”HTTP3åè®®æ— ç¼è½¬æ¢
- æ”¯æŒç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾ä¸¤ç§æ¨¡å¼
- å®Œæ•´çš„è®¾å¤‡ç®¡ç†å’Œå½•åƒæ–‡ä»¶ç®¡ç†åŠŸèƒ½
- åŸºäºæ—¶é—´æˆ³çš„ç«¯åˆ°ç«¯å»¶è¿Ÿç›‘æ§

**æ ¸å¿ƒåŠŸèƒ½**
1. **è®¾å¤‡ç®¡ç†**: æŸ¥è¯¢åœ¨çº¿è®¾å¤‡åˆ—è¡¨å’ŒçŠ¶æ€
2. **å½•åƒæŸ¥è¯¢**: æ–‡ä»¶ç³»ç»Ÿæ‰«æï¼Œè·å–å½•åƒåˆ—è¡¨
3. **ç›´é€šæ’­æ”¾**: è®¾å¤‡å®æ—¶è§†é¢‘æµâ†’å¹³å°ç«¯â†’Webå‰ç«¯ï¼Œå»¶è¿Ÿ<100ms
4. **å½•åƒå›æ”¾**: æ”¯æŒæ’­æ”¾ã€æš‚åœã€æ‹–åŠ¨ã€å¿«è¿›ã€å€é€Ÿç­‰å®Œæ•´æ§åˆ¶
5. **å®æ—¶ç›‘æ§**: WebSocketæ¨é€å®æ—¶äº‹ä»¶ï¼Œæ€§èƒ½ç»Ÿè®¡

**æŠ€æœ¯æ ˆ**
- **åç«¯**: Rust + Quinn (QUIC) + HTTP3
- **å‰ç«¯**: React + TypeScript
- **è§†é¢‘æ ¼å¼**: H.264ã€MP4
- **å­˜å‚¨**: å†…å­˜ + æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ
- **ç¼“å­˜**: æœ¬åœ°LRU Cache

**é€‚ç”¨åœºæ™¯**
- æŠ€æœ¯éªŒè¯å’ŒDemoæ¼”ç¤º
- å­¦ä¹ HTTP3/QUICåè®®
- è§†é¢‘æµä¼ è¾“åŸå‹å¼€å‘
- ç®—æ³•å’Œæ€§èƒ½æµ‹è¯•

---

## 1. ç³»ç»Ÿæ¦‚è¿°

### 1.1 é¡¹ç›®èƒŒæ™¯
æœ¬ç³»ç»ŸåŸºäºHTTP3/QUICåè®®æ„å»ºç«¯åˆ°ç«¯è§†é¢‘æµä¼ è¾“å¹³å°ï¼Œå®ç°è®¾å¤‡ç«¯åˆ°å¹³å°ç«¯çš„ä½å»¶è¿Ÿè§†é¢‘ä¼ è¾“ï¼Œå¹¶æ”¯æŒå¹³å°ç«¯å‘å¤šä¸ªWebå‰ç«¯çš„å®æ—¶åˆ†å‘ã€‚ç³»ç»Ÿé‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œç¡®ä¿è§†é¢‘å»¶è¿Ÿå°äº200æ¯«ç§’ï¼Œæ”¯æŒå¤šè·¯å¤ç”¨å’Œå®æ—¶æ’­æ”¾æ§åˆ¶ã€‚

### 1.2 æ ¸å¿ƒç›®æ ‡
- **æä½å»¶è¿Ÿ**: ç«¯åˆ°ç«¯å»¶è¿Ÿ < 200msï¼Œä¼˜åŒ–ç›®æ ‡ < 100ms
- **é«˜å¯é æ€§**: æ”¯æŒç½‘ç»œæŠ–åŠ¨å’Œä¸¢åŒ…æ¢å¤ï¼ˆ2%ã€5%ã€10%ä¸¢åŒ…ç‡æµ‹è¯•ï¼‰
- **å¤šè·¯å¤ç”¨**: å¹³å°ç«¯åŒæ—¶åˆ†å‘åˆ°å¤šä¸ªWebå‰ç«¯
- **å®æ—¶æ§åˆ¶**: æ’­æ”¾ã€æš‚åœã€æ¢å¤ã€æ‹–åŠ¨ã€å¿«è¿›åŠŸèƒ½
- **åè®®ä¼˜åŒ–**: è®¾å¤‡ç«¯QUICï¼Œå‰ç«¯HTTP3ï¼Œå¹³å°ç«¯åè®®è½¬æ¢

### 1.3 æŠ€æœ¯æ¶æ„ç‰¹ç‚¹
- **è®¾å¤‡ç«¯ â†” å¹³å°ç«¯**: QUICåè®®ï¼ˆUDPåŸºç¡€ï¼Œä½å»¶è¿Ÿä¼˜å…ˆï¼‰
- **å¹³å°ç«¯ â†” Webå‰ç«¯**: HTTP3åè®®ï¼ˆæ ‡å‡†åŒ–ï¼Œå…¼å®¹æ€§å¥½ï¼‰
- **è§†é¢‘æ ¼å¼æ”¯æŒ**: H.264ã€MP4ï¼Œå¸§çº§åˆ†ç‰‡ä¼ è¾“
- **å»¶è¿Ÿç›‘æ§**: åŸºäºæ—¶é—´æˆ³çš„ç«¯åˆ°ç«¯å»¶è¿Ÿæµ‹é‡
- **è‡ªé€‚åº”ä¼ è¾“**: æ ¹æ®ç½‘ç»œæ¡ä»¶åŠ¨æ€è°ƒæ•´ä¼ è¾“ç­–ç•¥
- **éƒ¨ç½²æ¨¡å¼**: Demoå•æœºç‰ˆæœ¬ï¼Œç®€åŒ–æ¶æ„ï¼Œæ— éœ€æ•°æ®åº“å’Œåˆ†å¸ƒå¼ç»„ä»¶

## 2. ç³»ç»Ÿæ¶æ„æ€»è§ˆ

### 2.1 æ•´ä½“æ¶æ„å›¾

```mermaid
graph LR
    subgraph è®¾å¤‡ç«¯["è®¾å¤‡ç«¯ (QUICå®¢æˆ·ç«¯)"]
        D1[è§†é¢‘é‡‡é›†]
        D2[QUICå®¢æˆ·ç«¯]
        D3[å¸§çº§åˆ†ç‰‡]
        D4[æ’­æ”¾æ§åˆ¶å“åº”]
    end
    
    subgraph å¹³å°ç«¯["å¹³å°ç«¯ (æ ¸å¿ƒæœåŠ¡å™¨)"]
        P1[QUICæœåŠ¡å™¨]
        P2[HTTP3æœåŠ¡å™¨]
        P3[åè®®è½¬æ¢å™¨]
        P4[å¤šè·¯åˆ†å‘]
        P5[å»¶è¿Ÿç›‘æ§]
        P6[ç¼“å­˜ç®¡ç†]
        P7[è®¾å¤‡ç®¡ç†]
        P8[å½•åƒç®¡ç†]
    end
    
    subgraph å‰ç«¯1["Webå‰ç«¯1 (HTTP3å®¢æˆ·ç«¯)"]
        W1[è§†é¢‘æ’­æ”¾å™¨]
        W2[æ’­æ”¾æ§åˆ¶]
        W3[çŠ¶æ€ç›‘æ§]
    end
    
    subgraph å‰ç«¯2["Webå‰ç«¯2 (HTTP3å®¢æˆ·ç«¯)"]
        W4[è§†é¢‘æ’­æ”¾å™¨]
        W5[æ’­æ”¾æ§åˆ¶]
        W6[çŠ¶æ€ç›‘æ§]
    end
    
    subgraph å‰ç«¯N["Webå‰ç«¯N (HTTP3å®¢æˆ·ç«¯)"]
        W7[è§†é¢‘æ’­æ”¾å™¨]
        W8[æ’­æ”¾æ§åˆ¶]
        W9[çŠ¶æ€ç›‘æ§]
    end
    
    è®¾å¤‡ç«¯ -.QUICåè®®.-> P1
    P1 --> P3
    P3 --> P4
    P4 --> P2
    P2 -.HTTP3åè®®.-> å‰ç«¯1
    P2 -.HTTP3åè®®.-> å‰ç«¯2
    P2 -.HTTP3åè®®.-> å‰ç«¯N
    
    å‰ç«¯1 -.æ§åˆ¶å‘½ä»¤.-> P2
    å‰ç«¯2 -.æ§åˆ¶å‘½ä»¤.-> P2
    å‰ç«¯N -.æ§åˆ¶å‘½ä»¤.-> P2
    P2 --> P3
    P3 -.æ§åˆ¶å‘½ä»¤.-> P1
    P1 -.QUICåè®®.-> è®¾å¤‡ç«¯
    
    style è®¾å¤‡ç«¯ fill:#e1f5ff
    style å¹³å°ç«¯ fill:#fff3e0
    style å‰ç«¯1 fill:#f3e5f5
    style å‰ç«¯2 fill:#f3e5f5
    style å‰ç«¯N fill:#f3e5f5
```

### 2.2 æ ¸å¿ƒç»„ä»¶è¯´æ˜

#### 2.2.1 è®¾å¤‡ç«¯ï¼ˆQUICå®¢æˆ·ç«¯ï¼‰
- **åŠŸèƒ½**: è§†é¢‘é‡‡é›†ã€ç¼–ç ã€åˆ†ç‰‡ä¼ è¾“
- **åè®®**: QUIC over UDP
- **ç‰¹æ€§**: å¸§çº§åˆ†ç‰‡ã€å®æ—¶å“åº”æ’­æ”¾æ§åˆ¶
- **å®ç°**: åŸºäºç°æœ‰PLATFORM_INTEGRATION_PROTOCOL.md

#### 2.2.2 å¹³å°ç«¯ï¼ˆæ ¸å¿ƒæœåŠ¡å™¨ï¼‰
- **åŠŸèƒ½**: åè®®è½¬æ¢ã€å¤šè·¯åˆ†å‘ã€å»¶è¿Ÿç›‘æ§
- **åè®®**: å•ä¸€æœåŠ¡è¿›ç¨‹ï¼ŒåŒæ—¶ç›‘å¬ä¸¤ä¸ªç«¯å£
  - QUICç«¯å£ï¼ˆ8080ï¼‰ï¼šæ¥æ”¶è®¾å¤‡ç«¯è¿æ¥
  - HTTP3ç«¯å£ï¼ˆ8443ï¼‰ï¼šæ¥æ”¶Webå‰ç«¯è¿æ¥
- **ç‰¹æ€§**: è¾¹æ¥æ”¶è¾¹è½¬å‘ã€ç¼“å­˜ç®¡ç†ã€è´Ÿè½½å‡è¡¡
- **å®ç°**: é‡ç‚¹è®¾è®¡ç»„ä»¶

**è¯´æ˜**ï¼šQUICæœåŠ¡å™¨å’ŒHTTP3æœåŠ¡å™¨æ˜¯åŒä¸€ä¸ªè¿›ç¨‹çš„ä¸¤ä¸ªç›‘å¬ç«¯å£ï¼Œä¸æ˜¯ä¸¤ä¸ªç‹¬ç«‹æœåŠ¡ã€‚HTTP3æœ¬èº«å°±æ˜¯åŸºäºQUICåè®®çš„HTTPï¼Œæ‰€ä»¥åº•å±‚éƒ½ä½¿ç”¨QUICä¼ è¾“ã€‚

#### 2.2.3 Webå‰ç«¯ï¼ˆHTTP3å®¢æˆ·ç«¯ï¼‰
- **åŠŸèƒ½**: è§†é¢‘æ’­æ”¾ã€ç”¨æˆ·äº¤äº’ã€çŠ¶æ€ç›‘æ§
- **åè®®**: HTTP3 over QUIC
- **ç‰¹æ€§**: æ’­æ”¾å™¨ç»„ä»¶ã€æ§åˆ¶é¢æ¿ã€å®æ—¶çŠ¶æ€æ˜¾ç¤º
- **å®ç°**: ç®€è¦è®¾è®¡

## 3. åè®®è®¾è®¡

### 3.1 ä¼ è¾“åè®®åˆ†å±‚

```
åº”ç”¨å±‚    â”‚ åª’ä½“ä¼ è¾“åè®® â”‚ ä¿¡ä»¤ä¼ è¾“åè®® â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
ä¼ è¾“å±‚    â”‚    HTTP3     â”‚    HTTP3     â”‚  â† å¹³å°ç«¯ â†” Webå‰ç«¯
         â”‚    QUIC      â”‚    QUIC      â”‚  â† è®¾å¤‡ç«¯ â†” å¹³å°ç«¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
ç½‘ç»œå±‚    â”‚     UDP      â”‚     UDP      â”‚
```

### 3.2 åª’ä½“ä¼ è¾“åè®®è®¾è®¡

#### 3.2.1 è®¾å¤‡ç«¯ â†’ å¹³å°ç«¯ (QUIC)

**åè®®æ¦‚è¿°**ï¼šè®¾å¤‡ç«¯ä¸å¹³å°ç«¯ä¹‹é—´é‡‡ç”¨QUICåè®®è¿›è¡Œè§†é¢‘åˆ†ç‰‡ä¼ è¾“ï¼ŒåŸºäºç°æœ‰PLATFORM_INTEGRATION_PROTOCOL.mdè§„èŒƒï¼Œé’ˆå¯¹ä½å»¶è¿Ÿåœºæ™¯è¿›è¡Œä¼˜åŒ–ã€‚

##### 3.2.1.1 è§†é¢‘åˆ†ç‰‡æ ¼å¼å®šä¹‰

**äºŒè¿›åˆ¶å¸§æ ¼å¼**ï¼ˆå›ºå®š42å­—èŠ‚å¤´éƒ¨ + å¯å˜é•¿åº¦æ•°æ®ï¼‰ï¼š

```rust
// è§†é¢‘åˆ†ç‰‡ç»“æ„ï¼ˆæ¥è‡ªPLATFORM_INTEGRATION_PROTOCOL.mdï¼‰
#[repr(C)]
pub struct VideoSegment {
    // === åŸºç¡€æ ‡è¯†å­—æ®µ (25å­—èŠ‚) ===
    pub stream_type: u8,        // æµç±»å‹: 0x01=è§†é¢‘, 0x02=éŸ³é¢‘
    pub segment_id: [u8; 16],   // åˆ†ç‰‡å”¯ä¸€æ ‡è¯†ç¬¦ (UUID v4)
    pub timestamp: f64,         // ç›¸å¯¹æ—¶é—´æˆ³(ç§’, IEEE 754åŒç²¾åº¦)
    
    // === åˆ†ç‰‡å…ƒæ•°æ® (13å­—èŠ‚) ===
    pub duration: f64,          // åˆ†ç‰‡æ—¶é•¿(ç§’)
    pub frame_count: u32,       // åŒ…å«çš„å¸§æ•°é‡
    pub flags: u8,              // æ ‡å¿—ä½ï¼ˆè§ä¸‹æ–¹å®šä¹‰ï¼‰
    
    // === æ•°æ®é•¿åº¦ (4å­—èŠ‚) ===
    pub data_length: u32,       // å®é™…è§†é¢‘æ•°æ®é•¿åº¦(å­—èŠ‚)
    
    // === å¯å˜é•¿åº¦æ•°æ® ===
    pub data: Vec<u8>,          // å®é™…è§†é¢‘æ•°æ®ï¼ˆH.264 NALå•å…ƒæˆ–MP4ç‰‡æ®µï¼‰
}

// æ ‡å¿—ä½å®šä¹‰ (flagså­—æ®µ)
pub mod SegmentFlags {
    pub const IS_KEYFRAME: u8       = 0b0000_0001;  // æ˜¯å¦ä¸ºå…³é”®å¸§
    pub const HAS_AUDIO: u8         = 0b0000_0010;  // æ˜¯å¦åŒ…å«éŸ³é¢‘
    pub const IS_LAST_SEGMENT: u8   = 0b0000_0100;  // æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªåˆ†ç‰‡
    pub const REQUIRES_ACK: u8      = 0b0000_1000;  // æ˜¯å¦éœ€è¦ç¡®è®¤
    pub const HIGH_PRIORITY: u8     = 0b0001_0000;  // é«˜ä¼˜å…ˆçº§åˆ†ç‰‡
    pub const CORRUPTED: u8         = 0b0010_0000;  // æ•°æ®å¯èƒ½æŸå
    pub const RETRANSMISSION: u8    = 0b0100_0000;  // é‡ä¼ åˆ†ç‰‡
    pub const RESERVED: u8          = 0b1000_0000;  // ä¿ç•™ä½
}
```

**å­—æ®µè¯´æ˜**ï¼š

| å­—æ®µ | ç±»å‹ | å¤§å° | è¯´æ˜ |
|------|------|------|------|
| stream_type | u8 | 1å­—èŠ‚ | æµç±»å‹æ ‡è¯†ï¼Œ0x01=è§†é¢‘ï¼Œ0x02=éŸ³é¢‘ |
| segment_id | UUID | 16å­—èŠ‚ | å…¨å±€å”¯ä¸€åˆ†ç‰‡æ ‡è¯†ç¬¦ï¼Œç”¨äºå»é‡å’Œè¿½è¸ª |
| timestamp | f64 | 8å­—èŠ‚ | ç›¸å¯¹æ—¶é—´æˆ³ï¼ˆç§’ï¼‰ï¼Œä»æµå¼€å§‹è®¡æ—¶ |
| duration | f64 | 8å­—èŠ‚ | åˆ†ç‰‡æ—¶é•¿ï¼ˆç§’ï¼‰ï¼Œç”¨äºæ’­æ”¾åŒæ­¥ |
| frame_count | u32 | 4å­—èŠ‚ | åŒ…å«çš„è§†é¢‘å¸§æ•°é‡ï¼Œé€šå¸¸ä¸º1ï¼ˆå¸§çº§åˆ†ç‰‡ï¼‰ |
| flags | u8 | 1å­—èŠ‚ | æ ‡å¿—ä½ï¼Œæ ‡è¯†å…³é”®å¸§ã€ä¼˜å…ˆçº§ç­‰å±æ€§ |
| data_length | u32 | 4å­—èŠ‚ | å®é™…æ•°æ®é•¿åº¦ï¼Œä¸åŒ…æ‹¬å¤´éƒ¨ |
| data | Vec<u8> | å¯å˜ | å®é™…è§†é¢‘æ•°æ®ï¼ŒH.264 NALå•å…ƒæˆ–MP4ç‰‡æ®µ |

##### 3.2.1.2 åˆ†ç‰‡ç­–ç•¥

**æ ¹æ®æ–‡ä»¶æ ¼å¼è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜åˆ†ç‰‡ç­–ç•¥**ï¼š

```rust
pub enum SegmentMode {
    Frame,      // å¸§çº§åˆ†ç‰‡ - H.264è£¸æµ
    GOP,        // GOPçº§åˆ†ç‰‡ - å…³é”®å¸§ç»„
    Time,       // æ—¶é—´åˆ†ç‰‡ - å›ºå®šæ—¶é•¿
    Fixed,      // å›ºå®šå¤§å°åˆ†ç‰‡ - MP4å®¹å™¨
}

// åˆ†ç‰‡ç­–ç•¥é€‰æ‹©é€»è¾‘
impl SegmentStrategy {
    pub fn select_strategy(file_format: &str) -> SegmentMode {
        match file_format {
            "h264" | "264" => SegmentMode::Frame,  // å¸§çº§åˆ†ç‰‡ï¼Œæœ€ä½å»¶è¿Ÿ
            "mp4" | "m4v" => SegmentMode::Fixed,   // 256KBå›ºå®šåˆ†ç‰‡
            "mkv" | "avi" => SegmentMode::Time,    // 1ç§’æ—¶é—´åˆ†ç‰‡
            _ => SegmentMode::Fixed,               // é»˜è®¤å›ºå®šåˆ†ç‰‡
        }
    }
}
```

**åˆ†ç‰‡å¤§å°å¯¹æ¯”**ï¼š

| æ–‡ä»¶æ ¼å¼ | åˆ†ç‰‡æ¨¡å¼ | å¹³å‡å¤§å° | å»¶è¿Ÿç‰¹æ€§ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|---------|---------|
| H.264è£¸æµ | Frame | 2-50KB | æä½å»¶è¿Ÿ | å®æ—¶ç›´æ’­ã€ç›‘æ§ |
| MP4å®¹å™¨ | Fixed | 256KB | ä½å»¶è¿Ÿ | å½•åƒå›æ”¾ |
| MKVå®¹å™¨ | Time | å¯å˜ | ä¸­ç­‰å»¶è¿Ÿ | é€šç”¨å›æ”¾ |
| GOPåˆ†ç‰‡ | GOP | 100-500KB | ä½å»¶è¿Ÿ | å¹³è¡¡æ¨¡å¼ |

##### 3.2.1.3 QUICä¼ è¾“ä¼˜åŒ–

**æµä¼˜å…ˆçº§é…ç½®**ï¼š

```rust
// QUICæµä¼˜å…ˆçº§è®¾ç½®
pub struct StreamPriority {
    pub urgency: u8,        // ç´§æ€¥åº¦: 0-7 (0æœ€é«˜)
    pub incremental: bool,  // æ˜¯å¦å¢é‡ä¼ è¾“
}

impl StreamPriority {
    // è§†é¢‘å…³é”®å¸§ï¼šæœ€é«˜ä¼˜å…ˆçº§
    pub fn keyframe() -> Self {
        Self { urgency: 0, incremental: false }
    }
    
    // è§†é¢‘æ™®é€šå¸§ï¼šé«˜ä¼˜å…ˆçº§
    pub fn video_frame() -> Self {
        Self { urgency: 2, incremental: false }
    }
    
    // éŸ³é¢‘å¸§ï¼šä¸­ç­‰ä¼˜å…ˆçº§
    pub fn audio_frame() -> Self {
        Self { urgency: 3, incremental: false }
    }
    
    // æ§åˆ¶ä¿¡ä»¤ï¼šæœ€é«˜ä¼˜å…ˆçº§
    pub fn control_message() -> Self {
        Self { urgency: 0, incremental: false }
    }
}
```

**ä¼ è¾“å‚æ•°ä¼˜åŒ–**ï¼š

```rust
// QUICä¼ è¾“é…ç½®ï¼ˆé’ˆå¯¹ä½å»¶è¿Ÿä¼˜åŒ–ï¼‰
pub struct QUICTransportConfig {
    // è¿æ¥å‚æ•°
    pub max_concurrent_uni_streams: u64,    // 100 - æ”¯æŒå¤šè·¯å¤ç”¨
    pub max_concurrent_bidi_streams: u64,   // 10 - æ§åˆ¶ä¿¡ä»¤
    
    // æµé‡æ§åˆ¶
    pub stream_receive_window: u64,         // 5MB - å•æµæ¥æ”¶çª—å£
    pub connection_receive_window: u64,     // 50MB - è¿æ¥æ€»çª—å£
    pub max_stream_data: u64,               // 10MB - å•æµæœ€å¤§æ•°æ®
    
    // æ‹¥å¡æ§åˆ¶
    pub congestion_controller: CongestionController, // BBRç®—æ³•
    pub initial_rtt: Duration,              // 50ms - åˆå§‹RTTä¼°è®¡
    pub min_rtt: Duration,                  // 10ms - æœ€å°RTT
    
    // ä¿æ´»å’Œè¶…æ—¶
    pub keep_alive_interval: Duration,      // 5s - å¿ƒè·³é—´éš”
    pub max_idle_timeout: Duration,         // 60s - ç©ºé—²è¶…æ—¶
    pub handshake_timeout: Duration,        // 10s - æ¡æ‰‹è¶…æ—¶
    
    // é‡ä¼ å’Œæ¢å¤
    pub max_ack_delay: Duration,            // 25ms - æœ€å¤§ACKå»¶è¿Ÿ
    pub ack_frequency: u32,                 // 2 - æ¯2ä¸ªåŒ…ç¡®è®¤ä¸€æ¬¡
    pub enable_early_data: bool,            // true - å¯ç”¨0-RTT
}

impl Default for QUICTransportConfig {
    fn default() -> Self {
        Self {
            max_concurrent_uni_streams: 100,
            max_concurrent_bidi_streams: 10,
            stream_receive_window: 5_000_000,
            connection_receive_window: 50_000_000,
            max_stream_data: 10_000_000,
            congestion_controller: CongestionController::BBR,
            initial_rtt: Duration::from_millis(50),
            min_rtt: Duration::from_millis(10),
            keep_alive_interval: Duration::from_secs(5),
            max_idle_timeout: Duration::from_secs(60),
            handshake_timeout: Duration::from_secs(10),
            max_ack_delay: Duration::from_millis(25),
            ack_frequency: 2,
            enable_early_data: true,
        }
    }
}
```

##### 3.2.1.4 ä¼ è¾“æµç¨‹

```mermaid
sequenceDiagram
    participant D as è®¾å¤‡ç«¯
    participant Q as QUICä¼ è¾“å±‚
    participant P as å¹³å°ç«¯
    
    Note over D,P: 1. è¿æ¥å»ºç«‹ï¼ˆ0-RTTä¼˜åŒ–ï¼‰
    D->>Q: å»ºç«‹QUICè¿æ¥
    Q->>P: ClientHello + 0-RTTæ•°æ®
    P->>Q: ServerHello + åŠ å¯†å‚æ•°
    Q->>D: è¿æ¥å°±ç»ª
    
    Note over D,P: 2. è§†é¢‘åˆ†ç‰‡ä¼ è¾“
    loop æ¯ä¸ªè§†é¢‘å¸§
        D->>D: è¯»å–è§†é¢‘å¸§
        D->>D: æ„å»ºVideoSegment
        D->>D: è®¾ç½®ä¼˜å…ˆçº§ï¼ˆå…³é”®å¸§=0ï¼‰
        
        alt å…³é”®å¸§
            D->>Q: å‘é€ï¼ˆä¼˜å…ˆçº§0ï¼Œä¸å¯ä¸¢å¼ƒï¼‰
            Q->>P: å¯é ä¼ è¾“
            P->>Q: ACKç¡®è®¤
        else æ™®é€šå¸§
            D->>Q: å‘é€ï¼ˆä¼˜å…ˆçº§2ï¼Œå¯ä¸¢å¼ƒï¼‰
            Q->>P: å°½åŠ›ä¼ è¾“
        end
        
        P->>P: è®°å½•æ¥æ”¶æ—¶é—´æˆ³
        P->>P: è®¡ç®—ä¼ è¾“å»¶è¿Ÿ
        
        alt å»¶è¿Ÿè¶…è¿‡é˜ˆå€¼
            P->>D: è¯·æ±‚é™ä½ç ç‡
        end
    end
    
    Note over D,P: 3. é”™è¯¯æ¢å¤
    alt æ£€æµ‹åˆ°ä¸¢åŒ…
        P->>D: NACKè¯·æ±‚é‡ä¼ 
        D->>Q: é‡ä¼ åˆ†ç‰‡ï¼ˆæ ‡è®°RETRANSMISSIONï¼‰
        Q->>P: é‡ä¼ æ•°æ®
    end
    
    Note over D,P: 4. è¿æ¥ä¿æ´»
    loop æ¯5ç§’
        D->>Q: PINGå¸§
        Q->>P: å¿ƒè·³
        P->>Q: PONGå¸§
    end
```

##### 3.2.1.5 æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

**1. é›¶æ‹·è´ä¼ è¾“**

```rust
// ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯å‡å°‘å†…å­˜å¤åˆ¶
pub async fn send_segment_zero_copy(
    stream: &mut SendStream,
    segment: &VideoSegment,
) -> Result<(), TransportError> {
    // 1. ç›´æ¥å‘é€å¤´éƒ¨ï¼ˆæ ˆä¸Šæ•°æ®ï¼‰
    let header_bytes = segment.serialize_header();
    stream.write_all(&header_bytes).await?;
    
    // 2. é›¶æ‹·è´å‘é€æ•°æ®ï¼ˆé¿å…å†…å­˜å¤åˆ¶ï¼‰
    stream.write_all_vectored(&[
        IoSlice::new(&segment.data)
    ]).await?;
    
    Ok(())
}
```

**2. æ‰¹é‡å‘é€ä¼˜åŒ–**

```rust
// æ‰¹é‡å‘é€å¤šä¸ªå°åˆ†ç‰‡ï¼Œå‡å°‘ç³»ç»Ÿè°ƒç”¨
pub async fn send_batch(
    stream: &mut SendStream,
    segments: Vec<VideoSegment>,
) -> Result<(), TransportError> {
    let mut buffer = Vec::with_capacity(segments.len() * 1024);
    
    // æ‰¹é‡åºåˆ—åŒ–
    for segment in segments {
        buffer.extend_from_slice(&segment.serialize());
    }
    
    // ä¸€æ¬¡æ€§å‘é€
    stream.write_all(&buffer).await?;
    
    Ok(())
}
```

**3. è‡ªé€‚åº”ç ç‡æ§åˆ¶**

```rust
// æ ¹æ®ç½‘ç»œæ¡ä»¶åŠ¨æ€è°ƒæ•´ä¼ è¾“é€Ÿç‡
pub struct AdaptiveBitrateController {
    current_bitrate: u64,
    target_bitrate: u64,
    min_bitrate: u64,
    max_bitrate: u64,
    rtt_history: VecDeque<Duration>,
    loss_rate_history: VecDeque<f64>,
}

impl AdaptiveBitrateController {
    pub fn adjust_bitrate(&mut self, network_stats: &NetworkStats) -> u64 {
        // 1. è®¡ç®—ç½‘ç»œè´¨é‡è¯„åˆ†
        let quality_score = self.calculate_quality_score(network_stats);
        
        // 2. æ ¹æ®è¯„åˆ†è°ƒæ•´ç ç‡
        self.target_bitrate = match quality_score {
            score if score > 0.9 => self.max_bitrate,                    // ä¼˜ç§€
            score if score > 0.7 => (self.max_bitrate * 3) / 4,         // è‰¯å¥½
            score if score > 0.5 => self.max_bitrate / 2,               // ä¸€èˆ¬
            score if score > 0.3 => self.max_bitrate / 4,               // è¾ƒå·®
            _ => self.min_bitrate,                                       // æå·®
        };
        
        // 3. å¹³æ»‘è¿‡æ¸¡ï¼ˆé¿å…å‰§çƒˆæ³¢åŠ¨ï¼‰
        let adjustment = (self.target_bitrate as i64 - self.current_bitrate as i64) / 4;
        self.current_bitrate = (self.current_bitrate as i64 + adjustment) as u64;
        
        self.current_bitrate
    }
    
    fn calculate_quality_score(&self, stats: &NetworkStats) -> f64 {
        let rtt_score = 1.0 - (stats.rtt.as_millis() as f64 / 500.0).min(1.0);
        let loss_score = 1.0 - (stats.packet_loss_rate * 10.0).min(1.0);
        let bandwidth_score = (stats.available_bandwidth as f64 / self.max_bitrate as f64).min(1.0);
        
        // åŠ æƒå¹³å‡
        (rtt_score * 0.3 + loss_score * 0.4 + bandwidth_score * 0.3)
    }
}
```

##### 3.2.1.6 é”™è¯¯å¤„ç†å’Œé‡ä¼ æœºåˆ¶

**é”™è¯¯ç±»å‹å®šä¹‰**ï¼š

```rust
#[derive(Debug, Clone)]
pub enum TransmissionError {
    // ç½‘ç»œé”™è¯¯
    ConnectionLost,              // è¿æ¥ä¸¢å¤±
    ConnectionTimeout,           // è¿æ¥è¶…æ—¶
    StreamClosed,                // æµå·²å…³é—­
    
    // ä¼ è¾“é”™è¯¯
    SegmentTooLarge,            // åˆ†ç‰‡è¿‡å¤§
    InvalidSegmentFormat,        // åˆ†ç‰‡æ ¼å¼é”™è¯¯
    ChecksumMismatch,           // æ ¡éªŒå’Œä¸åŒ¹é…
    
    // èµ„æºé”™è¯¯
    BufferOverflow,             // ç¼“å†²åŒºæº¢å‡º
    OutOfMemory,                // å†…å­˜ä¸è¶³
    TooManyStreams,             // æµæ•°é‡è¶…é™
    
    // åè®®é”™è¯¯
    ProtocolViolation,          // åè®®è¿è§„
    UnsupportedVersion,         // ä¸æ”¯æŒçš„ç‰ˆæœ¬
}

// é”™è¯¯æ¢å¤ç­–ç•¥
pub struct ErrorRecoveryPolicy {
    pub max_retries: u32,                    // æœ€å¤§é‡è¯•æ¬¡æ•°
    pub retry_strategy: RetryStrategy,       // é‡è¯•ç­–ç•¥
    pub backoff_base: Duration,              // é€€é¿åŸºç¡€æ—¶é—´
    pub backoff_max: Duration,               // æœ€å¤§é€€é¿æ—¶é—´
    pub circuit_breaker_threshold: u32,      // ç†”æ–­é˜ˆå€¼
}

#[derive(Debug, Clone)]
pub enum RetryStrategy {
    Immediate,                   // ç«‹å³é‡è¯•
    FixedDelay(Duration),       // å›ºå®šå»¶è¿Ÿ
    ExponentialBackoff,         // æŒ‡æ•°é€€é¿ï¼ˆæ¨èï¼‰
    LinearBackoff,              // çº¿æ€§é€€é¿
}
```

**é‡ä¼ å®ç°**ï¼š

```rust
pub async fn send_with_retry(
    stream: &mut SendStream,
    segment: VideoSegment,
    policy: &ErrorRecoveryPolicy,
) -> Result<(), TransmissionError> {
    let mut retry_count = 0;
    let mut backoff_duration = policy.backoff_base;
    
    loop {
        match stream.write_segment(&segment).await {
            Ok(_) => {
                // å‘é€æˆåŠŸ
                return Ok(());
            }
            Err(e) if retry_count < policy.max_retries => {
                // å¯é‡è¯•é”™è¯¯
                retry_count += 1;
                
                warn!("Transmission failed (attempt {}/{}): {:?}", 
                      retry_count, policy.max_retries, e);
                
                // æ ¹æ®ç­–ç•¥è®¡ç®—é€€é¿æ—¶é—´
                backoff_duration = match policy.retry_strategy {
                    RetryStrategy::Immediate => Duration::ZERO,
                    RetryStrategy::FixedDelay(d) => d,
                    RetryStrategy::ExponentialBackoff => {
                        (backoff_duration * 2).min(policy.backoff_max)
                    }
                    RetryStrategy::LinearBackoff => {
                        (backoff_duration + policy.backoff_base).min(policy.backoff_max)
                    }
                };
                
                // ç­‰å¾…åé‡è¯•
                if backoff_duration > Duration::ZERO {
                    tokio::time::sleep(backoff_duration).await;
                }
            }
            Err(e) => {
                // ä¸å¯æ¢å¤é”™è¯¯æˆ–é‡è¯•æ¬¡æ•°è€—å°½
                error!("Transmission failed permanently: {:?}", e);
                return Err(e);
            }
        }
    }
}
```

##### 3.2.1.7 æ€§èƒ½æŒ‡æ ‡

**å®æµ‹æ€§èƒ½æ•°æ®**ï¼ˆåŸºäºè®¾å¤‡ç«¯å®ç°ï¼‰ï¼š

| æŒ‡æ ‡ | H.264æ–‡ä»¶ | MP4æ–‡ä»¶ | è¯´æ˜ |
|------|----------|---------|------|
| **åˆ†ç‰‡å¤§å°** | 2-50KB | 256KB | å¸§çº§ vs å›ºå®š |
| **åˆ†ç‰‡æ•°é‡** | 150ä¸ª/ç§’ | 20ä¸ª/ç§’ | 30fpsè§†é¢‘ |
| **å³°å€¼ååé‡** | 109.2 Mbps | 896.5 Mbps | å®æµ‹æœ€å¤§å€¼ |
| **å¹³å‡ååé‡** | 9.4 Mbps | 50 Mbps | ç¨³å®šä¼ è¾“ |
| **ä¼ è¾“å»¶è¿Ÿ** | 5-15ms | 10-30ms | ç½‘ç»œRTT |
| **CPUå ç”¨** | 15-25% | 10-20% | å•æ ¸å ç”¨ |
| **å†…å­˜å ç”¨** | 50-100MB | 100-200MB | ç¼“å†²åŒº |

**å»¶è¿Ÿåˆ†è§£**ï¼š

```
ç«¯åˆ°ç«¯å»¶è¿Ÿ = ç¼–ç å»¶è¿Ÿ + åˆ†ç‰‡å»¶è¿Ÿ + ä¼ è¾“å»¶è¿Ÿ + å¤„ç†å»¶è¿Ÿ
           = 10ms    + 2ms     + 15ms     + 5ms
           = 32ms (ç†æƒ³æƒ…å†µ)

å®é™…å»¶è¿Ÿ = 50-100ms (åŒ…å«ç½‘ç»œæŠ–åŠ¨å’Œæ’é˜Ÿå»¶è¿Ÿ)
```

#### 3.2.2 å¹³å°ç«¯ â†’ Webå‰ç«¯ (HTTP3) - ç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆ

**åè®®æ¦‚è¿°**ï¼šå¹³å°ç«¯ä¸Webå‰ç«¯ä¹‹é—´é‡‡ç”¨HTTP3åè®®è¿›è¡Œè§†é¢‘åˆ†ç‰‡ä¼ è¾“ï¼Œä½¿ç”¨SSEï¼ˆServer-Sent Eventsï¼‰æ¨é€æœºåˆ¶å®ç°ä½å»¶è¿Ÿæµå¼ä¼ è¾“ã€‚è¯¥æ–¹æ¡ˆç»Ÿä¸€æ”¯æŒç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾ï¼Œå®ç°ç«¯åˆ°ç«¯å»¶è¿Ÿå°äº200msçš„ç›®æ ‡ã€‚

##### 3.2.2.1 ç»Ÿä¸€æµä¼ è¾“æ¶æ„

**æ ¸å¿ƒè®¾è®¡ç†å¿µ**ï¼š
- **ç»Ÿä¸€å¤„ç†**: ç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾ä½¿ç”¨ç›¸åŒçš„ä¼ è¾“æœºåˆ¶å’Œæ’­æ”¾å™¨
- **é›¶ç¼“å†²è½¬å‘**: å¹³å°ç«¯è¾¹æ¥æ”¶è¾¹è½¬å‘ï¼Œå¤„ç†å»¶è¿Ÿ<5ms
- **ä½å»¶è¿Ÿä¼˜åŒ–**: å°åˆ†ç‰‡ï¼ˆ8KB-32KBï¼‰+ æœ€å°ç¼“å†²ï¼ˆ100-500msï¼‰
- **æ™ºèƒ½ç¼“å†²**: æ ¹æ®æµç±»å‹ï¼ˆç›´é€š/å›æ”¾ï¼‰è‡ªåŠ¨è°ƒæ•´ç¼“å†²ç­–ç•¥

**ä¼ è¾“æµç¨‹**ï¼š
```
æ•°æ®æºï¼ˆè®¾å¤‡ç«¯/æ–‡ä»¶ç³»ç»Ÿï¼‰
    â†“
UnifiedStreamHandlerï¼ˆç»Ÿä¸€æµå¤„ç†å™¨ï¼‰
    â†“
é›¶ç¼“å†²è½¬å‘ï¼ˆ<5mså¤„ç†å»¶è¿Ÿï¼‰
    â†“
HTTP3/SSEæ¨é€
    â†“
UnifiedMSEPlayerï¼ˆç»Ÿä¸€MSEæ’­æ”¾å™¨ï¼‰
    â†“
è§†é¢‘æ’­æ”¾
```

##### 3.2.2.2 SSEåª’ä½“ä¼ è¾“åè®®

**ç«¯ç‚¹å®šä¹‰**ï¼š
```http
GET /api/v1/stream/{session_id}/segments HTTP/3
Accept: text/event-stream
```

**SSEäº‹ä»¶æ ¼å¼**ï¼š
```
event: segment
data: {
  "segment_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": 15.5,
  "duration": 0.033,
  "is_keyframe": true,
  "format": "fmp4",
  "data": "base64_encoded_video_data"
}

event: segment
data: {...}
```

**å…ƒæ•°æ®å­—æ®µè¯´æ˜**ï¼š

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| segment_id | UUID | åˆ†ç‰‡å”¯ä¸€æ ‡è¯†ç¬¦ |
| timestamp | f64 | ç›¸å¯¹æ—¶é—´æˆ³ï¼ˆç§’ï¼‰ |
| duration | f64 | åˆ†ç‰‡æ—¶é•¿ï¼ˆç§’ï¼‰ |
| is_keyframe | bool | æ˜¯å¦ä¸ºå…³é”®å¸§ |
| format | string | åˆ†ç‰‡æ ¼å¼ï¼ˆfmp4/h264/mp4ï¼‰ |
| data | string | Base64ç¼–ç çš„è§†é¢‘æ•°æ® |

##### 3.2.2.3 ç»Ÿä¸€æµå¯åŠ¨API

**ç«¯ç‚¹å®šä¹‰**ï¼š
```http
POST /api/v1/stream/start HTTP/3
Content-Type: application/json
```

**è¯·æ±‚æ ¼å¼**ï¼š
```json
{
  "mode": "live" | "playback",
  "source": {
    // ç›´é€šæ’­æ”¾
    "device_id": "device_001"
    // æˆ–å½•åƒå›æ”¾
    "file_id": "rec_001",
    "start_position": 0.0,
    "playback_rate": 1.0
  },
  "config": {
    "client_id": "web_client_001",
    "low_latency_mode": true,
    "target_latency_ms": 100
  }
}
```

**å“åº”æ ¼å¼**ï¼š
```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "stream_url": "/api/v1/stream/{session_id}/segments",
  "control_url": "/api/v1/stream/{session_id}/control",
  "estimated_latency_ms": 100,
  "stream_info": {
    "mode": "live" | "playback",
    "resolution": "1920x1080",
    "frame_rate": 30.0,
    "bitrate": 5000000
  }
}
```

##### 3.2.2.4 æ’­æ”¾æ§åˆ¶API

**ç«¯ç‚¹å®šä¹‰**ï¼š
```http
POST /api/v1/stream/{session_id}/control HTTP/3
Content-Type: application/json
```

**æ§åˆ¶å‘½ä»¤**ï¼š

```json
// æš‚åœ
{"command": "pause"}

// æ¢å¤
{"command": "resume"}

// å®šä½ï¼ˆä»…å›æ”¾ï¼‰
{"command": "seek", "position": 30.0}

// å€é€Ÿï¼ˆä»…å›æ”¾ï¼‰
{"command": "set_rate", "rate": 2.0}

// åœæ­¢
{"command": "stop"}
```

**å“åº”æ ¼å¼**ï¼š
```json
{
  "status": "success",
  "current_state": "paused" | "playing" | "seeking" | "stopped",
  "current_position": 15.5,
  "playback_rate": 1.0
}
```

##### 3.2.2.5 æµçŠ¶æ€æŸ¥è¯¢API

**ç«¯ç‚¹å®šä¹‰**ï¼š
```http
GET /api/v1/stream/{session_id}/status HTTP/3
```

**å“åº”æ ¼å¼**ï¼š
```json
{
  "session_id": "uuid",
  "mode": "live" | "playback",
  "state": "streaming" | "paused" | "stopped",
  "current_position": 15.5,
  "playback_rate": 1.0,
  "stats": {
    "average_latency_ms": 95,
    "current_latency_ms": 87,
    "throughput_mbps": 5.2,
    "packet_loss_rate": 0.01,
    "total_segments": 1500,
    "total_bytes": 15728640
  }
}
```

##### 3.2.2.6 æ€§èƒ½æŒ‡æ ‡

**å»¶è¿Ÿåˆ†è§£**ï¼ˆå½•åƒå›æ”¾ï¼‰ï¼š
```
æ–‡ä»¶è¯»å–:      5ms   (å°åˆ†ç‰‡ï¼Œ8KB)
åˆ†ç‰‡å¤„ç†:      2ms   (é›¶æ‹·è´)
HTTP3ä¼ è¾“:    15ms   (QUICåè®®)
å‰ç«¯æ¥æ”¶:      5ms   (SSE)
MSEè¿½åŠ :      10ms   (SourceBuffer)
è§£ç æ¸²æŸ“:     20ms   (ç¡¬ä»¶åŠ é€Ÿ)
ç¼“å†²å»¶è¿Ÿ:     50ms   (æœ€å°ç¼“å†²)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ€»å»¶è¿Ÿ:      107ms   âœ… (æä½å»¶è¿Ÿ)
```

**å»¶è¿Ÿå¯¹æ¯”**ï¼š

| åœºæ™¯ | æ—§æ–¹æ¡ˆ | æ–°æ–¹æ¡ˆï¼ˆç»Ÿä¸€ä½å»¶è¿Ÿï¼‰ | æ”¹å–„ |
|------|--------|---------------------|------|
| **ç›´é€šæ’­æ”¾** | æœªå®ç° | 50-100ms | - |
| **å½•åƒå›æ”¾** | 1000-2000ms | 100-200ms | **10å€æå‡** âœ… |

##### 3.2.2.7 ä¼ è¾“ä¼˜åŒ–æŠ€æœ¯

**1. é›¶ç¼“å†²è½¬å‘**

```rust
// å¹³å°ç«¯è¾¹æ¥æ”¶è¾¹è½¬å‘ï¼Œæ— ç¼“å†²å»¶è¿Ÿ
pub async fn forward_segment_immediate(
    &self,
    session_id: Uuid,
    segment: VideoSegment,
) -> Result<(), StreamError> {
    let receive_time = SystemTime::now();
    
    // ç«‹å³å¹¶å‘è½¬å‘åˆ°æ‰€æœ‰å®¢æˆ·ç«¯
    let clients = self.get_session_clients(session_id)?;
    let tasks: Vec<_> = clients.iter()
        .map(|client| client.send_segment(segment.clone()))
        .collect();
    
    futures::future::join_all(tasks).await;
    
    // ç›‘æ§å¤„ç†å»¶è¿Ÿ
    let processing_latency = SystemTime::now()
        .duration_since(receive_time)
        .unwrap_or_default();
    
    if processing_latency > Duration::from_millis(5) {
        warn!("High processing latency: {:?}", processing_latency);
    }
    
    Ok(())
}
```

**2. å°åˆ†ç‰‡ç­–ç•¥**

```rust
// ä½¿ç”¨å°åˆ†ç‰‡é™ä½å»¶è¿Ÿ
pub const SEGMENT_SIZE: usize = 8192;  // 8KB

// æ–‡ä»¶æµå¼è¯»å–
pub async fn read_small_segment(&mut self) -> Result<Vec<u8>, StreamError> {
    let mut buffer = vec![0u8; SEGMENT_SIZE];
    let bytes_read = self.file.read(&mut buffer).await?;
    buffer.truncate(bytes_read);
    Ok(buffer)
}
```

**3. é›¶æ‹·è´ä¼ è¾“**

```rust
// ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯å‡å°‘å†…å­˜å¤åˆ¶
pub async fn send_segment_zero_copy(
    stream: &mut SendStream,
    segment: &VideoSegment,
) -> Result<(), StreamError> {
    stream.write_all_vectored(&[
        IoSlice::new(&segment.header_bytes()),
        IoSlice::new(&segment.data),
    ]).await?;
    Ok(())
}
```

##### 3.2.2.8 å‰ç«¯MSEæ’­æ”¾å™¨

**æ ¸å¿ƒç»„ä»¶**ï¼š

```typescript
class UnifiedMSEPlayer {
  private mediaSource: MediaSource
  private sourceBuffer: SourceBuffer
  private mode: 'live' | 'playback'
  private targetBuffer: number  // ç›®æ ‡ç¼“å†²ï¼ˆç§’ï¼‰
  
  constructor(sessionId: string, mode: 'live' | 'playback') {
    this.mode = mode
    // æ ¹æ®æ¨¡å¼é…ç½®ç¼“å†²ç­–ç•¥
    this.targetBuffer = mode === 'live' ? 0.5 : 2.0
    this.initMediaSource()
  }
  
  private initMediaSource() {
    this.mediaSource = new MediaSource()
    this.video.src = URL.createObjectURL(this.mediaSource)
    
    this.mediaSource.addEventListener('sourceopen', () => {
      this.sourceBuffer = this.mediaSource.addSourceBuffer(
        'video/mp4; codecs="avc1.64001f"'
      )
      
      // ä½å»¶è¿Ÿæ¨¡å¼é…ç½®
      if (this.mode === 'live') {
        this.sourceBuffer.mode = 'sequence'
      }
      
      this.startReceivingSegments()
    })
  }
  
  private startReceivingSegments() {
    const eventSource = new EventSource(
      `/api/v1/stream/${this.sessionId}/segments`
    )
    
    eventSource.addEventListener('segment', (event) => {
      const segment = JSON.parse(event.data)
      const data = this.base64ToUint8Array(segment.data)
      
      // ç«‹å³è¿½åŠ åˆ°SourceBuffer
      if (!this.sourceBuffer.updating) {
        this.sourceBuffer.appendBuffer(data)
      } else {
        this.segmentQueue.push(data)
      }
      
      // æ™ºèƒ½ç¼“å†²ç®¡ç†
      this.manageBuffer()
    })
  }
  
  private manageBuffer() {
    const currentTime = this.video.currentTime
    const buffered = this.sourceBuffer.buffered
    
    if (buffered.length > 0) {
      const bufferedEnd = buffered.end(0)
      const bufferedAmount = bufferedEnd - currentTime
      
      // ç§»é™¤è¿‡å¤šçš„ç¼“å†²ï¼ˆä¿æŒä½å»¶è¿Ÿï¼‰
      if (bufferedAmount > this.targetBuffer + 1.0) {
        const removeEnd = bufferedEnd - this.targetBuffer
        this.sourceBuffer.remove(0, removeEnd)
      }
    }
  }
}
```

##### 3.2.2.9 ç»Ÿä¸€æ–¹æ¡ˆä¼˜åŠ¿

**æ¶æ„ä¼˜åŠ¿**ï¼š
1. âœ… **ä»£ç å¤ç”¨**: ç›´é€šå’Œå›æ”¾å…±äº«80%ä»¥ä¸Šä»£ç 
2. âœ… **ä¸€è‡´ä½“éªŒ**: ç”¨æˆ·åœ¨ä¸¤ç§æ¨¡å¼é—´åˆ‡æ¢æ— æ„ŸçŸ¥
3. âœ… **æ˜“äºç»´æŠ¤**: å•ä¸€æ’­æ”¾å™¨ï¼Œé™ä½ç»´æŠ¤æˆæœ¬
4. âœ… **æ˜“äºæ‰©å±•**: æœªæ¥åŠŸèƒ½ï¼ˆå¤šéŸ³è½¨ã€å­—å¹•ï¼‰æ›´å®¹æ˜“å®ç°

**æ€§èƒ½ä¼˜åŠ¿**ï¼š
1. âœ… **æä½å»¶è¿Ÿ**: å½•åƒå›æ”¾ä»2ç§’é™åˆ°200msï¼ˆ10å€æå‡ï¼‰
2. âœ… **é›¶ç¼“å†²è½¬å‘**: å¹³å°ç«¯å¤„ç†å»¶è¿Ÿ<5ms
3. âœ… **é«˜å¹¶å‘**: æ”¯æŒ100+å¹¶å‘æµä¼šè¯
4. âœ… **ä½èµ„æºå ç”¨**: å•æµCPU<5%ï¼Œå†…å­˜<50MB

**ç”¨æˆ·ä½“éªŒä¼˜åŠ¿**ï¼š
1. âœ… **å¿«é€Ÿå¯åŠ¨**: æœ€å°ç¼“å†²ï¼Œå¿«é€Ÿå¼€å§‹æ’­æ”¾
2. âœ… **æµç•…æ’­æ”¾**: æ™ºèƒ½ç¼“å†²ç­–ç•¥ï¼Œé¿å…å¡é¡¿
3. âœ… **ç²¾ç¡®æ§åˆ¶**: æ”¯æŒæš‚åœã€å®šä½ã€å€é€Ÿç­‰å®Œæ•´æ§åˆ¶
4. âœ… **å®æ—¶åé¦ˆ**: å»¶è¿Ÿç›‘æ§å’Œæ€§èƒ½ç»Ÿè®¡

### 3.3 ä¿¡ä»¤ä¼ è¾“åè®®è®¾è®¡

#### 3.3.1 è®¾å¤‡ç«¯ â†” å¹³å°ç«¯ä¿¡ä»¤ (QUIC)

**åè®®è¯´æ˜**ï¼šè®¾å¤‡ç«¯ä¸å¹³å°ç«¯ä¹‹é—´ä½¿ç”¨QUICåè®®è¿›è¡Œä¿¡ä»¤é€šä¿¡ï¼ŒåŸºäºè®¾å¤‡ç«¯å®é™…ä»£ç å®ç°ã€‚

##### 3.3.1.1 åŸºç¡€æ¶ˆæ¯æ ¼å¼

æ‰€æœ‰ä¿¡ä»¤æ¶ˆæ¯é‡‡ç”¨JSONåºåˆ—åŒ–ï¼Œé€šè¿‡QUICå•å‘æµä¼ è¾“ï¼š

```rust
// åè®®æ¶ˆæ¯ç»“æ„ï¼ˆæ¥è‡ªè®¾å¤‡ç«¯ä»£ç ï¼‰
pub struct ProtocolMessage {
    pub message_type: MessageType,
    pub payload: Vec<u8>,
    pub sequence_number: u64,
    pub timestamp: SystemTime,
    pub session_id: Uuid,
}
```

**JSONæ ¼å¼ç¤ºä¾‹**ï¼š
```json
{
  "message_type": "SessionStart",
  "payload": [base64ç¼–ç çš„å­—èŠ‚æ•°ç»„],
  "sequence_number": 1,
  "timestamp": "2025-12-11T01:16:25Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

##### 3.3.1.2 æ¶ˆæ¯ç±»å‹å®šä¹‰

æ ¹æ®è®¾å¤‡ç«¯ä»£ç å®ç°ï¼Œæ”¯æŒä»¥ä¸‹æ¶ˆæ¯ç±»å‹ï¼š

```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub enum MessageType {
    // ä¼šè¯ç®¡ç†
    SessionStart = 0x01,           // ä¼šè¯å¼€å§‹
    SessionEnd = 0x02,             // ä¼šè¯ç»“æŸ
    StatusResponse = 0x09,         // çŠ¶æ€å“åº”
    ErrorReport = 0x07,            // é”™è¯¯æŠ¥å‘Š
    
    // æ–‡ä»¶ç®¡ç†
    FileListQuery = 0x0D,          // æ–‡ä»¶åˆ—è¡¨æŸ¥è¯¢
    FileListResponse = 0x0E,       // æ–‡ä»¶åˆ—è¡¨å“åº”
    FileRequest = 0x0B,            // æ–‡ä»¶è¯·æ±‚
    
    // æ’­æ”¾æ§åˆ¶
    PlaybackControl = 0x0C,        // æ’­æ”¾æ§åˆ¶ï¼ˆç»Ÿä¸€æ§åˆ¶å‘½ä»¤ï¼‰
    SeekRequest = 0x03,            // å®šä½è¯·æ±‚ï¼ˆç‹¬ç«‹ï¼‰
    RateChange = 0x04,             // æ’­æ”¾é€Ÿç‡å˜æ›´ï¼ˆç‹¬ç«‹ï¼‰
    PauseRequest = 0x05,           // æš‚åœè¯·æ±‚ï¼ˆç‹¬ç«‹ï¼‰
    ResumeRequest = 0x06,          // æ¢å¤è¯·æ±‚ï¼ˆç‹¬ç«‹ï¼‰
    
    // ç»Ÿè®¡ç›‘æ§
    StatsRequest = 0x08,           // ç»Ÿè®¡è¯·æ±‚
}
```

**è¯´æ˜**ï¼š
- âŒ å·²ç§»é™¤ `VersionNegotiation = 0x0A`ï¼ˆç‰ˆæœ¬åå•†ï¼‰
- âœ… ä¿ç•™æ‰€æœ‰å®é™…ä½¿ç”¨çš„æ¶ˆæ¯ç±»å‹
- âœ… æ’­æ”¾æ§åˆ¶æ”¯æŒç»Ÿä¸€çš„ `PlaybackControl` å’Œç‹¬ç«‹çš„æ§åˆ¶å‘½ä»¤

##### 3.3.1.3 ä¼šè¯ç®¡ç†æ¶ˆæ¯

**SessionStart - ä¼šè¯å¼€å§‹**

è®¾å¤‡ç«¯è¿æ¥åˆ°å¹³å°ç«¯æ—¶å‘é€ï¼Œå»ºç«‹QUICè¿æ¥ï¼š

```json
// è®¾å¤‡ç«¯ â†’ å¹³å°ç«¯
{
  "message_type": "SessionStart",
  "payload": [],  // ç©ºè½½è·æˆ–åŒ…å«è®¾å¤‡åŸºæœ¬ä¿¡æ¯
  "sequence_number": 1,
  "timestamp": "2025-12-11T01:16:25Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯ï¼ˆå“åº”ï¼‰
{
  "message_type": "StatusResponse",
  "payload": [200, 0],  // çŠ¶æ€ç 200è¡¨ç¤ºæˆåŠŸ
  "sequence_number": 2,
  "timestamp": "2025-12-11T01:16:26Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**SessionEnd - ä¼šè¯ç»“æŸ**

æ–­å¼€è¿æ¥å‰å‘é€ï¼Œä¼˜é›…å…³é—­ä¼šè¯ï¼š

```json
// è®¾å¤‡ç«¯ â†’ å¹³å°ç«¯ æˆ– å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "SessionEnd",
  "payload": [],  // ç©ºè½½è·
  "sequence_number": 999,
  "timestamp": "2025-12-11T01:20:30Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**StatusResponse - çŠ¶æ€å“åº”**

é€šç”¨çš„çŠ¶æ€å“åº”æ¶ˆæ¯ï¼Œç”¨äºç¡®è®¤æ“ä½œç»“æœï¼š

```json
{
  "message_type": "StatusResponse",
  "payload": [200, 0],  // çŠ¶æ€ç å­—èŠ‚æ•°ç»„
  "sequence_number": 3,
  "timestamp": "2025-12-11T01:16:28Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**çŠ¶æ€ç å®šä¹‰**ï¼ˆæ¥è‡ªè®¾å¤‡ç«¯ä»£ç ï¼‰ï¼š
```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub enum StatusCode {
    Success = 200,
    BadRequest = 400,
    Unauthorized = 401,
    NotFound = 404,
    InternalError = 500,
    ServiceUnavailable = 503,
    UnsupportedFormat = 1001,
    InsufficientBandwidth = 1002,
    StorageFull = 1003,
    AuthenticationFailed = 1004,
    SegmentCorrupted = 1005,
}
```

##### 3.3.1.4 æ–‡ä»¶ç®¡ç†æ¶ˆæ¯

**FileListQuery - æŸ¥è¯¢æ–‡ä»¶åˆ—è¡¨**
```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "FileListQuery",
  "payload": "eyJmaWx0ZXIiOiAibXA0In0=",  // {"filter": "mp4"}
  "sequence_number": 6,
  "timestamp": "2025-12-11T01:16:35Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è½½è·æ ¼å¼ï¼š
{
  "filter": "å¯é€‰çš„æ–‡ä»¶è¿‡æ»¤å™¨å­—ç¬¦ä¸²ï¼Œæ”¯æŒæ ¼å¼åæˆ–è·¯å¾„åŒ¹é…"
}
```

**FileListResponse - æ–‡ä»¶åˆ—è¡¨å“åº”**
```json
// è®¾å¤‡ç«¯ â†’ å¹³å°ç«¯
{
  "message_type": "FileListResponse",
  "payload": "Base64ç¼–ç çš„æ–‡ä»¶åˆ—è¡¨",
  "sequence_number": 7,
  "timestamp": "2025-12-11T01:16:36Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è½½è·æ ¼å¼ï¼š
{
  "files": [
    {
      "file_path": "recordings/device_001/2025/12/11/video_20251211_010000.h264",
      "file_size": 1048576000,
      "duration": 3600.0,
      "format": "h264",
      "available": true,
      "resolution": {
        "width": 1920,
        "height": 1080
      },
      "codec": {
        "video": "H.264",
        "audio": "AAC"
      },
      "frame_rate": 30.0,
      "bit_rate": 5000000,
      "created_time": "2025-12-11T01:00:00Z"
    }
  ]
}
```

**FileRequest - è¯·æ±‚æ–‡ä»¶ä¸Šä¼ **
```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "FileRequest",
  "payload": "Base64ç¼–ç çš„æ–‡ä»¶è¯·æ±‚",
  "sequence_number": 8,
  "timestamp": "2025-12-11T01:16:40Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è½½è·æ ¼å¼ï¼š
{
  "file_path": "recordings/device_001/2025/12/11/video_20251211_010000.h264",
  "priority": 1,                    // 1-255ï¼Œæ•°å€¼è¶Šé«˜ä¼˜å…ˆçº§è¶Šé«˜
  "seek_position": 0.0,             // å¯é€‰ï¼Œä»æŒ‡å®šä½ç½®å¼€å§‹
  "playback_rate": 1.0,             // æ’­æ”¾å€é€Ÿï¼Œ0.25-4.0
  "quality_preference": "low_latency", // "low_latency" | "high_quality" | "balanced"
  "segment_mode": "frame",          // "frame" | "gop" | "time" | "auto"
  "max_bandwidth": 10000000,        // å¯é€‰ï¼Œæœ€å¤§å¸¦å®½é™åˆ¶(bps)
  "resume_from_segment": null       // å¯é€‰ï¼Œæ–­ç‚¹ç»­ä¼ çš„åˆ†ç‰‡ID
}
```

##### 3.3.1.5 æ’­æ”¾æ§åˆ¶æ¶ˆæ¯

è®¾å¤‡ç«¯å®ç°äº†å®Œæ•´çš„æ’­æ”¾æ§åˆ¶åŠŸèƒ½ï¼Œæ”¯æŒSEEKã€å€é€Ÿã€æš‚åœ/æ¢å¤ç­‰æ“ä½œã€‚

**SeekRequest - å®šä½è¯·æ±‚**

åŸºäºè®¾å¤‡ç«¯çš„å…³é”®å¸§ç´¢å¼•å®ç°ç²¾ç¡®å®šä½ï¼š

```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "SeekRequest",
  "payload": [/* åºåˆ—åŒ–çš„å®šä½å‚æ•° */],
  "sequence_number": 9,
  "timestamp": "2025-12-11T01:17:00Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è½½è·æ ¼å¼ï¼ˆJSONï¼‰ï¼š
{
  "position": 45.5,              // ç›®æ ‡æ—¶é—´ä½ç½®ï¼ˆç§’ï¼‰
  "accurate": true               // æ˜¯å¦ç²¾ç¡®å®šä½åˆ°å…³é”®å¸§
}

// è®¾å¤‡ç«¯å“åº”
{
  "message_type": "StatusResponse",
  "payload": [/* SeekResultåºåˆ—åŒ– */],
  "sequence_number": 10,
  "timestamp": "2025-12-11T01:17:01Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// SeekResultæ ¼å¼ï¼ˆæ¥è‡ªè®¾å¤‡ç«¯ä»£ç ï¼‰ï¼š
{
  "requested_time": 45.5,
  "actual_time": 45.2,           // å®é™…å®šä½åˆ°çš„å…³é”®å¸§æ—¶é—´
  "keyframe_offset": 1024000,    // æ–‡ä»¶åç§»é‡
  "precision_achieved": 0.993,   // å®šä½ç²¾åº¦ï¼ˆ0-1ï¼‰
  "execution_time_ms": 15        // æ‰§è¡Œè€—æ—¶
}
```

**RateChange - æ’­æ”¾é€Ÿç‡å˜æ›´**

æ”¯æŒ0.25xåˆ°10xçš„å€é€Ÿæ’­æ”¾ï¼Œè®¾å¤‡ç«¯ä¼šæ ¹æ®å€é€Ÿè‡ªåŠ¨è°ƒæ•´å¸§ä¸¢å¼ƒç­–ç•¥ï¼š

```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "RateChange",
  "payload": [/* é€Ÿç‡å‚æ•° */],
  "sequence_number": 11,
  "timestamp": "2025-12-11T01:17:30Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è½½è·æ ¼å¼ï¼š
{
  "rate": 2.0                    // æ’­æ”¾å€é€Ÿï¼Œæ”¯æŒ0.25-10.0
}

// è®¾å¤‡ç«¯å¸§ä¸¢å¼ƒç­–ç•¥ï¼ˆæ¥è‡ªè®¾å¤‡ç«¯ä»£ç ï¼‰ï¼š
// rate <= 1.0: ä¸ä¸¢å¸§
// rate <= 2.0: ä¸¢å¼ƒBå¸§
// rate <= 4.0: ä¸¢å¼ƒBå¸§å’ŒPå¸§
// rate > 4.0:  ä»…ä¿ç•™å…³é”®å¸§
```

**PauseRequest - æš‚åœè¯·æ±‚**

```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "PauseRequest",
  "payload": [],
  "sequence_number": 12,
  "timestamp": "2025-12-11T01:18:00Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è®¾å¤‡ç«¯å“åº”
{
  "message_type": "StatusResponse",
  "payload": [200, 0],
  "sequence_number": 13,
  "timestamp": "2025-12-11T01:18:01Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**ResumeRequest - æ¢å¤è¯·æ±‚**

```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "ResumeRequest",
  "payload": [],
  "sequence_number": 14,
  "timestamp": "2025-12-11T01:18:30Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è®¾å¤‡ç«¯å“åº”
{
  "message_type": "StatusResponse",
  "payload": [200, 0],
  "sequence_number": 15,
  "timestamp": "2025-12-11T01:18:31Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**PlaybackControl - ç»Ÿä¸€æ’­æ”¾æ§åˆ¶**

é™¤äº†ç‹¬ç«‹çš„æ§åˆ¶æ¶ˆæ¯ï¼Œè®¾å¤‡ç«¯è¿˜æ”¯æŒç»Ÿä¸€çš„PlaybackControlæ¶ˆæ¯ï¼š

```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "PlaybackControl",
  "payload": [/* æ§åˆ¶å‘½ä»¤åºåˆ—åŒ– */],
  "sequence_number": 16,
  "timestamp": "2025-12-11T01:19:00Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è½½è·å¯ä»¥åŒ…å«ä»»æ„æ§åˆ¶å‘½ä»¤çš„ç»„åˆ
```

##### 3.3.1.6 é”™è¯¯å¤„ç†æ¶ˆæ¯

**ErrorReport - é”™è¯¯æŠ¥å‘Š**
```json
// è®¾å¤‡ç«¯ â†’ å¹³å°ç«¯ æˆ– å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "ErrorReport",
  "payload": "Base64ç¼–ç çš„é”™è¯¯ä¿¡æ¯",
  "sequence_number": 100,
  "timestamp": "2025-12-11T01:18:00Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è½½è·æ ¼å¼ï¼š
{
  "error_code": 1001,
  "error_message": "Unsupported file format: .avi",
  "error_type": "UnsupportedFormat",
  "retry_after": 5000,  // å¯é€‰ï¼Œæ¯«ç§’
  "max_retries": 3,     // å¯é€‰ï¼Œæœ€å¤§é‡è¯•æ¬¡æ•°
  "details": {
    "file_path": "test.avi",
    "supported_formats": ["mp4", "h264"]
  },
  "context": {
    "session_id": "550e8400-e29b-41d4-a716-446655440000",
    "device_id": "device_001",
    "timestamp": 1702259825000
  }
}
```

##### 3.3.1.7 ç»Ÿè®¡ç›‘æ§æ¶ˆæ¯

**StatsRequest - ç»Ÿè®¡è¯·æ±‚**
```json
// å¹³å°ç«¯ â†’ è®¾å¤‡ç«¯
{
  "message_type": "StatsRequest",
  "payload": "eyJ0eXBlIjogInBlcmZvcm1hbmNlIn0=",  // {"type": "performance"}
  "sequence_number": 101,
  "timestamp": "2025-12-11T01:18:30Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// è®¾å¤‡ç«¯ â†’ å¹³å°ç«¯ï¼ˆå“åº”ï¼‰
{
  "message_type": "StatusResponse",
  "payload": "Base64ç¼–ç çš„ç»Ÿè®¡æ•°æ®",
  "sequence_number": 102,
  "timestamp": "2025-12-11T01:18:31Z",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}

// ç»Ÿè®¡æ•°æ®è½½è·æ ¼å¼ï¼š
{
  "transmission_stats": {
    "total_segments": 150,
    "total_bytes": 1048576000,
    "transmission_duration_ms": 890,
    "average_segment_time_ms": 5.93,
    "overall_throughput_mbps": 9.4,
    "peak_throughput_mbps": 109.2
  },
  "device_stats": {
    "cpu_usage": 25.5,
    "memory_usage": 128.5,
    "network_usage_mbps": 8.5,
    "temperature": 45.2
  },
  "network_stats": {
    "rtt_ms": 15,
    "packet_loss_rate": 0.01,
    "bandwidth_mbps": 10.0,
    "jitter_ms": 2.5
  }
}
```

##### 3.3.1.8 è®¾å¤‡ç«¯æ ¸å¿ƒèƒ½åŠ›

åŸºäºè®¾å¤‡ç«¯ä»£ç å®ç°ï¼Œè®¾å¤‡ç«¯å…·å¤‡ä»¥ä¸‹æ ¸å¿ƒèƒ½åŠ›ï¼š

**1. å…³é”®å¸§ç´¢å¼•ç®¡ç†**
```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub struct KeyframeIndex {
    pub entries: Vec<KeyframeEntry>,
    pub total_duration: f64,
    pub index_precision: f64,        // æ”¯æŒäºšç§’çº§ç²¾åº¦
    pub memory_optimized: bool,
    pub optimization_strategy: IndexOptimizationStrategy,
}

// ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
pub enum IndexOptimizationStrategy {
    Full,           // å®Œæ•´ç´¢å¼•ï¼Œæ‰€æœ‰å…³é”®å¸§
    Sparse,         // ç¨€ç–ç´¢å¼•ï¼Œå®šæœŸé‡‡æ ·
    Adaptive,       // è‡ªé€‚åº”ï¼Œæ ¹æ®å†…å­˜åŠ¨æ€è°ƒæ•´
    Hierarchical,   // åˆ†å±‚ç´¢å¼•ï¼Œå¤šçº§ç²¾åº¦
}
```

**2. æ’­æ”¾æ§åˆ¶å™¨**
```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/controller.rs
pub trait PlaybackController {
    async fn seek(&mut self, position: f64) -> Result<(), PlaybackError>;
    async fn seek_to_keyframe(&mut self, position: f64, index: &KeyframeIndex) 
        -> Result<SeekResult, PlaybackError>;
    async fn set_playback_rate(&mut self, rate: f64) -> Result<(), PlaybackError>;
    fn get_drop_frame_strategy(&self, rate: f64) -> DropFrameStrategy;
    fn adjust_transmission_queue(&self, segments: Vec<VideoSegment>, playback_rate: f64) 
        -> Vec<VideoSegment>;
}
```

**3. ç½‘ç»œæ¡ä»¶ç›‘æ§**
```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub struct NetworkConditions {
    pub bandwidth_estimate: u64,
    pub rtt: Duration,
    pub packet_loss_rate: f64,
    pub jitter: Duration,
    pub congestion_level: CongestionLevel,
}

pub enum CongestionLevel {
    Low,        // < 1% ä¸¢åŒ…ç‡
    Medium,     // 1-2% ä¸¢åŒ…ç‡
    High,       // 2-5% ä¸¢åŒ…ç‡
    Critical,   // > 5% ä¸¢åŒ…ç‡
}
```

**4. è¿æ¥æ¢å¤æœºåˆ¶**
```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub struct RecoveryState {
    pub last_successful_segment: Option<Uuid>,
    pub retry_count: u32,
    pub max_retries: u32,
    pub backoff_duration: Duration,
    pub recovery_strategy: RecoveryStrategy,
}

pub enum RecoveryStrategy {
    Immediate,           // ç«‹å³é‡è¯•
    ExponentialBackoff,  // æŒ‡æ•°é€€é¿
    LinearBackoff,       // çº¿æ€§é€€é¿
    AdaptiveBackoff,     // è‡ªé€‚åº”é€€é¿
}
```

##### 3.3.1.9 ä¿¡ä»¤äº¤äº’æµç¨‹

```mermaid
sequenceDiagram
    participant P as å¹³å°ç«¯
    participant D as è®¾å¤‡ç«¯
    
    Note over P,D: 1. è¿æ¥å»ºç«‹
    D->>P: QUICè¿æ¥è¯·æ±‚
    P->>D: è¿æ¥ç¡®è®¤
    D->>P: SessionStart
    P->>D: StatusResponse (200 OK)
    
    Note over P,D: 2. æ–‡ä»¶å‘ç°
    P->>D: FileListQuery (filter: "h264")
    D->>P: FileListResponse (æ–‡ä»¶åˆ—è¡¨)
    
    Note over P,D: 3. è¯·æ±‚æ–‡ä»¶ä¸Šä¼ 
    P->>D: FileRequest (file_path, options)
    D->>P: StatusResponse (å‡†å¤‡å°±ç»ª)
    D->>D: æ„å»ºå…³é”®å¸§ç´¢å¼•
    
    Note over P,D: 4. è§†é¢‘åˆ†ç‰‡ä¼ è¾“ï¼ˆåª’ä½“æµï¼‰
    loop æ¯ä¸ªè§†é¢‘åˆ†ç‰‡
        D->>P: VideoSegment (åˆ†ç‰‡æ•°æ®)
    end
    
    Note over P,D: 5. æ’­æ”¾æ§åˆ¶ - SEEK
    P->>D: SeekRequest (position: 30.0s)
    D->>D: æŸ¥æ‰¾å…³é”®å¸§ç´¢å¼•
    D->>D: å®šä½åˆ°æ–‡ä»¶ä½ç½®
    D->>P: StatusResponse (SeekResult)
    
    Note over P,D: 6. æ’­æ”¾æ§åˆ¶ - å€é€Ÿ
    P->>D: RateChange (rate: 2.0)
    D->>D: åº”ç”¨å¸§ä¸¢å¼ƒç­–ç•¥
    D->>P: StatusResponse (200 OK)
    
    Note over P,D: 7. æ’­æ”¾æ§åˆ¶ - æš‚åœ/æ¢å¤
    P->>D: PauseRequest
    D->>P: StatusResponse (200 OK)
    P->>D: ResumeRequest
    D->>P: StatusResponse (200 OK)
    
    Note over P,D: 8. æ€§èƒ½ç»Ÿè®¡
    P->>D: StatsRequest
    D->>P: StatusResponse (æ€§èƒ½æ•°æ®)
    
    Note over P,D: 9. ä¼šè¯ç»“æŸ
    P->>D: SessionEnd
    D->>P: StatusResponse (200 OK)
    D->>P: å…³é—­QUICè¿æ¥
```

#### 3.3.2 å¹³å°ç«¯ â†” Webå‰ç«¯ä¿¡ä»¤ (HTTP3)

**åè®®è¯´æ˜**ï¼šå¹³å°ç«¯ä¸Webå‰ç«¯ä¹‹é—´ä½¿ç”¨HTTP3åè®®è¿›è¡Œä¿¡ä»¤é€šä¿¡ï¼Œé‡‡ç”¨RESTful API + WebSocketçš„æ··åˆæ¶æ„ã€‚

**è®¾è®¡åŸåˆ™**ï¼š
- RESTful APIï¼šç”¨äºè¯·æ±‚-å“åº”æ¨¡å¼çš„æ“ä½œï¼ˆè®¾å¤‡æŸ¥è¯¢ã€å½•åƒæŸ¥è¯¢ã€æ’­æ”¾å¯åŠ¨ç­‰ï¼‰
- WebSocketï¼šç”¨äºå®æ—¶äº‹ä»¶æ¨é€ï¼ˆåˆ†ç‰‡åˆ°è¾¾ã€çŠ¶æ€å˜åŒ–ã€æ€§èƒ½ç›‘æ§ç­‰ï¼‰
- ä¸è®¾å¤‡ç«¯ä¿¡ä»¤ä¿æŒä¸€è‡´çš„è¯­ä¹‰å’Œæµç¨‹

##### 3.3.2.1 è®¾å¤‡ç®¡ç†API

**æŸ¥è¯¢æ‰€æœ‰è¿æ¥è®¾å¤‡**

```http
GET /api/v1/devices HTTP/3

Response:
{
  "devices": [
    {
      "device_id": "device_001",
      "device_name": "æ‘„åƒå¤´-01",
      "device_type": "camera",
      "connection_status": "online",
      "last_seen": "2025-12-11T01:30:25Z",
      "capabilities": {
        "max_resolution": "1920x1080",
        "supported_formats": ["h264", "mp4"],
        "max_bitrate": 10000000
      },
      "current_sessions": [
        {
          "session_id": "550e8400-e29b-41d4-a716-446655440000",
          "stream_type": "live",
          "start_time": "2025-12-11T01:25:00Z",
          "client_count": 3
        }
      ],
      "network_stats": {
        "latency_ms": 15,
        "packet_loss_rate": 0.01,
        "bandwidth_mbps": 8.5
      }
    }
  ],
  "total_count": 1,
  "online_count": 1
}

# æŸ¥è¯¢ç‰¹å®šè®¾å¤‡è¯¦æƒ…
GET /api/v1/devices/{device_id} HTTP/3
Authorization: Bearer {jwt_token}

Response:
{
  "device_id": "device_001",
  "device_name": "æ‘„åƒå¤´-01",
  "device_type": "camera",
  "connection_status": "online",
  "connection_time": "2025-12-11T01:20:00Z",
  "last_heartbeat": "2025-12-11T01:30:20Z",
  "hardware_info": {
    "model": "SimulatedCamera",
    "firmware_version": "1.0.0",
    "serial_number": "SIM001"
  },
  "capabilities": {
    "max_resolution": "1920x1080",
    "supported_formats": ["h264", "mp4"],
    "max_bitrate": 10000000,
    "supports_playback_control": true,
    "supports_recording": true
  },
  "current_performance": {
    "cpu_usage": 25.5,
    "memory_usage": 128.5,
    "network_usage_mbps": 8.5,
    "temperature": 45.2
  }
}

# è®¾å¤‡æ§åˆ¶å‘½ä»¤
POST /api/v1/devices/{device_id}/control HTTP/3
Content-Type: application/json
Authorization: Bearer {jwt_token}

{
  "command": "reboot",
  "parameters": {},
  "client_id": "web_client_001",
  "timestamp": 1702259825000
}
```

##### 3.3.2.2 å½•åƒæ–‡ä»¶ç®¡ç†API

```http
# æŸ¥è¯¢è®¾å¤‡å½•åƒæ–‡ä»¶åˆ—è¡¨
GET /api/v1/devices/{device_id}/recordings HTTP/3
Authorization: Bearer {jwt_token}
Query Parameters:
  - start_time: 2025-12-10T00:00:00Z
  - end_time: 2025-12-11T23:59:59Z
  - page: 1
  - page_size: 20
  - format: h264,mp4

Response:
{
  "recordings": [
    {
      "file_id": "rec_001",
      "file_name": "video_20251211_013000.h264",
      "file_path": "recordings/device_001/2025/12/11/video_20251211_013000.h264",
      "file_size": 1048576000,
      "duration": 3600.0,
      "format": "h264",
      "resolution": "1920x1080",
      "bitrate": 5000000,
      "frame_rate": 30.0,
      "created_time": "2025-12-11T01:30:00Z",
      "modified_time": "2025-12-11T02:30:00Z",
      "checksum": "sha256:abc123...",
      "thumbnail_url": "/api/v1/recordings/rec_001/thumbnail",
      "preview_url": "/api/v1/recordings/rec_001/preview",
      "download_url": "/api/v1/recordings/rec_001/download",
      "stream_url": "/api/v1/recordings/rec_001/stream",
      "metadata": {
        "codec": "H.264",
        "profile": "High",
        "level": "4.1",
        "has_audio": true,
        "audio_codec": "AAC"
      }
    }
  ],
  "pagination": {
    "current_page": 1,
    "page_size": 20,
    "total_count": 150,
    "total_pages": 8
  },
  "summary": {
    "total_files": 150,
    "total_size_gb": 156.8,
    "total_duration_hours": 450.5,
    "date_range": {
      "earliest": "2025-12-01T00:00:00Z",
      "latest": "2025-12-11T02:30:00Z"
    }
  }
}

```

**è¯´æ˜**ï¼š
- å½•åƒæ–‡ä»¶åˆ—è¡¨åŒ…å«å®Œæ•´çš„æ–‡ä»¶ä¿¡æ¯ï¼Œæ— éœ€å•ç‹¬çš„è¯¦æƒ…æ¥å£
- Demoç‰ˆæœ¬ä¸æ”¯æŒåˆ é™¤å½•åƒåŠŸèƒ½ï¼Œç®€åŒ–å®ç°

##### 3.3.2.3 ç›´é€šæ’­æ”¾API

**å‰ç½®æ¡ä»¶**ï¼šéœ€è¦å…ˆé€šè¿‡è®¾å¤‡ç®¡ç†APIæŸ¥è¯¢åˆ°åœ¨çº¿è®¾å¤‡

```http
# å¼€å§‹ç›´é€šæ’­æ”¾
POST /api/v1/devices/{device_id}/live-stream HTTP/3
Content-Type: application/json

{
  "client_id": "web_client_001",
  "quality_preference": "auto",
  "buffer_size": 30,
  "low_latency_mode": true,
  "audio_enabled": true,
  "timestamp": 1702259825000
}

Response:
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "stream_url": "/api/v1/stream/550e8400-e29b-41d4-a716-446655440000/segments",
  "control_url": "/api/v1/playback/550e8400-e29b-41d4-a716-446655440000/control",
  "status_url": "/api/v1/stream/550e8400-e29b-41d4-a716-446655440000/status",
  "websocket_url": "wss://platform-server:8443/api/v1/stream/550e8400-e29b-41d4-a716-446655440000/events",
  "estimated_latency_ms": 85,
  "stream_info": {
    "resolution": "1920x1080",
    "frame_rate": 30.0,
    "bitrate": 5000000,
    "format": "h264"
  }
}

# åœæ­¢ç›´é€šæ’­æ”¾
DELETE /api/v1/stream/{session_id} HTTP/3

{
  "client_id": "web_client_001",
  "reason": "user_stop",
  "timestamp": 1702259825000
}
```

##### 3.3.2.4 å›æ”¾æ§åˆ¶API

**å‰ç½®æ¡ä»¶**ï¼šéœ€è¦å…ˆé€šè¿‡å½•åƒæ–‡ä»¶ç®¡ç†APIæŸ¥è¯¢åˆ°å½•åƒæ–‡ä»¶åˆ—è¡¨ï¼Œè·å–file_id

```http
# å¼€å§‹å½•åƒå›æ”¾
POST /api/v1/recordings/{file_id}/playback HTTP/3
Content-Type: application/json

{
  "client_id": "web_client_001",
  "start_position": 0.0,
  "quality": "high",
  "playback_rate": 1.0,
  "audio_enabled": true,
  "timestamp": 1702259825000
}

Response:
{
  "session_id": "550e8400-e29b-41d4-a716-446655440001",
  "playback_url": "/api/v1/playback/550e8400-e29b-41d4-a716-446655440001/segments",
  "control_url": "/api/v1/playback/550e8400-e29b-41d4-a716-446655440001/control",
  "status_url": "/api/v1/playback/550e8400-e29b-41d4-a716-446655440001/status",
  "websocket_url": "wss://platform-server:8443/api/v1/playback/550e8400-e29b-41d4-a716-446655440001/events",
  "file_info": {
    "duration": 3600.0,
    "resolution": "1280x720",
    "frame_rate": 30.0,
    "bitrate": 3000000
  }
}

# å›æ”¾æ’­æ”¾æ§åˆ¶ï¼ˆæ’­æ”¾ã€æš‚åœã€æ¢å¤ã€æ‹–åŠ¨ã€å¿«è¿›ã€åœæ­¢ï¼‰
POST /api/v1/playback/{session_id}/control HTTP/3
Content-Type: application/json

# æ’­æ”¾
{
  "command": "play",
  "client_id": "web_client_001",
  "timestamp": 1702259825000
}

# æš‚åœ
{
  "command": "pause",
  "client_id": "web_client_001",
  "timestamp": 1702259825000
}

# æ¢å¤æ’­æ”¾
{
  "command": "resume",
  "client_id": "web_client_001",
  "timestamp": 1702259825000
}

# æ‹–åŠ¨å®šä½
{
  "command": "seek",
  "position": 1800.0,
  "accurate": true,
  "client_id": "web_client_001",
  "timestamp": 1702259825000
}

# å¿«è¿›æ§åˆ¶ï¼ˆå€é€Ÿæ’­æ”¾ï¼‰
{
  "command": "set_rate",
  "rate": 2.0,
  "maintain_audio": false,
  "client_id": "web_client_001",
  "timestamp": 1702259825000
}

# åœæ­¢æ’­æ”¾
{
  "command": "stop",
  "reason": "user_request",
  "client_id": "web_client_001",
  "timestamp": 1702259825000
}
```

##### 3.3.2.5 WebSocketå®æ—¶äº‹ä»¶æ¨é€

**åŠŸèƒ½è¯´æ˜**ï¼šWebSocketç”¨äºå¹³å°ç«¯å‘Webå‰ç«¯å®æ—¶æ¨é€äº‹ä»¶é€šçŸ¥ï¼Œå®ç°åŒå‘é€šä¿¡ã€‚å‰ç«¯é€šè¿‡WebSocketæ¥æ”¶å®æ—¶çŠ¶æ€æ›´æ–°ï¼Œæ— éœ€è½®è¯¢ã€‚

**åº”ç”¨åœºæ™¯**ï¼š
- å®æ—¶æ¥æ”¶è§†é¢‘åˆ†ç‰‡åˆ°è¾¾é€šçŸ¥
- ç›‘æ§æ’­æ”¾çŠ¶æ€å˜åŒ–
- æ¥æ”¶è®¾å¤‡è¿æ¥çŠ¶æ€å˜åŒ–
- æ¥æ”¶å»¶è¿Ÿå‘Šè­¦å’Œæ€§èƒ½æŒ‡æ ‡

**è¿æ¥å»ºç«‹**ï¼š

```javascript
// 1. å»ºç«‹WebSocketè¿æ¥ï¼ˆç›´é€šæ’­æ”¾ï¼‰
const liveWs = new WebSocket('wss://platform-server:8443/api/v1/stream/{session_id}/events');

// 2. å»ºç«‹WebSocketè¿æ¥ï¼ˆå½•åƒå›æ”¾ï¼‰
const playbackWs = new WebSocket('wss://platform-server:8443/api/v1/playback/{session_id}/events');

// 3. ç›‘å¬äº‹ä»¶
liveWs.onmessage = (event) => {
    const message = JSON.parse(event.data);
    handleRealtimeEvent(message);
};

// 4. è¿æ¥çŠ¶æ€ç®¡ç†
liveWs.onopen = () => {
    console.log('WebSocketè¿æ¥å·²å»ºç«‹');
};

liveWs.onerror = (error) => {
    console.error('WebSocketé”™è¯¯:', error);
};

liveWs.onclose = () => {
    console.log('WebSocketè¿æ¥å·²å…³é—­');
    // å®ç°é‡è¿é€»è¾‘
};
```

**äº‹ä»¶ç±»å‹å®šä¹‰**ï¼š

```javascript
// äº‹ä»¶1: è§†é¢‘åˆ†ç‰‡æ¥æ”¶é€šçŸ¥
// ç”¨é€”: å®æ—¶æ˜¾ç¤ºè§†é¢‘ä¼ è¾“è¿›åº¦å’Œæ€§èƒ½
{
  "event_type": "segment_received",
  "data": {
    "segment_id": "550e8400-e29b-41d4-a716-446655440002",
    "timestamp": 15.5,
    "size": 2048,
    "latency_ms": 12,
    "is_keyframe": true,
    "frame_count": 1
  },
  "timestamp": "2025-12-11T01:35:00Z"
}

// äº‹ä»¶2: æ’­æ”¾çŠ¶æ€å˜åŒ–é€šçŸ¥
// ç”¨é€”: åŒæ­¥æ’­æ”¾å™¨çŠ¶æ€ï¼Œæ›´æ–°UIæ˜¾ç¤º
{
  "event_type": "playback_status_changed",
  "data": {
    "status": "playing",  // playing, paused, stopped, seeking, buffering
    "position": 30.5,
    "rate": 1.0,
    "buffer_health": 25.5,
    "buffer_duration": 30.0
  },
  "timestamp": "2025-12-11T01:35:00Z"
}

// äº‹ä»¶3: è®¾å¤‡è¿æ¥çŠ¶æ€å˜åŒ–é€šçŸ¥
// ç”¨é€”: å®æ—¶æ›´æ–°è®¾å¤‡åˆ—è¡¨ï¼Œå¤„ç†è®¾å¤‡ç¦»çº¿æƒ…å†µ
{
  "event_type": "device_status_changed",
  "data": {
    "device_id": "device_001",
    "status": "offline",  // online, offline, reconnecting
    "reason": "network_timeout",
    "last_seen": "2025-12-11T01:34:50Z"
  },
  "timestamp": "2025-12-11T01:35:00Z"
}

// äº‹ä»¶4: å»¶è¿Ÿå‘Šè­¦é€šçŸ¥
// ç”¨é€”: å®æ—¶ç›‘æ§ç³»ç»Ÿæ€§èƒ½ï¼Œè§¦å‘å‘Šè­¦æç¤º
{
  "event_type": "latency_alert",
  "data": {
    "current_latency_ms": 250,
    "threshold_ms": 200,
    "severity": "warning",  // info, warning, error, critical
    "affected_session": "550e8400-e29b-41d4-a716-446655440000"
  },
  "timestamp": "2025-12-11T01:35:00Z"
}

// äº‹ä»¶5: ç¼“å†²åŒºçŠ¶æ€é€šçŸ¥
// ç”¨é€”: ç›‘æ§æ’­æ”¾ç¼“å†²åŒºå¥åº·åº¦ï¼Œä¼˜åŒ–æ’­æ”¾ä½“éªŒ
{
  "event_type": "buffer_status",
  "data": {
    "buffer_duration": 25.5,
    "target_buffer": 30.0,
    "buffer_health": "healthy",  // healthy, low, critical
    "is_buffering": false
  },
  "timestamp": "2025-12-11T01:35:00Z"
}

// äº‹ä»¶6: è´¨é‡åˆ‡æ¢é€šçŸ¥
// ç”¨é€”: é€šçŸ¥å‰ç«¯è§†é¢‘è´¨é‡å·²è‡ªåŠ¨è°ƒæ•´
{
  "event_type": "quality_changed",
  "data": {
    "old_quality": "high",
    "new_quality": "medium",
    "reason": "bandwidth_limitation",
    "new_bitrate": 3000000
  },
  "timestamp": "2025-12-11T01:35:00Z"
}

// äº‹ä»¶7: å½•åƒæ–‡ä»¶å˜åŒ–é€šçŸ¥
// ç”¨é€”: å®æ—¶æ›´æ–°å½•åƒåˆ—è¡¨ï¼ˆæ–°å½•åƒç”Ÿæˆã€å½•åƒåˆ é™¤ï¼‰
{
  "event_type": "recording_changed",
  "data": {
    "action": "created",  // created, deleted, updated
    "file_id": "rec_002",
    "device_id": "device_001",
    "file_name": "video_20251211_020000.h264"
  },
  "timestamp": "2025-12-11T01:35:00Z"
}
```

**WebSocketå¿ƒè·³æœºåˆ¶**ï¼š

```javascript
// å®¢æˆ·ç«¯å‘é€å¿ƒè·³
setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'ping',
            timestamp: Date.now()
        }));
    }
}, 30000); // æ¯30ç§’å‘é€ä¸€æ¬¡å¿ƒè·³

// æœåŠ¡ç«¯å“åº”å¿ƒè·³
{
  "type": "pong",
  "timestamp": "2025-12-11T01:35:00Z",
  "server_time": 1702259825000
}
```

##### 3.3.2.6 ä¿¡ä»¤äº¤äº’æµç¨‹

æœ¬èŠ‚é€šè¿‡æ—¶åºå›¾è¯¦ç»†æè¿°å¹³å°ç«¯ä¸Webå‰ç«¯ä¹‹é—´çš„æ‰€æœ‰ä¿¡ä»¤äº¤äº’åœºæ™¯ã€‚

###### 3.3.2.6.1 è®¾å¤‡å‘ç°å’ŒæŸ¥è¯¢æµç¨‹

```mermaid
sequenceDiagram
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    
    Note over W,P: åœºæ™¯1: é¡µé¢åŠ è½½ï¼ŒæŸ¥è¯¢è®¾å¤‡åˆ—è¡¨
    W->>P: GET /api/v1/devices
    P->>P: æŸ¥è¯¢åœ¨çº¿è®¾å¤‡
    P->>W: è¿”å›è®¾å¤‡åˆ—è¡¨
    Note right of W: æ˜¾ç¤ºè®¾å¤‡åˆ—è¡¨<br/>çŠ¶æ€ï¼šonline/offline
    
    Note over W,P: åœºæ™¯2: æŸ¥è¯¢ç‰¹å®šè®¾å¤‡è¯¦æƒ…
    W->>P: GET /api/v1/devices/device_001
    P->>P: è·å–è®¾å¤‡è¯¦ç»†ä¿¡æ¯
    P->>W: è¿”å›è®¾å¤‡è¯¦æƒ…
    Note right of W: æ˜¾ç¤ºè®¾å¤‡è¯¦ç»†ä¿¡æ¯<br/>æ€§èƒ½æŒ‡æ ‡ã€èƒ½åŠ›ç­‰
    
    Note over W,P: åœºæ™¯3: WebSocketè¿æ¥ï¼ˆè®¾å¤‡çŠ¶æ€ç›‘å¬ï¼‰
    W->>P: WebSocketè¿æ¥è¯·æ±‚
    P->>W: è¿æ¥å»ºç«‹æˆåŠŸ
    
    loop è®¾å¤‡çŠ¶æ€å˜åŒ–
        P->>W: device_status_changedäº‹ä»¶
        Note right of W: å®æ—¶æ›´æ–°è®¾å¤‡çŠ¶æ€
    end
```

###### 3.3.2.6.2 å½•åƒæŸ¥è¯¢å’Œç®¡ç†æµç¨‹

```mermaid
sequenceDiagram
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    participant R as å½•åƒç®¡ç†å™¨
    participant F as æ–‡ä»¶ç³»ç»Ÿ
    
    Note over W,F: åœºæ™¯1: æŸ¥è¯¢è®¾å¤‡å½•åƒåˆ—è¡¨
    W->>P: GET /api/v1/devices/device_001/recordings<br/>?start_time=2025-12-10&end_time=2025-12-11
    P->>R: æŸ¥è¯¢å½•åƒåˆ—è¡¨
    
    alt ç¼“å­˜å‘½ä¸­
        R->>R: ä»å†…å­˜ç¼“å­˜è¯»å–å…ƒæ•°æ®
        R->>P: è¿”å›å½•åƒåˆ—è¡¨
    else ç¼“å­˜æœªå‘½ä¸­æˆ–è¿‡æœŸ
        R->>F: æ‰«ææ–‡ä»¶ç³»ç»Ÿ
        F->>R: è¿”å›æ–‡ä»¶åˆ—è¡¨
        R->>R: è§£æå…ƒæ•°æ®å¹¶ç¼“å­˜
        R->>P: è¿”å›å½•åƒåˆ—è¡¨
    end
    
    P->>W: è¿”å›å½•åƒåˆ—è¡¨ï¼ˆå«åˆ†é¡µï¼‰
    Note right of W: æ˜¾ç¤ºå½•åƒåˆ—è¡¨<br/>ç¼©ç•¥å›¾ã€æ—¶é•¿ã€å¤§å°
    
    Note over W,F: åœºæ™¯2: è·å–å½•åƒç¼©ç•¥å›¾
    W->>P: GET /api/v1/recordings/rec_001/thumbnail
    P->>F: è¯»å–ç¼©ç•¥å›¾æ–‡ä»¶
    F->>P: è¿”å›ç¼©ç•¥å›¾æ•°æ®
    P->>W: è¿”å›ç¼©ç•¥å›¾ï¼ˆJPEGï¼‰
    Note right of W: æ˜¾ç¤ºç¼©ç•¥å›¾
    
    Note over W,F: åœºæ™¯3: ä¸‹è½½å½•åƒæ–‡ä»¶
    W->>P: GET /api/v1/recordings/rec_001/download
    P->>F: æ‰“å¼€æ–‡ä»¶æµ
    F->>P: è¿”å›æ–‡ä»¶æ•°æ®æµ
    P->>W: æµå¼ä¼ è¾“æ–‡ä»¶
    Note right of W: æµè§ˆå™¨ä¸‹è½½æ–‡ä»¶
```

###### 3.3.2.6.3 ç›´é€šæ’­æ”¾å®Œæ•´æµç¨‹

```mermaid
sequenceDiagram
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    participant D as è®¾å¤‡ç«¯
    participant WS as WebSocket
    
    Note over W,D: åœºæ™¯1: å¯åŠ¨ç›´é€šæ’­æ”¾
    W->>P: POST /api/v1/devices/device_001/live-stream<br/>{client_id, quality, low_latency_mode}
    
    P->>P: éªŒè¯è®¾å¤‡åœ¨çº¿çŠ¶æ€
    P->>P: åˆ›å»ºæµä¼šè¯
    
    P->>D: QUIC: FileRequest<br/>(è¯·æ±‚å®æ—¶æµ)
    D->>P: QUIC: StatusResponse<br/>(å‡†å¤‡å°±ç»ª)
    
    P->>W: è¿”å›ä¼šè¯ä¿¡æ¯<br/>{session_id, stream_url, websocket_url}
    
    Note over W,D: åœºæ™¯2: å»ºç«‹WebSocketè¿æ¥
    W->>WS: è¿æ¥ wss://.../stream/{session_id}/events
    WS->>W: è¿æ¥å»ºç«‹æˆåŠŸ
    
    Note over W,D: åœºæ™¯3: è§†é¢‘åˆ†ç‰‡ä¼ è¾“
    loop å®æ—¶è§†é¢‘æµ
        D->>P: QUIC: VideoSegment<br/>(è§†é¢‘åˆ†ç‰‡)
        P->>P: åè®®è½¬æ¢ QUICâ†’HTTP3
        P->>P: å»¶è¿Ÿç›‘æ§ï¼ˆè®°å½•æ—¶é—´æˆ³ï¼‰
        
        par å¹¶è¡Œå¤„ç†
            P->>W: HTTP3: POST /stream/{session_id}/segments<br/>(è§†é¢‘åˆ†ç‰‡)
            Note right of W: MediaSourceæ¥æ”¶<br/>å®æ—¶æ’­æ”¾
        and
            P->>WS: segment_receivedäº‹ä»¶<br/>{segment_id, latency_ms}
            WS->>W: æ¨é€äº‹ä»¶
            Note right of W: æ›´æ–°æ€§èƒ½ç»Ÿè®¡
        end
        
        alt å»¶è¿Ÿè¶…è¿‡é˜ˆå€¼
            P->>WS: latency_alertäº‹ä»¶<br/>{current_latency_ms, threshold_ms}
            WS->>W: æ¨é€å‘Šè­¦
            Note right of W: æ˜¾ç¤ºå»¶è¿Ÿå‘Šè­¦
        end
    end
    
    Note over W,D: åœºæ™¯4: åœæ­¢ç›´é€šæ’­æ”¾
    W->>P: DELETE /api/v1/stream/{session_id}<br/>{reason: "user_stop"}
    P->>D: QUIC: PlaybackControl<br/>(Stopå‘½ä»¤)
    D->>P: QUIC: StatusResponse<br/>(å·²åœæ­¢)
    P->>W: è¿”å›æˆåŠŸ
    P->>WS: å…³é—­WebSocketè¿æ¥
    Note right of W: åœæ­¢æ’­æ”¾<br/>æ¸…ç†èµ„æº
```

###### 3.3.2.6.4 å½•åƒå›æ”¾å®Œæ•´æµç¨‹

```mermaid
sequenceDiagram
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    participant R as å›æ”¾å¤„ç†å™¨
    participant F as æ–‡ä»¶ç³»ç»Ÿ
    participant WS as WebSocket
    
    Note over W,F: å‰ç½®æ¡ä»¶: å·²æŸ¥è¯¢å½•åƒåˆ—è¡¨ï¼Œè·å¾—file_id
    
    Note over W,F: åœºæ™¯1: å¯åŠ¨å½•åƒå›æ”¾
    W->>P: POST /api/v1/recordings/rec_001/playback<br/>{client_id, start_position, playback_rate}
    
    P->>R: åˆ›å»ºå›æ”¾ä¼šè¯
    R->>F: éªŒè¯æ–‡ä»¶å­˜åœ¨æ€§
    F->>R: æ–‡ä»¶å¯è®¿é—®
    R->>R: åˆ›å»ºFileStreamReader
    R->>R: æ„å»ºå…³é”®å¸§ç´¢å¼•
    
    P->>W: è¿”å›ä¼šè¯ä¿¡æ¯<br/>{session_id, playback_url, websocket_url, file_info}
    
    Note over W,F: åœºæ™¯2: å»ºç«‹WebSocketè¿æ¥
    W->>WS: è¿æ¥ wss://.../playback/{session_id}/events
    WS->>W: è¿æ¥å»ºç«‹æˆåŠŸ
    
    Note over W,F: åœºæ™¯3: è§†é¢‘åˆ†ç‰‡ä¼ è¾“
    loop å›æ”¾è§†é¢‘æµ
        R->>F: è¯»å–è§†é¢‘åˆ†ç‰‡
        F->>R: è¿”å›åˆ†ç‰‡æ•°æ®
        R->>R: æ ¹æ®playback_rateæ§åˆ¶é€Ÿåº¦
        
        par å¹¶è¡Œå¤„ç†
            P->>W: HTTP3: POST /playback/{session_id}/segments<br/>(è§†é¢‘åˆ†ç‰‡)
            Note right of W: MediaSourceæ¥æ”¶<br/>å›æ”¾æ’­æ”¾
        and
            P->>WS: segment_receivedäº‹ä»¶<br/>{segment_id, timestamp}
            WS->>W: æ¨é€äº‹ä»¶
            Note right of W: æ›´æ–°æ’­æ”¾è¿›åº¦
        end
        
        alt ç¼“å†²åŒºå¥åº·åº¦ä½
            P->>WS: buffer_statusäº‹ä»¶<br/>{buffer_health: "low"}
            WS->>W: æ¨é€ç¼“å†²çŠ¶æ€
            Note right of W: æ˜¾ç¤ºç¼“å†²ä¸­
        end
    end
    
    Note over W,F: åœºæ™¯4: æ’­æ”¾æ§åˆ¶ - æš‚åœ
    W->>P: POST /api/v1/playback/{session_id}/control<br/>{command: "pause"}
    P->>R: æš‚åœåˆ†ç‰‡ä¼ è¾“
    R->>R: ä¿æŒå½“å‰ä½ç½®
    P->>W: è¿”å›æˆåŠŸ
    P->>WS: playback_status_changedäº‹ä»¶<br/>{status: "paused", position: 120.5}
    WS->>W: æ¨é€çŠ¶æ€å˜åŒ–
    Note right of W: æ›´æ–°UIä¸ºæš‚åœçŠ¶æ€
    
    Note over W,F: åœºæ™¯5: æ’­æ”¾æ§åˆ¶ - æ‹–åŠ¨å®šä½
    W->>P: POST /api/v1/playback/{session_id}/control<br/>{command: "seek", position: 300.0}
    P->>R: æ‰§è¡ŒSEEKæ“ä½œ
    R->>R: æŸ¥æ‰¾æœ€è¿‘å…³é”®å¸§
    R->>F: å®šä½åˆ°æ–‡ä»¶ä½ç½®
    F->>R: å®šä½æˆåŠŸ
    R->>R: æ›´æ–°å½“å‰ä½ç½®
    P->>W: è¿”å›æˆåŠŸ
    P->>WS: playback_status_changedäº‹ä»¶<br/>{status: "seeking", position: 300.0}
    WS->>W: æ¨é€çŠ¶æ€å˜åŒ–
    Note right of W: æ˜¾ç¤ºå®šä½ä¸­
    
    Note over W,F: åœºæ™¯6: æ’­æ”¾æ§åˆ¶ - å€é€Ÿæ’­æ”¾
    W->>P: POST /api/v1/playback/{session_id}/control<br/>{command: "set_rate", rate: 2.0}
    P->>R: è°ƒæ•´æ’­æ”¾é€Ÿç‡
    R->>R: æ›´æ–°ä¼ è¾“é—´éš”
    P->>W: è¿”å›æˆåŠŸ
    P->>WS: playback_status_changedäº‹ä»¶<br/>{status: "playing", rate: 2.0}
    WS->>W: æ¨é€çŠ¶æ€å˜åŒ–
    Note right of W: æ›´æ–°å€é€Ÿæ˜¾ç¤º
    
    Note over W,F: åœºæ™¯7: åœæ­¢å›æ”¾
    W->>P: POST /api/v1/playback/{session_id}/control<br/>{command: "stop"}
    P->>R: åœæ­¢åˆ†ç‰‡ä¼ è¾“
    R->>F: å…³é—­æ–‡ä»¶æµ
    R->>R: æ¸…ç†ä¼šè¯èµ„æº
    P->>W: è¿”å›æˆåŠŸ
    P->>WS: å…³é—­WebSocketè¿æ¥
    Note right of W: åœæ­¢æ’­æ”¾<br/>æ¸…ç†èµ„æº
```

###### 3.3.2.6.5 è®¾å¤‡çŠ¶æ€ç›‘æ§æµç¨‹

```mermaid
sequenceDiagram
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    participant D as è®¾å¤‡ç«¯
    participant WS as WebSocket
    
    Note over W,D: åœºæ™¯1: å»ºç«‹å…¨å±€è®¾å¤‡ç›‘æ§
    W->>P: WebSocketè¿æ¥è¯·æ±‚<br/>wss://.../devices/events
    P->>W: è¿æ¥å»ºç«‹æˆåŠŸ
    
    Note over W,D: åœºæ™¯2: è®¾å¤‡ä¸Šçº¿
    D->>P: QUIC: SessionStart<br/>(è®¾å¤‡è¿æ¥)
    P->>P: æ³¨å†Œè®¾å¤‡ä¿¡æ¯
    P->>WS: device_status_changedäº‹ä»¶<br/>{device_id, status: "online"}
    WS->>W: æ¨é€è®¾å¤‡ä¸Šçº¿äº‹ä»¶
    Note right of W: æ›´æ–°è®¾å¤‡åˆ—è¡¨<br/>æ˜¾ç¤ºä¸ºåœ¨çº¿
    
    Note over W,D: åœºæ™¯3: è®¾å¤‡å¿ƒè·³
    loop æ¯30ç§’
        D->>P: QUIC: StatusResponse<br/>(å¿ƒè·³ + æ€§èƒ½æ•°æ®)
        P->>P: æ›´æ–°è®¾å¤‡æœ€åå¿ƒè·³æ—¶é—´
        P->>P: æ›´æ–°æ€§èƒ½æŒ‡æ ‡
    end
    
    Note over W,D: åœºæ™¯4: è®¾å¤‡ç¦»çº¿æ£€æµ‹
    P->>P: æ£€æµ‹å¿ƒè·³è¶…æ—¶ï¼ˆ>60ç§’ï¼‰
    P->>P: æ ‡è®°è®¾å¤‡ä¸ºç¦»çº¿
    P->>WS: device_status_changedäº‹ä»¶<br/>{device_id, status: "offline", reason: "timeout"}
    WS->>W: æ¨é€è®¾å¤‡ç¦»çº¿äº‹ä»¶
    Note right of W: æ›´æ–°è®¾å¤‡åˆ—è¡¨<br/>æ˜¾ç¤ºä¸ºç¦»çº¿<br/>æç¤ºç”¨æˆ·
    
    Note over W,D: åœºæ™¯5: è®¾å¤‡é‡è¿
    D->>P: QUIC: SessionStart<br/>(é‡æ–°è¿æ¥)
    P->>P: æ¢å¤è®¾å¤‡åœ¨çº¿çŠ¶æ€
    P->>WS: device_status_changedäº‹ä»¶<br/>{device_id, status: "online"}
    WS->>W: æ¨é€è®¾å¤‡é‡è¿äº‹ä»¶
    Note right of W: æ›´æ–°è®¾å¤‡åˆ—è¡¨<br/>æ˜¾ç¤ºä¸ºåœ¨çº¿
```

###### 3.3.2.6.6 æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦æµç¨‹

```mermaid
sequenceDiagram
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    participant M as å»¶è¿Ÿç›‘æ§å™¨
    participant WS as WebSocket
    
    Note over W,M: åœºæ™¯1: å®æ—¶æ€§èƒ½ç›‘æ§
    loop æ¯ç§’ç»Ÿè®¡
        M->>M: æ”¶é›†æ€§èƒ½æŒ‡æ ‡<br/>å»¶è¿Ÿã€ååé‡ã€ä¸¢åŒ…ç‡
        M->>P: æ›´æ–°æ€§èƒ½ç»Ÿè®¡
        
        alt æœ‰æ´»è·ƒçš„WebSocketè¿æ¥
            P->>WS: segment_receivedäº‹ä»¶<br/>{latency_ms, throughput_mbps}
            WS->>W: æ¨é€æ€§èƒ½æ•°æ®
            Note right of W: æ›´æ–°æ€§èƒ½å›¾è¡¨<br/>å®æ—¶æ˜¾ç¤º
        end
    end
    
    Note over W,M: åœºæ™¯2: å»¶è¿Ÿå‘Šè­¦
    M->>M: æ£€æµ‹å»¶è¿Ÿè¶…è¿‡é˜ˆå€¼<br/>(>200ms)
    M->>P: è§¦å‘å»¶è¿Ÿå‘Šè­¦
    P->>WS: latency_alertäº‹ä»¶<br/>{current_latency_ms: 250, threshold_ms: 200, severity: "warning"}
    WS->>W: æ¨é€å‘Šè­¦
    Note right of W: æ˜¾ç¤ºå‘Šè­¦æç¤º<br/>é»„è‰²è­¦å‘Šå›¾æ ‡
    
    Note over W,M: åœºæ™¯3: ä¸¥é‡å»¶è¿Ÿå‘Šè­¦
    M->>M: æ£€æµ‹å»¶è¿Ÿä¸¥é‡è¶…æ ‡<br/>(>500ms)
    M->>P: è§¦å‘ä¸¥é‡å‘Šè­¦
    P->>WS: latency_alertäº‹ä»¶<br/>{current_latency_ms: 550, threshold_ms: 200, severity: "critical"}
    WS->>W: æ¨é€ä¸¥é‡å‘Šè­¦
    Note right of W: æ˜¾ç¤ºä¸¥é‡å‘Šè­¦<br/>çº¢è‰²è­¦å‘Šå›¾æ ‡<br/>å»ºè®®é™ä½è´¨é‡
    
    Note over W,M: åœºæ™¯4: ç¼“å†²åŒºç›‘æ§
    loop æ¯2ç§’æ£€æŸ¥
        P->>P: æ£€æŸ¥ç¼“å†²åŒºå¥åº·åº¦
        
        alt ç¼“å†²åŒºå¥åº·
            P->>WS: buffer_statusäº‹ä»¶<br/>{buffer_health: "healthy", buffer_duration: 28.5}
            WS->>W: æ¨é€ç¼“å†²çŠ¶æ€
            Note right of W: ç»¿è‰²ç¼“å†²æŒ‡ç¤ºå™¨
        else ç¼“å†²åŒºåä½
            P->>WS: buffer_statusäº‹ä»¶<br/>{buffer_health: "low", buffer_duration: 5.2}
            WS->>W: æ¨é€ç¼“å†²çŠ¶æ€
            Note right of W: é»„è‰²ç¼“å†²æŒ‡ç¤ºå™¨<br/>æ˜¾ç¤º"ç¼“å†²ä¸­"
        else ç¼“å†²åŒºä¸¥é‡ä¸è¶³
            P->>WS: buffer_statusäº‹ä»¶<br/>{buffer_health: "critical", buffer_duration: 1.0, is_buffering: true}
            WS->>W: æ¨é€ç¼“å†²çŠ¶æ€
            Note right of W: çº¢è‰²ç¼“å†²æŒ‡ç¤ºå™¨<br/>æš‚åœæ’­æ”¾<br/>æ˜¾ç¤º"ç¼“å†²ä¸­"
        end
    end
    
    Note over W,M: åœºæ™¯5: è´¨é‡è‡ªé€‚åº”è°ƒæ•´
    P->>P: æ£€æµ‹ç½‘ç»œæ¡ä»¶æ¶åŒ–<br/>å¸¦å®½ä¸è¶³
    P->>P: è‡ªåŠ¨é™ä½è§†é¢‘è´¨é‡
    P->>WS: quality_changedäº‹ä»¶<br/>{old_quality: "high", new_quality: "medium", reason: "bandwidth_limitation"}
    WS->>W: æ¨é€è´¨é‡å˜åŒ–
    Note right of W: æ˜¾ç¤ºè´¨é‡å˜åŒ–æç¤º<br/>"å·²è‡ªåŠ¨è°ƒæ•´ä¸ºä¸­ç­‰ç”»è´¨"
```

###### 3.3.2.6.7 é”™è¯¯å¤„ç†æµç¨‹

```mermaid
sequenceDiagram
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    participant D as è®¾å¤‡ç«¯
    participant WS as WebSocket
    
    Note over W,D: åœºæ™¯1: è®¾å¤‡ç¦»çº¿é”™è¯¯
    W->>P: POST /api/v1/devices/device_001/live-stream
    P->>P: æ£€æŸ¥è®¾å¤‡çŠ¶æ€
    P->>W: HTTP 404 Not Found<br/>{error: "Device offline", device_id: "device_001"}
    Note right of W: æ˜¾ç¤ºé”™è¯¯æç¤º<br/>"è®¾å¤‡å·²ç¦»çº¿"
    
    Note over W,D: åœºæ™¯2: æ–‡ä»¶ä¸å­˜åœ¨é”™è¯¯
    W->>P: POST /api/v1/recordings/rec_999/playback
    P->>P: æŸ¥è¯¢å½•åƒæ–‡ä»¶
    P->>W: HTTP 404 Not Found<br/>{error: "Recording not found", file_id: "rec_999"}
    Note right of W: æ˜¾ç¤ºé”™è¯¯æç¤º<br/>"å½•åƒæ–‡ä»¶ä¸å­˜åœ¨"
    
    Note over W,D: åœºæ™¯3: ä¼šè¯è¶…æ—¶é”™è¯¯
    W->>P: POST /api/v1/playback/{expired_session_id}/control
    P->>P: æŸ¥è¯¢ä¼šè¯
    P->>W: HTTP 404 Not Found<br/>{error: "Session expired", session_id: "..."}
    Note right of W: æ˜¾ç¤ºé”™è¯¯æç¤º<br/>"ä¼šè¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°å¼€å§‹"
    
    Note over W,D: åœºæ™¯4: ä¼ è¾“é”™è¯¯å’Œé‡è¯•
    D->>P: QUIC: VideoSegment<br/>(åˆ†ç‰‡æ•°æ®)
    P->>P: æ£€æµ‹åˆ†ç‰‡æŸå
    P->>D: QUIC: ErrorReport<br/>{error_code: 1005, segment_id: "..."}
    D->>P: QUIC: VideoSegment<br/>(é‡ä¼ åˆ†ç‰‡)
    P->>W: HTTP3: æ­£å¸¸åˆ†ç‰‡ä¼ è¾“
    Note right of W: ç”¨æˆ·æ— æ„ŸçŸ¥<br/>è‡ªåŠ¨æ¢å¤
    
    Note over W,D: åœºæ™¯5: ç½‘ç»œä¸­æ–­æ¢å¤
    W->>P: WebSocketè¿æ¥ä¸­æ–­
    Note right of W: æ£€æµ‹åˆ°è¿æ¥æ–­å¼€
    
    loop é‡è¿å°è¯•ï¼ˆæœ€å¤š5æ¬¡ï¼‰
        W->>P: WebSocketé‡è¿è¯·æ±‚
        alt é‡è¿æˆåŠŸ
            P->>W: è¿æ¥å»ºç«‹æˆåŠŸ
            Note right of W: æ¢å¤æ­£å¸¸<br/>ç»§ç»­æ¥æ”¶äº‹ä»¶
        else é‡è¿å¤±è´¥
            Note right of W: ç­‰å¾…æŒ‡æ•°é€€é¿<br/>1s, 2s, 4s, 8s, 16s
        end
    end
    
    alt é‡è¿å…¨éƒ¨å¤±è´¥
        Note right of W: æ˜¾ç¤ºé”™è¯¯æç¤º<br/>"è¿æ¥å·²æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢"
    end
    
    Note over W,D: åœºæ™¯6: æœåŠ¡å™¨é”™è¯¯
    W->>P: POST /api/v1/devices/device_001/live-stream
    P->>P: å†…éƒ¨é”™è¯¯å‘ç”Ÿ
    P->>W: HTTP 500 Internal Server Error<br/>{error: "Internal error", message: "..."}
    Note right of W: æ˜¾ç¤ºé”™è¯¯æç¤º<br/>"æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•"
```

###### 3.3.2.6.8 å®Œæ•´ç”¨æˆ·æ“ä½œæµç¨‹

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant W as Webå‰ç«¯
    participant P as å¹³å°ç«¯
    participant D as è®¾å¤‡ç«¯
    
    Note over U,D: å®Œæ•´çš„ç”¨æˆ·æ“ä½œæµç¨‹ç¤ºä¾‹
    
    U->>W: æ‰“å¼€Webé¡µé¢
    W->>P: GET /api/v1/devices
    P->>W: è¿”å›è®¾å¤‡åˆ—è¡¨
    W->>U: æ˜¾ç¤ºè®¾å¤‡åˆ—è¡¨
    
    U->>W: ç‚¹å‡»"æŸ¥çœ‹å½•åƒ"æŒ‰é’®
    W->>P: GET /api/v1/devices/device_001/recordings
    P->>W: è¿”å›å½•åƒåˆ—è¡¨
    W->>U: æ˜¾ç¤ºå½•åƒåˆ—è¡¨ï¼ˆå«ç¼©ç•¥å›¾ï¼‰
    
    U->>W: ç‚¹å‡»æŸä¸ªå½•åƒçš„"æ’­æ”¾"æŒ‰é’®
    W->>P: POST /api/v1/recordings/rec_001/playback
    P->>W: è¿”å›ä¼šè¯ä¿¡æ¯
    W->>P: å»ºç«‹WebSocketè¿æ¥
    W->>U: å¼€å§‹æ’­æ”¾è§†é¢‘
    
    loop æ’­æ”¾è¿‡ç¨‹
        P->>W: æ¨é€è§†é¢‘åˆ†ç‰‡
        W->>U: å®æ—¶æ’­æ”¾
        P->>W: æ¨é€æ€§èƒ½äº‹ä»¶
        W->>U: æ›´æ–°è¿›åº¦æ¡å’Œç»Ÿè®¡
    end
    
    U->>W: æ‹–åŠ¨è¿›åº¦æ¡åˆ°5åˆ†é’Ÿä½ç½®
    W->>P: POST /control {command: "seek", position: 300}
    P->>W: è¿”å›æˆåŠŸ
    W->>U: è·³è½¬åˆ°5åˆ†é’Ÿä½ç½®ç»§ç»­æ’­æ”¾
    
    U->>W: ç‚¹å‡»"2å€é€Ÿ"æŒ‰é’®
    W->>P: POST /control {command: "set_rate", rate: 2.0}
    P->>W: è¿”å›æˆåŠŸ
    W->>U: ä»¥2å€é€Ÿæ’­æ”¾
    
    U->>W: ç‚¹å‡»"æš‚åœ"æŒ‰é’®
    W->>P: POST /control {command: "pause"}
    P->>W: è¿”å›æˆåŠŸ
    W->>U: æš‚åœæ’­æ”¾
    
    U->>W: ç‚¹å‡»"åœæ­¢"æŒ‰é’®
    W->>P: POST /control {command: "stop"}
    P->>W: è¿”å›æˆåŠŸ
    W->>P: å…³é—­WebSocketè¿æ¥
    W->>U: åœæ­¢æ’­æ”¾ï¼Œè¿”å›å½•åƒåˆ—è¡¨
    
    U->>W: ç‚¹å‡»"ç›´é€šæ’­æ”¾"æŒ‰é’®
    W->>P: POST /api/v1/devices/device_001/live-stream
    P->>D: è¯·æ±‚å®æ—¶æµ
    D->>P: å¼€å§‹ä¼ è¾“
    P->>W: è¿”å›ä¼šè¯ä¿¡æ¯
    W->>P: å»ºç«‹WebSocketè¿æ¥
    W->>U: å¼€å§‹å®æ—¶æ’­æ”¾
    
    loop å®æ—¶æ’­æ”¾
        D->>P: æ¨é€å®æ—¶è§†é¢‘åˆ†ç‰‡
        P->>W: è½¬å‘è§†é¢‘åˆ†ç‰‡
        W->>U: å®æ—¶æ’­æ”¾
        P->>W: æ¨é€å»¶è¿Ÿç»Ÿè®¡
        W->>U: æ˜¾ç¤ºå»¶è¿ŸæŒ‡æ ‡
    end
    
    U->>W: ç‚¹å‡»"åœæ­¢ç›´é€š"æŒ‰é’®
    W->>P: DELETE /api/v1/stream/{session_id}
    P->>D: åœæ­¢ä¼ è¾“
    P->>W: è¿”å›æˆåŠŸ
    W->>P: å…³é—­WebSocketè¿æ¥
    W->>U: åœæ­¢æ’­æ”¾ï¼Œè¿”å›è®¾å¤‡åˆ—è¡¨
```

## 4. å¹³å°ç«¯æ ¸å¿ƒè®¾è®¡ï¼ˆé‡ç‚¹ï¼‰

### 4.1 å¹³å°ç«¯æ¶æ„

**æ¶æ„è¯´æ˜**ï¼š
- å¹³å°ç«¯æ˜¯**å•ä¸€æœåŠ¡è¿›ç¨‹**ï¼ŒåŒæ—¶ç›‘å¬ä¸¤ä¸ªç«¯å£
- QUICæœåŠ¡å™¨å’ŒHTTP3æœåŠ¡å™¨å…±äº«åŒä¸€ä¸ªè¿›ç¨‹ç©ºé—´
- å½•åƒç®¡ç†å™¨åªç¼“å­˜æ–‡ä»¶å…ƒæ•°æ®ï¼Œä¸ç¼“å­˜è§†é¢‘å†…å®¹

```mermaid
graph TB
    subgraph å¹³å°ç«¯æ ¸å¿ƒæœåŠ¡å™¨
        subgraph æ¥å…¥å±‚
            QUIC[QUICæœåŠ¡å™¨<br/>è®¾å¤‡ç«¯æ¥å…¥]
            HTTP3[HTTP3æœåŠ¡å™¨<br/>å‰ç«¯æ¥å…¥]
            CONV[åè®®è½¬æ¢å™¨<br/>æ ¸å¿ƒç»„ä»¶]
        end
        
        subgraph ä¸šåŠ¡å±‚
            DEV[è®¾å¤‡ç®¡ç†å™¨<br/>è®¾å¤‡æ³¨å†Œ]
            DIST[åˆ†å‘ç®¡ç†å™¨<br/>å¤šè·¯åˆ†å‘]
            CACHE[ç¼“å­˜ç®¡ç†å™¨<br/>è¾¹ç¼“å­˜]
        end
        
        subgraph æ•°æ®å±‚
            REC[å½•åƒç®¡ç†å™¨<br/>æ–‡ä»¶ç´¢å¼•]
            SESS[ä¼šè¯ç®¡ç†å™¨<br/>æµä¼šè¯]
            LAT[å»¶è¿Ÿç›‘æ§å™¨<br/>æ€§èƒ½ç›‘æ§]
        end
        
        subgraph å¤„ç†å±‚
            LIVE[ç›´é€šå¤„ç†å™¨<br/>å®æ—¶æµ]
            PLAY[å›æ”¾å¤„ç†å™¨<br/>å½•åƒæ’­æ”¾]
            LB[è´Ÿè½½å‡è¡¡å™¨<br/>æµé‡åˆ†é…]
        end
    end
    
    QUIC --> CONV
    HTTP3 --> CONV
    CONV --> DEV
    CONV --> DIST
    CONV --> REC
    
    DEV --> SESS
    DIST --> CACHE
    DIST --> LB
    
    SESS --> LIVE
    SESS --> PLAY
    REC --> PLAY
    
    LIVE --> LAT
    PLAY --> LAT
    
    style QUIC fill:#bbdefb
    style HTTP3 fill:#bbdefb
    style CONV fill:#ffccbc
    style DEV fill:#c5e1a5
    style DIST fill:#c5e1a5
    style CACHE fill:#c5e1a5
    style REC fill:#fff9c4
    style SESS fill:#fff9c4
    style LAT fill:#fff9c4
    style LIVE fill:#f8bbd0
    style PLAY fill:#f8bbd0
    style LB fill:#f8bbd0
```

### 4.1.1 å¹³å°ç«¯æœåŠ¡è¯´æ˜

**é‡è¦è¯´æ˜**ï¼š
1. **å•ä¸€æœåŠ¡è¿›ç¨‹**ï¼šQUICæœåŠ¡å™¨å’ŒHTTP3æœåŠ¡å™¨æ˜¯åŒä¸€ä¸ªè¿›ç¨‹ï¼Œä¸æ˜¯ä¸¤ä¸ªç‹¬ç«‹æœåŠ¡
2. **åŒç«¯å£ç›‘å¬**ï¼š
   - ç«¯å£8080ï¼šQUICåè®®ï¼Œæ¥æ”¶è®¾å¤‡ç«¯è¿æ¥
   - ç«¯å£8443ï¼šHTTP3åè®®ï¼Œæ¥æ”¶Webå‰ç«¯è¿æ¥
3. **å…±äº«ç»„ä»¶**ï¼šä¸¤ä¸ªç«¯å£å…±äº«åè®®è½¬æ¢å™¨ã€å½•åƒç®¡ç†å™¨ã€ç¼“å­˜ç®¡ç†å™¨ç­‰æ ¸å¿ƒç»„ä»¶

### 4.1.2 æ ¸å¿ƒæ¨¡å—è¯´æ˜

#### è®¾å¤‡ç®¡ç†å™¨ (Device Manager)
- **åŠŸèƒ½**: è®¾å¤‡æ³¨å†Œã€çŠ¶æ€ç›‘æ§ã€èƒ½åŠ›ç®¡ç†
- **èŒè´£**: ç»´æŠ¤è®¾å¤‡è¿æ¥çŠ¶æ€ã€å¤„ç†è®¾å¤‡æŸ¥è¯¢è¯·æ±‚
- **å­˜å‚¨**: å†…å­˜HashMapï¼ˆDemoç‰ˆæœ¬ï¼‰
- **æ¥å£**: æä¾›è®¾å¤‡åˆ—è¡¨ã€è®¾å¤‡è¯¦æƒ…API

#### å½•åƒç®¡ç†å™¨ (Recording Manager)  
- **åŠŸèƒ½**: å½•åƒæ–‡ä»¶ç´¢å¼•ã€å­˜å‚¨ç®¡ç†ã€è®¿é—®æ§åˆ¶
- **èŒè´£**: 
  - ğŸ“ æ‰«ææ–‡ä»¶ç³»ç»Ÿï¼Œå‘ç°å½•åƒæ–‡ä»¶
  - ğŸ“Š è§£æè§†é¢‘æ–‡ä»¶å…ƒæ•°æ®ï¼ˆæ—¶é•¿ã€åˆ†è¾¨ç‡ã€æ ¼å¼ç­‰ï¼‰
  - ğŸ’¾ ç¼“å­˜å½•åƒæ–‡ä»¶å…ƒæ•°æ®ï¼ˆçº¦500KB/1000ä¸ªæ–‡ä»¶ï¼‰
  - ğŸ” æä¾›å½•åƒæŸ¥è¯¢æ¥å£
- **æ¥å£**: æä¾›å½•åƒæŸ¥è¯¢ã€æ’­æ”¾API
- **é‡è¦**: 
  - âœ… ç¼“å­˜ï¼šæ–‡ä»¶å…ƒæ•°æ®ï¼ˆæ–‡ä»¶åã€å¤§å°ã€æ—¶é•¿ç­‰ï¼‰- å‡ ç™¾KB
  - âŒ ä¸ç¼“å­˜ï¼šè§†é¢‘æ–‡ä»¶å†…å®¹æœ¬èº« - å‡ ç™¾GB
  - ğŸ“– ç±»æ¯”ï¼šç¼“å­˜å›¾ä¹¦ç›®å½•å¡ç‰‡ï¼Œä¸ç¼“å­˜ä¹¦ç±æœ¬èº«
  - ğŸ¬ å›æ”¾æ—¶ï¼šå®æ—¶ä»ç£ç›˜è¯»å–è§†é¢‘å†…å®¹

#### ç›´é€šå¤„ç†å™¨ (Live Stream Handler)
- **åŠŸèƒ½**: å®æ—¶æµå¤„ç†ã€ä½å»¶è¿Ÿä¼ è¾“ã€è´¨é‡è‡ªé€‚åº”
- **èŒè´£**: è®¾å¤‡æµæ¥å…¥ã€å®æ—¶åˆ†å‘ã€å»¶è¿Ÿä¼˜åŒ–
- **ç‰¹æ€§**: è¾¹æ¥æ”¶è¾¹è½¬å‘ã€é›¶ç¼“å†²ä¼ è¾“

#### å›æ”¾å¤„ç†å™¨ (Playback Handler)
- **åŠŸèƒ½**: å½•åƒå›æ”¾ã€è¿›åº¦æ§åˆ¶ã€å¤šå€é€Ÿæ’­æ”¾
- **èŒè´£**: æ–‡ä»¶æµåŒ–ã€æ’­æ”¾æ§åˆ¶ã€è¿›åº¦åŒæ­¥
- **ç‰¹æ€§**: æ”¯æŒæ‹–åŠ¨å®šä½ã€å€é€Ÿæ’­æ”¾ã€è´¨é‡åˆ‡æ¢

### 4.2 æ ¸å¿ƒç»„ä»¶è¯¦ç»†è®¾è®¡

#### 4.2.1 åè®®è½¬æ¢å™¨ (Protocol Converter)

**Demoç‰ˆæœ¬ç®€åŒ–è®¾è®¡**ï¼šä½¿ç”¨å†…å­˜å­˜å‚¨ï¼Œæ— éœ€æ•°æ®åº“

```rust
pub struct ProtocolConverter {
    quic_sessions: HashMap<Uuid, QUICSession>,
    http3_clients: HashMap<String, HTTP3Client>,
    device_registry: DeviceRegistry,           // å†…å­˜å­˜å‚¨è®¾å¤‡ä¿¡æ¯
    recording_manager: RecordingManager,       // æ–‡ä»¶ç³»ç»Ÿæ‰«æå½•åƒ
    segment_buffer: SegmentBuffer,
    conversion_stats: ConversionStats,
}

#[derive(Debug, Clone)]
pub struct DeviceRegistry {
    // Demoç‰ˆæœ¬ï¼šå†…å­˜HashMapå­˜å‚¨ï¼Œé‡å¯åä¸¢å¤±
    devices: HashMap<String, DeviceInfo>,
    device_sessions: HashMap<String, Vec<Uuid>>,
    device_capabilities: HashMap<String, DeviceCapabilities>,
}

#[derive(Debug, Clone)]
pub struct DeviceInfo {
    pub device_id: String,
    pub device_name: String,
    pub device_type: DeviceType,
    pub connection_status: ConnectionStatus,
    pub connection_time: SystemTime,
    pub last_heartbeat: SystemTime,
    pub hardware_info: HardwareInfo,
    pub network_stats: NetworkStats,
    pub current_performance: PerformanceMetrics,
}

#[derive(Debug, Clone)]
pub enum DeviceType {
    Camera,
    Recorder,
    Simulator,
    Gateway,
}

#[derive(Debug, Clone)]
pub struct RecordingManager {
    // Demoç‰ˆæœ¬ï¼šæ–‡ä»¶ç³»ç»Ÿæ‰«æï¼Œæ— éœ€æ•°æ®åº“ç´¢å¼•
    recordings_cache: HashMap<String, RecordingInfo>,  // ç¼“å­˜å½•åƒå…ƒæ•°æ®ï¼ˆä¸æ˜¯æ–‡ä»¶å†…å®¹ï¼‰
    storage_root: PathBuf,                             // å½•åƒæ–‡ä»¶æ ¹ç›®å½•
    scan_interval: Duration,                           // æ‰«æé—´éš”ï¼ˆå¦‚æ¯5åˆ†é’Ÿï¼‰
    last_scan_time: SystemTime,                        // ä¸Šæ¬¡æ‰«ææ—¶é—´
}

impl RecordingManager {
    // å½•åƒç®¡ç†å™¨çš„æ ¸å¿ƒåŠŸèƒ½è¯´æ˜ï¼š
    // 1. æ‰«ææ–‡ä»¶ç³»ç»Ÿï¼šå®šæœŸæ‰«æstorage_rootç›®å½•ï¼Œå‘ç°æ–°çš„å½•åƒæ–‡ä»¶
    // 2. è§£æå…ƒæ•°æ®ï¼šè¯»å–è§†é¢‘æ–‡ä»¶å¤´ï¼Œæå–æ—¶é•¿ã€åˆ†è¾¨ç‡ã€ç¼–ç æ ¼å¼ç­‰ä¿¡æ¯
    // 3. ç¼“å­˜å…ƒæ•°æ®ï¼šå°†æ–‡ä»¶ä¿¡æ¯ï¼ˆRecordingInfoï¼‰ç¼“å­˜åˆ°å†…å­˜HashMapä¸­
    // 4. æä¾›æŸ¥è¯¢ï¼šæ ¹æ®è®¾å¤‡IDã€æ—¶é—´èŒƒå›´ç­‰æ¡ä»¶æŸ¥è¯¢å½•åƒåˆ—è¡¨
    // 
    // æ³¨æ„ï¼šåªç¼“å­˜å…ƒæ•°æ®ï¼ˆå‡ KBï¼‰ï¼Œä¸ç¼“å­˜è§†é¢‘æ–‡ä»¶å†…å®¹ï¼ˆå‡ GBï¼‰
    // è§†é¢‘æ–‡ä»¶å§‹ç»ˆå­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼Œå›æ”¾æ—¶å®æ—¶è¯»å–
}

#[derive(Debug, Clone)]
pub struct RecordingInfo {
    pub file_id: String,
    pub device_id: String,
    pub file_name: String,
    pub file_path: PathBuf,
    pub file_size: u64,
    pub duration: f64,
    pub format: VideoFormat,
    pub resolution: Resolution,
    pub bitrate: u64,
    pub frame_rate: f64,
    pub created_time: SystemTime,
    pub modified_time: SystemTime,
    // Demoç‰ˆæœ¬ç§»é™¤ï¼šaccess_count, last_accessedï¼ˆæ— éœ€ç»Ÿè®¡ï¼‰
    pub metadata: VideoMetadata,
    // Demoç‰ˆæœ¬ç§»é™¤ï¼šquality_variantsï¼ˆä¸æ”¯æŒå¤šè´¨é‡ï¼‰
}

impl ProtocolConverter {
    // è®¾å¤‡æ³¨å†Œå’Œç®¡ç†
    pub async fn register_device(
        &mut self,
        device_info: DeviceInfo,
        session_id: Uuid,
    ) -> Result<(), ConverterError> {
        // 1. æ³¨å†Œè®¾å¤‡ä¿¡æ¯
        self.device_registry.devices.insert(device_info.device_id.clone(), device_info.clone());
        
        // 2. å…³è”ä¼šè¯
        self.device_registry.device_sessions
            .entry(device_info.device_id.clone())
            .or_insert_with(Vec::new)
            .push(session_id);
        
        // 3. åˆå§‹åŒ–å½•åƒç®¡ç†
        self.recording_manager.initialize_device_storage(&device_info.device_id).await?;
        
        info!("Device registered: {} ({})", device_info.device_name, device_info.device_id);
        Ok(())
    }
    
    // è·å–æ‰€æœ‰è¿æ¥è®¾å¤‡
    pub fn get_connected_devices(&self) -> Vec<DeviceInfo> {
        self.device_registry.devices
            .values()
            .filter(|device| matches!(device.connection_status, ConnectionStatus::Online))
            .cloned()
            .collect()
    }
    
    // è·å–è®¾å¤‡å½•åƒæ–‡ä»¶åˆ—è¡¨ï¼ˆDemoç‰ˆæœ¬ï¼šæ–‡ä»¶ç³»ç»Ÿæ‰«æï¼‰
    pub async fn get_device_recordings(
        &self,
        device_id: &str,
        query: RecordingQuery,
    ) -> Result<RecordingListResponse, ConverterError> {
        // Demoç‰ˆæœ¬ï¼šæ‰«ææ–‡ä»¶ç³»ç»Ÿè·å–å½•åƒåˆ—è¡¨
        let recordings = self.recording_manager
            .scan_device_recordings(device_id, query)
            .await?;
            
        Ok(RecordingListResponse {
            recordings,
            pagination: self.calculate_pagination(&recordings, &query),
            summary: self.calculate_summary(&recordings),
        })
    }
    
    // Demoç‰ˆæœ¬ï¼šæ–‡ä»¶ç³»ç»Ÿæ‰«æå®ç°
    async fn scan_device_recordings(
        &self,
        device_id: &str,
        query: RecordingQuery,
    ) -> Result<Vec<RecordingInfo>, ConverterError> {
        let device_path = self.storage_root.join(device_id);
        
        if !device_path.exists() {
            return Ok(Vec::new());
        }
        
        let mut recordings = Vec::new();
        
        // é€’å½’æ‰«æç›®å½•
        for entry in walkdir::WalkDir::new(device_path)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            if entry.file_type().is_file() {
                if let Some(recording) = self.parse_recording_file(entry.path()).await? {
                    // åº”ç”¨æŸ¥è¯¢è¿‡æ»¤æ¡ä»¶
                    if self.matches_query(&recording, &query) {
                        recordings.push(recording);
                    }
                }
            }
        }
        
        // æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åº
        recordings.sort_by(|a, b| b.created_time.cmp(&a.created_time));
        
        Ok(recordings)
    }
    
    // å¼€å§‹ç›´é€šæ’­æ”¾
    pub async fn start_live_stream(
        &mut self,
        device_id: &str,
        client_id: &str,
        options: LiveStreamOptions,
    ) -> Result<LiveStreamResponse, ConverterError> {
        // 1. éªŒè¯è®¾å¤‡è¿æ¥çŠ¶æ€
        let device = self.device_registry.devices.get(device_id)
            .ok_or(ConverterError::DeviceNotFound)?;
            
        if !matches!(device.connection_status, ConnectionStatus::Online) {
            return Err(ConverterError::DeviceOffline);
        }
        
        // 2. åˆ›å»ºæ–°çš„æµä¼šè¯
        let session_id = Uuid::new_v4();
        
        // 3. å‘è®¾å¤‡å‘é€å¼€å§‹æµå‘½ä»¤
        let stream_request = DeviceStreamRequest {
            session_id,
            quality: options.quality_preference,
            low_latency_mode: options.low_latency_mode,
            audio_enabled: options.audio_enabled,
        };
        
        self.send_device_command(device_id, DeviceCommand::StartStream(stream_request)).await?;
        
        // 4. æ³¨å†Œå®¢æˆ·ç«¯è®¢é˜…
        self.register_client_subscription(client_id, session_id).await?;
        
        Ok(LiveStreamResponse {
            session_id,
            stream_url: format!("/api/v1/stream/{}/segments", session_id),
            control_url: format!("/api/v1/playback/{}/control", session_id),
            status_url: format!("/api/v1/stream/{}/status", session_id),
            websocket_url: format!("wss://platform-server:8443/api/v1/stream/{}/events", session_id),
            estimated_latency_ms: self.estimate_latency(device_id).await,
            stream_info: StreamInfo {
                resolution: device.capabilities.max_resolution.clone(),
                frame_rate: 30.0,
                bitrate: device.capabilities.max_bitrate,
                format: VideoFormat::H264,
            },
        })
    }
    
    // å¼€å§‹å½•åƒå›æ”¾
    pub async fn start_playback(
        &mut self,
        file_id: &str,
        client_id: &str,
        options: PlaybackOptions,
    ) -> Result<PlaybackResponse, ConverterError> {
        // 1. è·å–å½•åƒæ–‡ä»¶ä¿¡æ¯
        let recording = self.recording_manager.get_recording(file_id).await?
            .ok_or(ConverterError::RecordingNotFound)?;
        
        // 2. åˆ›å»ºå›æ”¾ä¼šè¯
        let session_id = Uuid::new_v4();
        
        // 3. åˆå§‹åŒ–å›æ”¾æµ
        let playback_stream = PlaybackStream::new(
            session_id,
            recording.clone(),
            options.clone(),
        );
        
        // 4. æ³¨å†Œå®¢æˆ·ç«¯è®¢é˜…
        self.register_client_subscription(client_id, session_id).await?;
        
        // 5. å¼€å§‹åˆ†ç‰‡ä¼ è¾“
        self.start_playback_transmission(playback_stream).await?;
        
        Ok(PlaybackResponse {
            session_id,
            playback_url: format!("/api/v1/playback/{}/segments", session_id),
            control_url: format!("/api/v1/playback/{}/control", session_id),
            status_url: format!("/api/v1/playback/{}/status", session_id),
            file_info: FileInfo {
                duration: recording.duration,
                resolution: recording.resolution,
                frame_rate: recording.frame_rate,
                bitrate: recording.bitrate,
            },
        })
    }

    // QUICåˆ†ç‰‡ â†’ HTTP3åˆ†ç‰‡è½¬æ¢
    async fn convert_quic_to_http3(
        &mut self,
        quic_segment: QUICVideoSegment,
        target_clients: Vec<String>,
    ) -> Result<(), ConversionError> {
        // 1. è§£æQUICåˆ†ç‰‡
        let segment_data = self.parse_quic_segment(quic_segment)?;
        
        // 2. æ„å»ºHTTP3è¯·æ±‚
        let http3_request = HTTP3StreamRequest {
            method: "POST",
            path: format!("/api/v1/stream/{}/segments", segment_data.session_id),
            headers: vec![
                ("Content-Type", "application/octet-stream"),
                ("X-Segment-Type", "video"),
                ("X-Segment-Timestamp", &segment_data.timestamp.to_string()),
                ("X-Segment-Duration", &segment_data.duration.to_string()),
                ("X-Frame-Count", &segment_data.frame_count.to_string()),
                ("X-Is-Keyframe", &segment_data.is_keyframe.to_string()),
                ("X-Source-Device", &segment_data.device_id),
                ("X-Transmission-Delay", &self.calculate_delay(&segment_data).to_string()),
            ],
            body: segment_data.data,
        };
        
        // 3. å¹¶å‘åˆ†å‘åˆ°æ‰€æœ‰ç›®æ ‡å®¢æˆ·ç«¯
        let mut tasks = Vec::new();
        for client_id in target_clients {
            if let Some(client) = self.http3_clients.get_mut(&client_id) {
                let request = http3_request.clone();
                tasks.push(tokio::spawn(async move {
                    client.send_segment(request).await
                }));
            }
        }
        
        // 4. ç­‰å¾…æ‰€æœ‰åˆ†å‘å®Œæˆ
        let results = futures::future::join_all(tasks).await;
        self.update_conversion_stats(&results);
        
        Ok(())
    }
    
    // HTTP3æ§åˆ¶å‘½ä»¤ â†’ QUICæ§åˆ¶å‘½ä»¤è½¬æ¢
    async fn convert_http3_to_quic(
        &mut self,
        http3_control: HTTP3PlaybackControl,
        target_session: Uuid,
    ) -> Result<(), ConversionError> {
        // 1. è§£æHTTP3æ§åˆ¶å‘½ä»¤
        let control_data = self.parse_http3_control(http3_control)?;
        
        // 2. æ„å»ºQUICåè®®æ¶ˆæ¯
        let quic_message = ProtocolMessage {
            message_type: MessageType::PlaybackControl,
            payload: serde_json::to_vec(&control_data.command)?,
            sequence_number: self.generate_sequence_number(),
            timestamp: SystemTime::now(),
            session_id: target_session,
        };
        
        // 3. å‘é€åˆ°ç›®æ ‡è®¾å¤‡
        if let Some(session) = self.quic_sessions.get_mut(&target_session) {
            session.send_control_message(quic_message).await?;
        }
        
        Ok(())
    }
}
```

#### 4.2.2 åˆ†å‘ç®¡ç†å™¨ (Distribution Manager)

```rust
pub struct DistributionManager {
    active_streams: HashMap<Uuid, StreamInfo>,
    client_subscriptions: HashMap<String, Vec<Uuid>>,
    distribution_stats: DistributionStats,
    load_balancer: LoadBalancer,
}

#[derive(Debug, Clone)]
pub struct StreamInfo {
    pub session_id: Uuid,
    pub device_id: String,
    pub stream_type: StreamType,
    pub subscribers: Vec<String>,
    pub quality_levels: Vec<QualityLevel>,
    pub current_bitrate: u64,
    pub buffer_health: BufferHealth,
}

impl DistributionManager {
    // å¤šè·¯åˆ†å‘æ ¸å¿ƒé€»è¾‘
    async fn distribute_segment(
        &mut self,
        segment: VideoSegment,
        source_session: Uuid,
    ) -> Result<DistributionResult, DistributionError> {
        let start_time = Instant::now();
        
        // 1. è·å–è®¢é˜…è¯¥æµçš„æ‰€æœ‰å®¢æˆ·ç«¯
        let subscribers = self.get_stream_subscribers(source_session)?;
        if subscribers.is_empty() {
            return Ok(DistributionResult::NoSubscribers);
        }
        
        // 2. æ ¹æ®å®¢æˆ·ç«¯èƒ½åŠ›è¿›è¡Œè´¨é‡é€‚é…
        let adapted_segments = self.adapt_segment_quality(&segment, &subscribers).await?;
        
        // 3. å¹¶å‘åˆ†å‘åˆ°æ‰€æœ‰è®¢é˜…å®¢æˆ·ç«¯
        let mut distribution_tasks = Vec::new();
        
        for (client_id, adapted_segment) in adapted_segments {
            let client_id_clone = client_id.clone();
            let segment_clone = adapted_segment.clone();
            
            distribution_tasks.push(tokio::spawn(async move {
                let send_start = Instant::now();
                let result = self.send_to_client(&client_id_clone, segment_clone).await;
                let send_duration = send_start.elapsed();
                
                DistributionTask {
                    client_id: client_id_clone,
                    result,
                    duration: send_duration,
                }
            }));
        }
        
        // 4. æ”¶é›†åˆ†å‘ç»“æœ
        let task_results = futures::future::join_all(distribution_tasks).await;
        let distribution_duration = start_time.elapsed();
        
        // 5. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        self.update_distribution_stats(&task_results, distribution_duration);
        
        // 6. æ£€æŸ¥åˆ†å‘è´¨é‡å¹¶è°ƒæ•´ç­–ç•¥
        self.adjust_distribution_strategy(&task_results).await?;
        
        Ok(DistributionResult::Success {
            distributed_count: task_results.len(),
            total_duration: distribution_duration,
            average_client_latency: self.calculate_average_latency(&task_results),
        })
    }
    
    // è‡ªé€‚åº”è´¨é‡è°ƒæ•´
    async fn adapt_segment_quality(
        &self,
        segment: &VideoSegment,
        subscribers: &[String],
    ) -> Result<Vec<(String, VideoSegment)>, DistributionError> {
        let mut adapted_segments = Vec::new();
        
        for client_id in subscribers {
            if let Some(client_capability) = self.get_client_capability(client_id) {
                let adapted_segment = match client_capability.max_bitrate {
                    bitrate if bitrate >= 5_000_000 => {
                        // é«˜è´¨é‡å®¢æˆ·ç«¯ï¼šåŸå§‹è´¨é‡
                        segment.clone()
                    }
                    bitrate if bitrate >= 2_000_000 => {
                        // ä¸­ç­‰è´¨é‡å®¢æˆ·ç«¯ï¼šé€‚åº¦å‹ç¼©
                        self.compress_segment(segment, 0.7).await?
                    }
                    _ => {
                        // ä½è´¨é‡å®¢æˆ·ç«¯ï¼šå¤§å¹…å‹ç¼©
                        self.compress_segment(segment, 0.4).await?
                    }
                };
                
                adapted_segments.push((client_id.clone(), adapted_segment));
            }
        }
        
        Ok(adapted_segments)
    }
}
```

#### 4.2.3 å»¶è¿Ÿç›‘æ§å™¨ (Latency Monitor)

```rust
pub struct LatencyMonitor {
    device_timestamps: HashMap<Uuid, DeviceTimestamp>,
    platform_timestamps: HashMap<Uuid, PlatformTimestamp>,
    latency_history: VecDeque<LatencyMeasurement>,
    alert_thresholds: LatencyThresholds,
}

#[derive(Debug, Clone)]
pub struct LatencyMeasurement {
    pub session_id: Uuid,
    pub segment_id: Uuid,
    pub device_timestamp: SystemTime,      // è®¾å¤‡ç«¯å‘é€æ—¶é—´
    pub platform_receive_timestamp: SystemTime, // å¹³å°ç«¯æ¥æ”¶æ—¶é—´
    pub platform_forward_timestamp: SystemTime, // å¹³å°ç«¯è½¬å‘æ—¶é—´
    pub end_to_end_latency: Duration,      // ç«¯åˆ°ç«¯å»¶è¿Ÿ
    pub platform_processing_latency: Duration, // å¹³å°å¤„ç†å»¶è¿Ÿ
}

impl LatencyMonitor {
    // å»¶è¿Ÿæµ‹é‡æ ¸å¿ƒé€»è¾‘
    pub fn measure_latency(
        &mut self,
        segment: &VideoSegment,
        receive_time: SystemTime,
    ) -> Result<LatencyMeasurement, MonitorError> {
        // 1. æå–è®¾å¤‡ç«¯æ—¶é—´æˆ³ï¼ˆä»åˆ†ç‰‡å¤´éƒ¨ï¼‰
        let device_timestamp = SystemTime::UNIX_EPOCH + 
            Duration::from_secs_f64(segment.timestamp);
        
        // 2. è®°å½•å¹³å°ç«¯æ¥æ”¶æ—¶é—´
        let platform_receive_timestamp = receive_time;
        
        // 3. è®¡ç®—ä¼ è¾“å»¶è¿Ÿ
        let transmission_latency = platform_receive_timestamp
            .duration_since(device_timestamp)
            .unwrap_or_default();
        
        // 4. åˆ›å»ºå»¶è¿Ÿæµ‹é‡è®°å½•
        let measurement = LatencyMeasurement {
            session_id: segment.session_id,
            segment_id: segment.id,
            device_timestamp,
            platform_receive_timestamp,
            platform_forward_timestamp: SystemTime::now(), // å°†åœ¨è½¬å‘æ—¶æ›´æ–°
            end_to_end_latency: transmission_latency,
            platform_processing_latency: Duration::from_millis(0), // å°†åœ¨å¤„ç†å®Œæˆæ—¶æ›´æ–°
        };
        
        // 5. å­˜å‚¨æµ‹é‡ç»“æœ
        self.latency_history.push_back(measurement.clone());
        
        // 6. ä¿æŒå†å²è®°å½•å¤§å°é™åˆ¶
        if self.latency_history.len() > 1000 {
            self.latency_history.pop_front();
        }
        
        // 7. æ£€æŸ¥å»¶è¿Ÿé˜ˆå€¼å‘Šè­¦
        self.check_latency_alerts(&measurement)?;
        
        Ok(measurement)
    }
    
    // å»¶è¿Ÿç»Ÿè®¡åˆ†æ
    pub fn get_latency_statistics(&self, duration: Duration) -> LatencyStatistics {
        let cutoff_time = SystemTime::now() - duration;
        
        let recent_measurements: Vec<&LatencyMeasurement> = self.latency_history
            .iter()
            .filter(|m| m.platform_receive_timestamp >= cutoff_time)
            .collect();
        
        if recent_measurements.is_empty() {
            return LatencyStatistics::default();
        }
        
        let latencies: Vec<Duration> = recent_measurements
            .iter()
            .map(|m| m.end_to_end_latency)
            .collect();
        
        let total_latency: Duration = latencies.iter().sum();
        let average_latency = total_latency / latencies.len() as u32;
        
        let mut sorted_latencies = latencies.clone();
        sorted_latencies.sort();
        
        let p50_latency = sorted_latencies[sorted_latencies.len() / 2];
        let p95_latency = sorted_latencies[sorted_latencies.len() * 95 / 100];
        let p99_latency = sorted_latencies[sorted_latencies.len() * 99 / 100];
        
        LatencyStatistics {
            sample_count: recent_measurements.len(),
            average_latency,
            min_latency: *sorted_latencies.first().unwrap(),
            max_latency: *sorted_latencies.last().unwrap(),
            p50_latency,
            p95_latency,
            p99_latency,
            measurements_above_threshold: recent_measurements
                .iter()
                .filter(|m| m.end_to_end_latency > self.alert_thresholds.warning_threshold)
                .count(),
        }
    }
}
```

### 4.3 ç¼“å­˜ç®¡ç†ç­–ç•¥ï¼ˆDemoç‰ˆæœ¬ç®€åŒ–ï¼‰

**Demoç‰ˆæœ¬ç‰¹ç‚¹**ï¼š
- å•æœºæœ¬åœ°ç¼“å­˜ï¼Œä½¿ç”¨å†…å­˜LRU Cache
- æ— éœ€Redisç­‰åˆ†å¸ƒå¼ç¼“å­˜
- è§†é¢‘åˆ†ç‰‡ç¼“å­˜åœ¨æœ¬åœ°ç£ç›˜

```rust
pub struct CacheManager {
    // Demoç‰ˆæœ¬ï¼šç®€åŒ–çš„æœ¬åœ°å†…å­˜ç¼“å­˜
    segment_cache: LRUCache<Uuid, CachedSegment>,  // æœ€è¿‘åˆ†ç‰‡ç¼“å­˜
    keyframe_cache: HashMap<Uuid, Vec<CachedSegment>>,  // å…³é”®å¸§ç´¢å¼•
    cache_stats: CacheStatistics,
    cache_policy: CachePolicy,
    max_cache_size: usize,  // æœ€å¤§ç¼“å­˜å¤§å°ï¼ˆå­—èŠ‚ï¼‰
}

#[derive(Debug, Clone)]
pub struct CachedSegment {
    pub segment: VideoSegment,
    pub cache_time: SystemTime,
    pub access_count: u64,
    pub last_access: SystemTime,
    // Demoç‰ˆæœ¬ç§»é™¤ï¼šquality_variantsï¼ˆä¸æ”¯æŒå¤šè´¨é‡ï¼‰
}

impl CacheManager {
    // Demoç‰ˆæœ¬ï¼šç®€åŒ–çš„ç¼“å­˜ç­–ç•¥
    pub async fn cache_segment(
        &mut self,
        segment: VideoSegment,
    ) -> Result<(), CacheError> {
        // 1. æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ¶
        if self.get_cache_size() >= self.max_cache_size {
            // LRUè‡ªåŠ¨æ·˜æ±°æœ€æ—§çš„æ¡ç›®
            self.evict_oldest();
        }
        
        // 2. Demoç‰ˆæœ¬ï¼šåªç¼“å­˜å…³é”®å¸§å’Œæœ€è¿‘çš„åˆ†ç‰‡
        let should_cache = segment.is_keyframe || 
            self.is_recent_segment(&segment);
        
        if should_cache {
            // 3. åˆ›å»ºç¼“å­˜æ¡ç›®ï¼ˆDemoç‰ˆæœ¬ï¼šæ— è´¨é‡å˜ä½“ï¼‰
            let cached_segment = CachedSegment {
                segment: segment.clone(),
                cache_time: SystemTime::now(),
                access_count: 0,
                last_access: SystemTime::now(),
            };
            
            // 4. å­˜å‚¨åˆ°ç¼“å­˜
            self.segment_cache.put(segment.id, cached_segment);
            
            // 5. å…³é”®å¸§é¢å¤–ç´¢å¼•
            if segment.is_keyframe {
                self.keyframe_cache
                    .entry(segment.session_id)
                    .or_insert_with(Vec::new)
                    .push(cached_segment.clone());
            }
            
            // 6. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            self.cache_stats.total_cached += 1;
            self.cache_stats.cache_size_bytes += segment.data.len() as u64;
        }
        
        Ok(())
    }
    
    // Demoç‰ˆæœ¬ï¼šç®€åŒ–çš„ç¼“å­˜è·å–
    pub fn get_cached_segment(
        &mut self,
        segment_id: Uuid,
    ) -> Option<VideoSegment> {
        if let Some(cached) = self.segment_cache.get_mut(&segment_id) {
            // æ›´æ–°è®¿é—®ç»Ÿè®¡
            cached.access_count += 1;
            cached.last_access = SystemTime::now();
            self.cache_stats.cache_hits += 1;
            
            // Demoç‰ˆæœ¬ï¼šç›´æ¥è¿”å›åŸå§‹åˆ†ç‰‡
            Some(cached.segment.clone())
        } else {
            self.cache_stats.cache_misses += 1;
            None
        }
    }
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºæœ€è¿‘çš„åˆ†ç‰‡ï¼ˆæœ€è¿‘30ç§’ï¼‰
    fn is_recent_segment(&self, segment: &VideoSegment) -> bool {
        let segment_time = SystemTime::UNIX_EPOCH + 
            Duration::from_secs_f64(segment.timestamp);
        let age = SystemTime::now()
            .duration_since(segment_time)
            .unwrap_or_default();
        age < Duration::from_secs(30)
    }
    
    // è·å–å½“å‰ç¼“å­˜å¤§å°
    fn get_cache_size(&self) -> usize {
        self.cache_stats.cache_size_bytes as usize
    }
    
    // æ·˜æ±°æœ€æ—§çš„ç¼“å­˜æ¡ç›®
    fn evict_oldest(&mut self) {
        // LRU Cacheä¼šè‡ªåŠ¨æ·˜æ±°
        self.cache_stats.evictions += 1;
    }
}
```

## 5. ç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾è¯¦ç»†è®¾è®¡ï¼ˆç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆï¼‰

**è®¾è®¡ç†å¿µ**ï¼šæœ¬èŠ‚æè¿°åŸºäºç»Ÿä¸€ä½å»¶è¿Ÿæ¶æ„çš„ç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾å®ç°æ–¹æ¡ˆã€‚ä¸¤ç§æ¨¡å¼å…±äº«ç›¸åŒçš„æµå¤„ç†å™¨ã€ä¼ è¾“åè®®å’Œæ’­æ”¾å™¨ï¼Œä»…åœ¨æ•°æ®æºå±‚é¢æœ‰æ‰€åŒºåˆ«ã€‚

### 5.1 ç»Ÿä¸€æµå¤„ç†æ¶æ„

#### 5.1.1 æ ¸å¿ƒç»„ä»¶

```rust
// ç»Ÿä¸€æµå¤„ç†å™¨
pub struct UnifiedStreamHandler {
    active_sessions: HashMap<Uuid, StreamSession>,
    zero_buffer_mode: bool,
}

// æµä¼šè¯
pub struct StreamSession {
    pub session_id: Uuid,
    pub source: Box<dyn StreamSource>,  // æ•°æ®æºæŠ½è±¡
    pub config: StreamConfig,
    pub state: StreamState,
    pub stats: StreamStats,
}

// æ•°æ®æºæŠ½è±¡æ¥å£
#[async_trait]
pub trait StreamSource: Send + Sync {
    async fn next_segment(&mut self) -> Result<Option<VideoSegment>, StreamError>;
    async fn seek(&mut self, position: f64) -> Result<(), StreamError>;
    async fn set_rate(&mut self, rate: f64) -> Result<(), StreamError>;
    async fn pause(&mut self) -> Result<(), StreamError>;
    async fn resume(&mut self) -> Result<(), StreamError>;
    fn get_info(&self) -> StreamInfo;
}

// ç›´é€šæ’­æ”¾æ•°æ®æº
pub struct LiveStreamSource {
    device_id: String,
    quic_receiver: Receiver<VideoSegment>,
}

// å½•åƒå›æ”¾æ•°æ®æº
pub struct PlaybackSource {
    file_reader: FileStreamReader,
    playback_rate: f64,
}
```

#### 5.1.2 ç»Ÿä¸€å¤„ç†æµç¨‹

```mermaid
graph TB
    subgraph æ•°æ®æºå±‚
        D1[è®¾å¤‡ç«¯å®æ—¶æµ<br/>LiveStreamSource]
        D2[æ–‡ä»¶ç³»ç»Ÿ<br/>PlaybackSource]
    end
    
    subgraph ç»Ÿä¸€å¤„ç†å±‚
        U[UnifiedStreamHandler]
        Z[é›¶ç¼“å†²è½¬å‘<br/>&lt;5mså¤„ç†å»¶è¿Ÿ]
    end
    
    subgraph ä¼ è¾“å±‚
        H[HTTP3/SSEä¼ è¾“]
    end
    
    subgraph å‰ç«¯å±‚
        M[UnifiedMSEPlayer]
        B[æ™ºèƒ½ç¼“å†²ç­–ç•¥]
    end
    
    D1 -->|å®ç°StreamSource| U
    D2 -->|å®ç°StreamSource| U
    U --> Z
    Z --> H
    H --> M
    M --> B
    
    style D1 fill:#e1f5ff
    style D2 fill:#e1f5ff
    style U fill:#fff3e0
    style Z fill:#ffccbc
    style H fill:#c5e1a5
    style M fill:#f3e5f5
```

### 5.2 ç›´é€šæ’­æ”¾æµç¨‹

```mermaid
sequenceDiagram
    participant F as Frontend
    participant P as Platform
    participant D as Device
    
    Note over F,D: 1. å¯åŠ¨ç›´é€šæ’­æ”¾ï¼ˆç»Ÿä¸€APIï¼‰
    F->>P: POST /api/v1/stream/start<br/>{mode: "live", source: {device_id}}
    P->>P: åˆ›å»ºLiveStreamSource
    P->>P: UnifiedStreamHandler.start_stream()
    P->>D: QUIC: FileRequest (stream_type: "live")
    D->>P: QUIC: StatusResponse (å‡†å¤‡å°±ç»ª)
    P->>F: HTTP3: {session_id, stream_url}
    
    Note over F,D: 2. å»ºç«‹SSEè¿æ¥
    F->>P: GET /api/v1/stream/{session_id}/segments
    P->>F: HTTP3: SSEè¿æ¥å»ºç«‹
    
    Note over F,D: 3. é›¶ç¼“å†²è½¬å‘ï¼ˆ<5mså¤„ç†å»¶è¿Ÿï¼‰
    loop å®æ—¶è§†é¢‘æµ
        D->>P: QUIC: VideoSegment
        P->>P: é›¶ç¼“å†²è½¬å‘ï¼ˆç«‹å³å¤„ç†ï¼‰
        P->>F: HTTP3/SSE: VideoSegment
        F->>F: MSEæ’­æ”¾ï¼ˆæœ€å°ç¼“å†²100-500msï¼‰
    end
    
    Note over F,D: 4. æ’­æ”¾æ§åˆ¶
    F->>P: POST /api/v1/stream/{session_id}/control<br/>{command: "pause"}
    P->>D: QUIC: PauseRequest
    D->>P: QUIC: StatusResponse
    P->>F: HTTP3: {status: "paused"}
    
    Note over F,D: 5. åœæ­¢æ’­æ”¾
    F->>P: POST /api/v1/stream/{session_id}/control<br/>{command: "stop"}
    P->>D: QUIC: SessionEnd
    P->>F: HTTP3: {status: "stopped"}
```

**ç›´é€šæ’­æ”¾å»¶è¿Ÿåˆ†è§£**ï¼š
```
é‡‡é›†å»¶è¿Ÿ:     10ms  (è®¾å¤‡ç«¯)
ç¼–ç å»¶è¿Ÿ:     10ms  (H.264ç¼–ç )
QUICä¼ è¾“:     15ms  (è®¾å¤‡â†’å¹³å°)
å¹³å°å¤„ç†:      3ms  (é›¶ç¼“å†²è½¬å‘)
HTTP3ä¼ è¾“:    15ms  (å¹³å°â†’å‰ç«¯)
å‰ç«¯æ¥æ”¶:      5ms  (SSE)
MSEè¿½åŠ :      10ms  (SourceBuffer)
è§£ç æ¸²æŸ“:     20ms  (ç¡¬ä»¶åŠ é€Ÿ)
ç¼“å†²å»¶è¿Ÿ:    100ms  (æœ€å°ç¼“å†²)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ€»å»¶è¿Ÿ:      188ms  âœ… (ç›®æ ‡<200ms)
```

### 5.3 å½•åƒå›æ”¾æµç¨‹ï¼ˆç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆï¼‰

```mermaid
sequenceDiagram
    participant F as Frontend
    participant P as Platform
    participant FS as FileSystem
    
    Note over F,FS: 1. å¯åŠ¨å½•åƒå›æ”¾ï¼ˆç»Ÿä¸€APIï¼‰
    F->>P: POST /api/v1/stream/start<br/>{mode: "playback", source: {file_id, start_position}}
    P->>P: åˆ›å»ºPlaybackSource
    P->>P: UnifiedStreamHandler.start_stream()
    P->>FS: æ‰“å¼€FileStreamReader
    FS->>P: æ–‡ä»¶æµå°±ç»ª
    P->>F: HTTP3: {session_id, stream_url}
    
    Note over F,FS: 2. å»ºç«‹SSEè¿æ¥
    F->>P: GET /api/v1/stream/{session_id}/segments
    P->>F: HTTP3: SSEè¿æ¥å»ºç«‹
    
    Note over F,FS: 3. æ–‡ä»¶æµå¼è¯»å–ï¼ˆå°åˆ†ç‰‡8KBï¼‰
    loop æ–‡ä»¶æµå¼ä¼ è¾“
        P->>FS: è¯»å–å°åˆ†ç‰‡ï¼ˆ8KBï¼‰
        FS->>P: åˆ†ç‰‡æ•°æ®
        P->>P: é€Ÿç‡æ§åˆ¶ï¼ˆæ ¹æ®playback_rateï¼‰
        P->>F: HTTP3/SSE: VideoSegment
        F->>F: MSEæ’­æ”¾ï¼ˆç¼“å†²500-2000msï¼‰
    end
    
    Note over F,FS: 4. æ’­æ”¾æ§åˆ¶ - å®šä½
    F->>P: POST /api/v1/stream/{session_id}/control<br/>{command: "seek", position: 30.0}
    P->>FS: FileReader.seek_to(30.0)
    FS->>P: å®šä½æˆåŠŸ
    P->>F: HTTP3: {status: "seeking"}
    P->>F: HTTP3/SSE: VideoSegment (30sä½ç½®)
    
    Note over F,FS: 5. æ’­æ”¾æ§åˆ¶ - å€é€Ÿ
    F->>P: POST /api/v1/stream/{session_id}/control<br/>{command: "set_rate", rate: 2.0}
    P->>P: è°ƒæ•´å‘é€é—´éš”ï¼ˆ16.5msï¼‰
    P->>F: HTTP3: {status: "rate_changed", rate: 2.0}
    
    Note over F,FS: 6. åœæ­¢å›æ”¾
    F->>P: POST /api/v1/stream/{session_id}/control<br/>{command: "stop"}
    P->>FS: å…³é—­æ–‡ä»¶æµ
    P->>F: HTTP3: {status: "stopped"}
```

**å½•åƒå›æ”¾å»¶è¿Ÿåˆ†è§£**ï¼š
```
æ–‡ä»¶è¯»å–:      5ms  (å°åˆ†ç‰‡8KB)
åˆ†ç‰‡å¤„ç†:      2ms  (é›¶æ‹·è´)
HTTP3ä¼ è¾“:    15ms  (QUICåè®®)
å‰ç«¯æ¥æ”¶:      5ms  (SSE)
MSEè¿½åŠ :      10ms  (SourceBuffer)
è§£ç æ¸²æŸ“:     20ms  (ç¡¬ä»¶åŠ é€Ÿ)
ç¼“å†²å»¶è¿Ÿ:     50ms  (æœ€å°ç¼“å†²)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ€»å»¶è¿Ÿ:      107ms  âœ… (ç›®æ ‡<200ms)
```

**å»¶è¿Ÿå¯¹æ¯”**ï¼š

| æ–¹æ¡ˆ | ç›´é€šæ’­æ”¾ | å½•åƒå›æ”¾ | æ”¹å–„ |
|------|---------|---------|------|
| **æ—§æ–¹æ¡ˆ** | æœªå®ç° | 1000-2000ms | - |
| **æ–°æ–¹æ¡ˆ** | 188ms | 107ms | **10å€æå‡** âœ… |

### 5.5 æ•°æ®æºå®ç°

#### 5.5.1 StreamSource Trait

```rust
// æ•°æ®æºæŠ½è±¡æ¥å£
#[async_trait]
pub trait StreamSource: Send + Sync {
    /// è·å–ä¸‹ä¸€ä¸ªè§†é¢‘åˆ†ç‰‡
    async fn next_segment(&mut self) -> Result<Option<VideoSegment>, StreamError>;
    
    /// å®šä½åˆ°æŒ‡å®šæ—¶é—´ä½ç½®
    async fn seek(&mut self, position: f64) -> Result<(), StreamError>;
    
    /// è®¾ç½®æ’­æ”¾é€Ÿç‡
    async fn set_rate(&mut self, rate: f64) -> Result<(), StreamError>;
    
    /// æš‚åœ
    async fn pause(&mut self) -> Result<(), StreamError>;
    
    /// æ¢å¤
    async fn resume(&mut self) -> Result<(), StreamError>;
    
    /// è·å–æµä¿¡æ¯
    fn get_info(&self) -> StreamInfo;
}
```

#### 5.5.2 LiveStreamSourceå®ç°

```rust
pub struct LiveStreamSource {
    device_id: String,
    quic_receiver: Receiver<VideoSegment>,
    state: SourceState,
}

#[async_trait]
impl StreamSource for LiveStreamSource {
    async fn next_segment(&mut self) -> Result<Option<VideoSegment>, StreamError> {
        // ä»QUICæ¥æ”¶å™¨è·å–å®æ—¶åˆ†ç‰‡
        match self.quic_receiver.recv().await {
            Some(segment) => Ok(Some(segment)),
            None => Ok(None),
        }
    }
    
    async fn seek(&mut self, _position: f64) -> Result<(), StreamError> {
        // ç›´é€šæ’­æ”¾ä¸æ”¯æŒå®šä½
        Err(StreamError::OperationNotSupported)
    }
    
    async fn set_rate(&mut self, _rate: f64) -> Result<(), StreamError> {
        // ç›´é€šæ’­æ”¾ä¸æ”¯æŒå€é€Ÿ
        Err(StreamError::OperationNotSupported)
    }
    
    async fn pause(&mut self) -> Result<(), StreamError> {
        self.state = SourceState::Paused;
        // é€šçŸ¥è®¾å¤‡ç«¯æš‚åœ
        Ok(())
    }
    
    async fn resume(&mut self) -> Result<(), StreamError> {
        self.state = SourceState::Streaming;
        // é€šçŸ¥è®¾å¤‡ç«¯æ¢å¤
        Ok(())
    }
    
    fn get_info(&self) -> StreamInfo {
        StreamInfo {
            mode: StreamMode::Live { device_id: self.device_id.clone() },
            supports_seek: false,
            supports_rate_change: false,
        }
    }
}
```

#### 5.5.3 PlaybackSourceå®ç°

```rust
pub struct PlaybackSource {
    file_reader: FileStreamReader,
    playback_rate: f64,
    state: SourceState,
}

#[async_trait]
impl StreamSource for PlaybackSource {
    async fn next_segment(&mut self) -> Result<Option<VideoSegment>, StreamError> {
        // ä»æ–‡ä»¶è¯»å–å™¨è·å–åˆ†ç‰‡
        self.file_reader.read_segment().await
    }
    
    async fn seek(&mut self, position: f64) -> Result<(), StreamError> {
        // å®šä½åˆ°æŒ‡å®šä½ç½®
        self.file_reader.seek_to(position).await
    }
    
    async fn set_rate(&mut self, rate: f64) -> Result<(), StreamError> {
        // è®¾ç½®æ’­æ”¾é€Ÿç‡
        self.playback_rate = rate;
        self.file_reader.set_rate(rate).await
    }
    
    async fn pause(&mut self) -> Result<(), StreamError> {
        self.state = SourceState::Paused;
        Ok(())
    }
    
    async fn resume(&mut self) -> Result<(), StreamError> {
        self.state = SourceState::Streaming;
        Ok(())
    }
    
    fn get_info(&self) -> StreamInfo {
        StreamInfo {
            mode: StreamMode::Playback { 
                file_id: self.file_reader.file_id.clone(),
                playback_rate: self.playback_rate,
            },
            supports_seek: true,
            supports_rate_change: true,
        }
    }
}
```

### 5.6 æ–‡ä»¶æµå¼è¯»å–å™¨å®ç°

```rust
pub struct FileStreamReader {
    file: File,
    file_id: String,
    current_position: u64,
    playback_rate: f64,
    segment_size: usize,  // 8KBå°åˆ†ç‰‡
    state: ReaderState,
}

impl FileStreamReader {
    pub async fn new(file_path: PathBuf, file_id: String) -> Result<Self, StreamError> {
        let file = File::open(file_path).await?;
        
        Ok(Self {
            file,
            file_id,
            current_position: 0,
            playback_rate: 1.0,
            segment_size: 8192,  // 8KB
            state: ReaderState::Ready,
        })
    }
    
    // è¯»å–å°åˆ†ç‰‡
    pub async fn read_segment(&mut self) -> Result<Option<VideoSegment>, StreamError> {
        if self.state == ReaderState::Paused {
            // æš‚åœçŠ¶æ€ï¼Œç­‰å¾…æ¢å¤
            tokio::time::sleep(Duration::from_millis(100)).await;
            return Ok(None);
        }
        
        // è¯»å–å°åˆ†ç‰‡
        let mut buffer = vec![0u8; self.segment_size];
        let bytes_read = self.file.read(&mut buffer).await?;
        
        if bytes_read == 0 {
            return Ok(None);  // æ–‡ä»¶ç»“æŸ
        }
        
        buffer.truncate(bytes_read);
        
        // åˆ›å»ºè§†é¢‘åˆ†ç‰‡
        let segment = VideoSegment::new(
            buffer,
            self.current_position as f64 / 30.0,  // å‡è®¾30fps
            false,
        );
        
        // é€Ÿç‡æ§åˆ¶
        let frame_duration = Duration::from_millis(33);  // 30fps
        let adjusted_duration = frame_duration.div_f64(self.playback_rate);
        tokio::time::sleep(adjusted_duration).await;
        
        self.current_position += bytes_read as u64;
        
        Ok(Some(segment))
    }
    
    // å®šä½åˆ°æŒ‡å®šæ—¶é—´
    pub async fn seek_to(&mut self, position: f64) -> Result<(), StreamError> {
        // è®¡ç®—æ–‡ä»¶åç§»é‡ï¼ˆç®€åŒ–å®ç°ï¼‰
        let offset = (position * 30.0 * self.segment_size as f64) as u64;
        
        self.file.seek(SeekFrom::Start(offset)).await?;
        self.current_position = offset;
        
        Ok(())
    }
    
    // è®¾ç½®æ’­æ”¾é€Ÿç‡
    pub async fn set_rate(&mut self, rate: f64) -> Result<(), StreamError> {
        if rate < 0.25 || rate > 4.0 {
            return Err(StreamError::InvalidPlaybackRate);
        }
        
        self.playback_rate = rate;
        Ok(())
    }
}
```

### 5.7 æ€§èƒ½ä¼˜åŒ–å®ç°

#### 5.7.1 é›¶æ‹·è´ä¼ è¾“

```rust
// ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯å‡å°‘å†…å­˜å¤åˆ¶
pub async fn send_segment_zero_copy(
    stream: &mut SendStream,
    segment: &VideoSegment,
) -> Result<(), StreamError> {
    // ä½¿ç”¨IoSliceé¿å…å†…å­˜å¤åˆ¶
    stream.write_all_vectored(&[
        IoSlice::new(&segment.header_bytes()),
        IoSlice::new(&segment.data),
    ]).await?;
    
    Ok(())
}
```

#### 5.7.2 å¹¶å‘è½¬å‘

```rust
// å¹¶å‘è½¬å‘åˆ°å¤šä¸ªå®¢æˆ·ç«¯
pub async fn forward_to_clients(
    &self,
    session_id: Uuid,
    segment: VideoSegment,
) -> Result<(), StreamError> {
    let clients = self.get_session_clients(session_id)?;
    
    // å¹¶å‘å‘é€
    let tasks: Vec<_> = clients.iter()
        .map(|client| {
            let segment = segment.clone();
            async move {
                client.send_segment(segment).await
            }
        })
        .collect();
    
    futures::future::join_all(tasks).await;
    
    Ok(())
}
```

### 5.8 ç»Ÿä¸€æ–¹æ¡ˆæ€»ç»“

**æ¶æ„ä¼˜åŠ¿**ï¼š
1. âœ… **ä»£ç å¤ç”¨**: ç›´é€šå’Œå›æ”¾å…±äº«UnifiedStreamHandlerã€HTTP3ä¼ è¾“ã€MSEæ’­æ”¾å™¨
2. âœ… **ä¸€è‡´ä½“éªŒ**: ç”¨æˆ·åœ¨ä¸¤ç§æ¨¡å¼é—´åˆ‡æ¢æ— æ„ŸçŸ¥
3. âœ… **æ˜“äºç»´æŠ¤**: å•ä¸€ä»£ç è·¯å¾„ï¼Œé™ä½ç»´æŠ¤æˆæœ¬
4. âœ… **æ˜“äºæ‰©å±•**: æ–°åŠŸèƒ½ï¼ˆå¤šéŸ³è½¨ã€å­—å¹•ï¼‰åªéœ€å®ç°ä¸€æ¬¡

**æ€§èƒ½æå‡**ï¼š
1. âœ… **å½•åƒå›æ”¾å»¶è¿Ÿ**: ä»2000msé™åˆ°107msï¼ˆ**18å€æå‡**ï¼‰
2. âœ… **ç›´é€šæ’­æ”¾å»¶è¿Ÿ**: 188msï¼ˆæ»¡è¶³<200msç›®æ ‡ï¼‰
3. âœ… **å¹³å°ç«¯å¤„ç†**: <5msï¼ˆé›¶ç¼“å†²è½¬å‘ï¼‰
4. âœ… **é«˜å¹¶å‘**: æ”¯æŒ100+å¹¶å‘æµä¼šè¯

**å®ç°ç®€åŒ–**ï¼š
1. âœ… **ç»Ÿä¸€API**: å•ä¸€å¯åŠ¨ç«¯ç‚¹ï¼Œå•ä¸€æ§åˆ¶ç«¯ç‚¹
2. âœ… **ç»Ÿä¸€æ’­æ”¾å™¨**: å‰ç«¯åªéœ€ä¸€ä¸ªMSEæ’­æ”¾å™¨
3. âœ… **ç»Ÿä¸€ç›‘æ§**: å»¶è¿Ÿç›‘æ§å’Œç»Ÿè®¡é€»è¾‘å¤ç”¨

### 5.4 ç»Ÿä¸€æµå¤„ç†å™¨å®ç°

```rust
// ç»Ÿä¸€æµå¤„ç†å™¨ï¼ˆæ›¿ä»£åŸæœ‰çš„LiveStreamHandlerå’ŒPlaybackHandlerï¼‰
pub struct UnifiedStreamHandler {
    active_sessions: HashMap<Uuid, StreamSession>,
    zero_buffer_mode: bool,
}

pub struct StreamSession {
    pub session_id: Uuid,
    pub source: Box<dyn StreamSource>,  // æ•°æ®æºæŠ½è±¡
    pub config: StreamConfig,
    pub state: StreamState,
    pub stats: StreamStats,
    pub created_at: SystemTime,
}

pub struct StreamConfig {
    pub mode: StreamMode,
    pub low_latency: bool,
    pub target_latency_ms: u32,
    pub buffer_config: BufferConfig,
}

pub enum StreamMode {
    Live { device_id: String },
    Playback { file_id: String, playback_rate: f64 },
}

impl UnifiedStreamHandler {
    // ç»Ÿä¸€çš„æµå¯åŠ¨æ–¹æ³•
    pub async fn start_stream(
        &mut self,
        source: Box<dyn StreamSource>,
        config: StreamConfig,
    ) -> Result<StreamResponse, StreamError> {
        let session_id = Uuid::new_v4();
        
        let session = StreamSession {
            session_id,
            source,
            config: config.clone(),
            state: StreamState::Initializing,
            stats: StreamStats::new(),
            created_at: SystemTime::now(),
        };
        
        self.active_sessions.insert(session_id, session);
        
        // å¯åŠ¨é›¶ç¼“å†²è½¬å‘
        if self.zero_buffer_mode {
            self.start_zero_buffer_forwarding(session_id).await?;
        }
        
        Ok(StreamResponse {
            session_id,
            stream_url: format!("/api/v1/stream/{}/segments", session_id),
            control_url: format!("/api/v1/stream/{}/control", session_id),
            estimated_latency_ms: config.target_latency_ms,
        })
    }
    
    // é›¶ç¼“å†²è½¬å‘ï¼ˆç»Ÿä¸€å¤„ç†ç›´é€šå’Œå›æ”¾ï¼‰
    async fn start_zero_buffer_forwarding(
        &mut self,
        session_id: Uuid,
    ) -> Result<(), StreamError> {
        let session = self.active_sessions.get_mut(&session_id)
            .ok_or(StreamError::SessionNotFound)?;
        
        tokio::spawn(async move {
            while let Some(segment) = session.source.next_segment().await? {
                let receive_time = SystemTime::now();
                
                // ç«‹å³è½¬å‘åˆ°æ‰€æœ‰å®¢æˆ·ç«¯
                self.forward_to_clients(session_id, segment).await?;
                
                // ç›‘æ§å¤„ç†å»¶è¿Ÿ
                let processing_latency = SystemTime::now()
                    .duration_since(receive_time)
                    .unwrap_or_default();
                
                if processing_latency > Duration::from_millis(5) {
                    warn!("High processing latency: {:?} for session {}", 
                          processing_latency, session_id);
                }
                
                // æ›´æ–°ç»Ÿè®¡
                session.stats.update_latency(processing_latency);
            }
            
            Ok::<(), StreamError>(())
        });
        
        Ok(())
    }
    
    // æ’­æ”¾æ§åˆ¶ï¼ˆç»Ÿä¸€æ¥å£ï¼‰
    pub async fn control_stream(
        &mut self,
        session_id: Uuid,
        command: PlaybackCommand,
    ) -> Result<ControlResponse, StreamError> {
        let session = self.active_sessions.get_mut(&session_id)
            .ok_or(StreamError::SessionNotFound)?;
        
        match command {
            PlaybackCommand::Pause => {
                session.source.pause().await?;
                session.state = StreamState::Paused;
            }
            PlaybackCommand::Resume => {
                session.source.resume().await?;
                session.state = StreamState::Streaming;
            }
            PlaybackCommand::Seek { position } => {
                session.source.seek(position).await?;
                session.state = StreamState::Seeking;
            }
            PlaybackCommand::SetRate { rate } => {
                session.source.set_rate(rate).await?;
            }
            PlaybackCommand::Stop => {
                session.state = StreamState::Stopped;
                self.active_sessions.remove(&session_id);
            }
        }
        
        Ok(ControlResponse {
            status: "success".to_string(),
            current_state: session.state.clone(),
        })
    }
}

#[derive(Debug, Clone)]
pub struct LiveStreamSession {
    pub session_id: Uuid,
    pub device_id: String,
    pub client_subscriptions: Vec<ClientSubscription>,
    pub stream_config: StreamConfig,
    pub start_time: SystemTime,
    pub stats: StreamStats,
    pub latency_target: Duration,
}

impl LiveStreamHandler {
    // å¼€å§‹ç›´é€šæ’­æ”¾
    pub async fn start_live_stream(
        &mut self,
        device_id: &str,
        request: LiveStreamRequest,
    ) -> Result<LiveStreamResponse, StreamError> {
        // 1. éªŒè¯è®¾å¤‡è¿æ¥çŠ¶æ€
        let device_conn = self.device_connections.get(device_id)
            .ok_or(StreamError::DeviceNotConnected)?;
            
        if !device_conn.is_active() {
            return Err(StreamError::DeviceOffline);
        }
        
        // 2. åˆ›å»ºæµä¼šè¯
        let session_id = Uuid::new_v4();
        let stream_session = LiveStreamSession {
            session_id,
            device_id: device_id.to_string(),
            client_subscriptions: vec![ClientSubscription {
                client_id: request.client_id.clone(),
                subscription_time: SystemTime::now(),
                quality_preference: request.quality_preference,
                buffer_config: BufferConfig {
                    target_buffer_ms: if request.low_latency_mode { 100 } else { 3000 },
                    max_buffer_ms: if request.low_latency_mode { 500 } else { 10000 },
                },
            }],
            stream_config: StreamConfig {
                low_latency_mode: request.low_latency_mode,
                quality: request.quality_preference,
                audio_enabled: request.audio_enabled,
            },
            start_time: SystemTime::now(),
            stats: StreamStats::new(),
            latency_target: if request.low_latency_mode { 
                Duration::from_millis(100) 
            } else { 
                Duration::from_millis(200) 
            },
        };
        
        // 3. å‘è®¾å¤‡å‘é€å¼€å§‹æµå‘½ä»¤
        let device_command = DeviceStreamCommand {
            command_type: "start_live_stream".to_string(),
            session_id,
            parameters: serde_json::json!({
                "quality": request.quality_preference,
                "low_latency": request.low_latency_mode,
                "audio_enabled": request.audio_enabled,
                "target_latency_ms": stream_session.latency_target.as_millis(),
            }),
        };
        
        self.send_device_command(device_id, device_command).await?;
        
        // 4. æ³¨å†Œæµä¼šè¯
        self.active_streams.insert(session_id, stream_session);
        
        // 5. å¯åŠ¨é›¶ç¼“å†²è½¬å‘ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if self.zero_buffer_mode {
            self.start_zero_buffer_forwarding(session_id).await?;
        }
        
        Ok(LiveStreamResponse {
            session_id,
            stream_url: format!("/api/v1/stream/{}/segments", session_id),
            control_url: format!("/api/v1/playback/{}/control", session_id),
            status_url: format!("/api/v1/stream/{}/status", session_id),
            websocket_url: format!("wss://platform-server:8443/api/v1/stream/{}/events", session_id),
            estimated_latency_ms: stream_session.latency_target.as_millis() as u32,
            stream_info: StreamInfo {
                resolution: "1920x1080".to_string(),
                frame_rate: 30.0,
                bitrate: 5000000,
                format: VideoFormat::H264,
            },
        })
    }
    
    // é›¶ç¼“å†²è½¬å‘
    async fn start_zero_buffer_forwarding(
        &mut self,
        session_id: Uuid,
    ) -> Result<(), StreamError> {
        let session = self.active_streams.get(&session_id)
            .ok_or(StreamError::SessionNotFound)?;
            
        // å¯åŠ¨ä¸“ç”¨çš„é›¶å»¶è¿Ÿè½¬å‘ä»»åŠ¡
        tokio::spawn(async move {
            let mut segment_receiver = self.get_device_segment_receiver(&session.device_id).await?;
            let client_senders = self.get_client_senders(&session.client_subscriptions).await?;
            
            while let Some(segment) = segment_receiver.recv().await {
                let receive_time = SystemTime::now();
                
                // ç«‹å³å¹¶å‘è½¬å‘åˆ°æ‰€æœ‰å®¢æˆ·ç«¯
                let forward_tasks: Vec<_> = client_senders.iter()
                    .map(|sender| {
                        let segment_clone = segment.clone();
                        async move {
                            sender.send_segment_immediate(segment_clone).await
                        }
                    })
                    .collect();
                
                // ç­‰å¾…æ‰€æœ‰è½¬å‘å®Œæˆ
                let results = futures::future::join_all(forward_tasks).await;
                
                // è®°å½•å»¶è¿Ÿç»Ÿè®¡
                let forward_time = SystemTime::now();
                let processing_latency = forward_time.duration_since(receive_time).unwrap_or_default();
                
                // æ£€æŸ¥å»¶è¿Ÿé˜ˆå€¼
                if processing_latency > Duration::from_millis(5) {
                    warn!("High forwarding latency: {:?} for session {}", processing_latency, session_id);
                }
            }
            
            Ok::<(), StreamError>(())
        });
        
        Ok(())
    }
}
```

### 5.4 å½•åƒå›æ”¾å¤„ç†å™¨å®ç°

```rust
pub struct PlaybackHandler {
    active_playbacks: HashMap<Uuid, PlaybackSession>,
    file_cache: Arc<Mutex<PlaybackCache>>,
    storage_backend: StorageBackend,
}

#[derive(Debug, Clone)]
pub struct PlaybackSession {
    pub session_id: Uuid,
    pub file_id: String,
    pub recording_info: RecordingInfo,
    pub playback_config: PlaybackConfig,
    pub current_position: f64,
    pub playback_state: PlaybackState,
    pub client_subscriptions: Vec<ClientSubscription>,
    pub file_reader: Arc<Mutex<FileStreamReader>>,
    pub start_time: SystemTime,
}

impl PlaybackHandler {
    // å¼€å§‹å½•åƒå›æ”¾
    pub async fn start_playback(
        &mut self,
        file_id: &str,
        request: PlaybackRequest,
    ) -> Result<PlaybackResponse, PlaybackError> {
        // 1. è·å–å½•åƒæ–‡ä»¶ä¿¡æ¯
        let recording = self.storage_backend.get_recording(file_id).await?
            .ok_or(PlaybackError::RecordingNotFound)?;
        
        // 2. éªŒè¯æ–‡ä»¶å¯è®¿é—®æ€§
        if !recording.is_accessible() {
            return Err(PlaybackError::FileNotAccessible);
        }
        
        // 3. åˆ›å»ºæ–‡ä»¶æµè¯»å–å™¨
        let file_reader = FileStreamReader::new(
            recording.file_path.clone(),
            PlaybackConfig {
                start_position: request.start_position,
                playback_rate: request.playback_rate,
                quality: request.quality,
                audio_enabled: request.audio_enabled,
            },
        ).await?;
        
        // 4. åˆ›å»ºå›æ”¾ä¼šè¯
        let session_id = Uuid::new_v4();
        let playback_session = PlaybackSession {
            session_id,
            file_id: file_id.to_string(),
            recording_info: recording.clone(),
            playback_config: PlaybackConfig {
                start_position: request.start_position,
                playback_rate: request.playback_rate,
                quality: request.quality,
                audio_enabled: request.audio_enabled,
            },
            current_position: request.start_position,
            playback_state: PlaybackState::Playing,
            client_subscriptions: vec![ClientSubscription {
                client_id: request.client_id.clone(),
                subscription_time: SystemTime::now(),
                quality_preference: request.quality,
                buffer_config: BufferConfig::default(),
            }],
            file_reader: Arc::new(Mutex::new(file_reader)),
            start_time: SystemTime::now(),
        };
        
        // 5. å¯åŠ¨åˆ†ç‰‡ä¼ è¾“ä»»åŠ¡
        self.start_playback_streaming(session_id, playback_session.clone()).await?;
        
        // 6. æ³¨å†Œå›æ”¾ä¼šè¯
        self.active_playbacks.insert(session_id, playback_session);
        
        Ok(PlaybackResponse {
            session_id,
            playback_url: format!("/api/v1/playback/{}/segments", session_id),
            control_url: format!("/api/v1/playback/{}/control", session_id),
            status_url: format!("/api/v1/playback/{}/status", session_id),
            file_info: FileInfo {
                duration: recording.duration,
                resolution: recording.resolution,
                frame_rate: recording.frame_rate,
                bitrate: recording.bitrate,
            },
        })
    }
    
    // å¯åŠ¨å›æ”¾æµä¼ è¾“
    async fn start_playback_streaming(
        &mut self,
        session_id: Uuid,
        session: PlaybackSession,
    ) -> Result<(), PlaybackError> {
        let file_reader = session.file_reader.clone();
        let client_senders = self.get_client_senders(&session.client_subscriptions).await?;
        
        tokio::spawn(async move {
            let mut last_segment_time = SystemTime::now();
            
            loop {
                // æ£€æŸ¥æ’­æ”¾çŠ¶æ€
                if matches!(session.playback_state, PlaybackState::Stopped) {
                    break;
                }
                
                if matches!(session.playback_state, PlaybackState::Paused) {
                    tokio::time::sleep(Duration::from_millis(100)).await;
                    continue;
                }
                
                // è¯»å–ä¸‹ä¸€ä¸ªåˆ†ç‰‡
                let segment = {
                    let mut reader = file_reader.lock().await;
                    reader.read_next_segment().await?
                };
                
                if let Some(segment) = segment {
                    // è®¡ç®—æ’­æ”¾æ—¶é—´é—´éš”
                    let segment_duration = Duration::from_secs_f64(
                        segment.duration / session.playback_config.playback_rate
                    );
                    
                    // å‘é€åˆ†ç‰‡åˆ°å®¢æˆ·ç«¯
                    for sender in &client_senders {
                        sender.send_segment(segment.clone()).await?;
                    }
                    
                    // ç­‰å¾…æ’­æ”¾æ—¶é—´é—´éš”
                    let elapsed = last_segment_time.elapsed().unwrap_or_default();
                    if segment_duration > elapsed {
                        tokio::time::sleep(segment_duration - elapsed).await;
                    }
                    
                    last_segment_time = SystemTime::now();
                } else {
                    // æ’­æ”¾ç»“æŸ
                    break;
                }
            }
            
            Ok::<(), PlaybackError>(())
        });
        
        Ok(())
    }
    
    // å¤„ç†æ’­æ”¾æ§åˆ¶å‘½ä»¤
    pub async fn handle_playback_control(
        &mut self,
        session_id: Uuid,
        control: PlaybackControlCommand,
    ) -> Result<(), PlaybackError> {
        let session = self.active_playbacks.get_mut(&session_id)
            .ok_or(PlaybackError::SessionNotFound)?;
        
        match control.command.as_str() {
            "play" => {
                session.playback_state = PlaybackState::Playing;
            }
            "pause" => {
                session.playback_state = PlaybackState::Paused;
            }
            "stop" => {
                session.playback_state = PlaybackState::Stopped;
            }
            "seek" => {
                if let Some(position) = control.position {
                    session.playback_state = PlaybackState::Seeking;
                    
                    // æ‰§è¡Œå®šä½
                    let mut file_reader = session.file_reader.lock().await;
                    file_reader.seek_to(position).await?;
                    session.current_position = position;
                    
                    session.playback_state = PlaybackState::Playing;
                }
            }
            "set_rate" => {
                if let Some(rate) = control.rate {
                    session.playback_config.playback_rate = rate;
                }
            }
            _ => {
                return Err(PlaybackError::UnsupportedCommand);
            }
        }
        
        Ok(())
    }
}

// æ–‡ä»¶æµè¯»å–å™¨
pub struct FileStreamReader {
    file_path: PathBuf,
    file_handle: tokio::fs::File,
    segment_parser: SegmentParser,
    playback_config: PlaybackConfig,
    current_position: f64,
    total_duration: f64,
    keyframe_index: Vec<KeyframeInfo>,
}

#[derive(Debug, Clone)]
pub struct KeyframeInfo {
    pub timestamp: f64,
    pub file_offset: u64,
    pub size: u32,
}

impl FileStreamReader {
    pub async fn new(
        file_path: PathBuf,
        playback_config: PlaybackConfig,
    ) -> Result<Self, std::io::Error> {
        let file_handle = tokio::fs::File::open(&file_path).await?;
        
        // è§£ææ–‡ä»¶æ ¼å¼å’Œæ—¶é•¿
        let segment_parser = SegmentParser::new(&file_path).await?;
        let total_duration = segment_parser.get_duration();
        
        // æ„å»ºå…³é”®å¸§ç´¢å¼•
        let keyframe_index = segment_parser.build_keyframe_index().await?;
        
        Ok(Self {
            file_path,
            file_handle,
            segment_parser,
            playback_config,
            current_position: playback_config.start_position,
            total_duration,
            keyframe_index,
        })
    }
    
    // å¿«é€Ÿå®šä½åˆ°æŒ‡å®šä½ç½®
    pub async fn seek_to(&mut self, position: f64) -> Result<(), std::io::Error> {
        if position < 0.0 || position > self.total_duration {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "Invalid seek position"
            ));
        }
        
        // æŸ¥æ‰¾æœ€è¿‘çš„å…³é”®å¸§
        let keyframe = self.find_nearest_keyframe(position);
        
        if let Some(kf) = keyframe {
            // å®šä½åˆ°å…³é”®å¸§ä½ç½®
            self.file_handle.seek(std::io::SeekFrom::Start(kf.file_offset)).await?;
            self.current_position = kf.timestamp;
        } else {
            // ä»æ–‡ä»¶å¼€å§‹å®šä½
            self.file_handle.seek(std::io::SeekFrom::Start(0)).await?;
            self.current_position = 0.0;
        }
        
        // å¦‚æœä¸æ˜¯ç²¾ç¡®å®šä½åˆ°å…³é”®å¸§ï¼Œéœ€è¦è¯»å–åˆ°ç›®æ ‡ä½ç½®
        while self.current_position < position {
            if let Some(segment) = self.read_next_segment().await? {
                if segment.timestamp >= position {
                    break;
                }
            } else {
                break;
            }
        }
        
        Ok(())
    }
    
    // æŸ¥æ‰¾æœ€è¿‘çš„å…³é”®å¸§
    fn find_nearest_keyframe(&self, position: f64) -> Option<&KeyframeInfo> {
        self.keyframe_index
            .iter()
            .rev()
            .find(|kf| kf.timestamp <= position)
    }
    
    // è¯»å–ä¸‹ä¸€ä¸ªåˆ†ç‰‡
    pub async fn read_next_segment(&mut self) -> Result<Option<VideoSegment>, std::io::Error> {
        if self.current_position >= self.total_duration {
            return Ok(None);
        }
        
        let segment = self.segment_parser.read_next_segment().await?;
        
        if let Some(ref seg) = segment {
            self.current_position = seg.timestamp + seg.duration;
        }
        
        Ok(segment)
    }
}
```

### 5.5 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 5.5.1 é›¶ç¼“å†²ç›´é€šä¼ è¾“
```rust
// é›¶å»¶è¿Ÿè½¬å‘ä¼˜åŒ–
pub struct ZeroLatencyForwarder {
    segment_queue: Arc<Mutex<VecDeque<VideoSegment>>>,
    client_senders: Vec<HTTP3Sender>,
    processing_stats: ProcessingStats,
}

impl ZeroLatencyForwarder {
    // ç«‹å³è½¬å‘æ¨¡å¼
    pub async fn forward_immediately(
        &mut self,
        segment: VideoSegment,
    ) -> Result<(), ForwardError> {
        let start_time = Instant::now();
        
        // å¹¶å‘å‘é€åˆ°æ‰€æœ‰å®¢æˆ·ç«¯ï¼ˆæ— ç­‰å¾…ï¼‰
        let send_futures: Vec<_> = self.client_senders
            .iter()
            .map(|sender| sender.send_segment_nowait(segment.clone()))
            .collect();
        
        // å¯åŠ¨å¹¶å‘å‘é€ï¼Œä¸ç­‰å¾…å®Œæˆ
        for future in send_futures {
            tokio::spawn(future);
        }
        
        // è®°å½•å¤„ç†æ—¶é—´
        let processing_time = start_time.elapsed();
        self.processing_stats.record_processing_time(processing_time);
        
        // ç›®æ ‡ï¼šå¤„ç†æ—¶é—´ < 1ms
        if processing_time > Duration::from_millis(1) {
            warn!("High processing time: {:?}", processing_time);
        }
        
        Ok(())
    }
}
```

#### 5.5.2 æ™ºèƒ½å›æ”¾ç¼“å­˜
```rust
// è‡ªé€‚åº”é¢„è¯»ç¼“å­˜
pub struct AdaptivePlaybackCache {
    segment_cache: LRUCache<f64, VideoSegment>,
    prefetch_strategy: PrefetchStrategy,
    cache_stats: CacheStats,
}

#[derive(Debug, Clone)]
pub enum PrefetchStrategy {
    Conservative,  // ä¿å®ˆé¢„è¯»ï¼š10ç§’
    Normal,       // æ­£å¸¸é¢„è¯»ï¼š30ç§’
    Aggressive,   // æ¿€è¿›é¢„è¯»ï¼š60ç§’
    Adaptive,     // è‡ªé€‚åº”é¢„è¯»ï¼šæ ¹æ®ç½‘ç»œæ¡ä»¶è°ƒæ•´
}

impl AdaptivePlaybackCache {
    // è‡ªé€‚åº”é¢„è¯»
    pub async fn adaptive_prefetch(
        &mut self,
        current_position: f64,
        playback_rate: f64,
        network_conditions: &NetworkConditions,
    ) -> Result<(), CacheError> {
        // æ ¹æ®ç½‘ç»œæ¡ä»¶è°ƒæ•´é¢„è¯»ç­–ç•¥
        let prefetch_duration = match network_conditions.bandwidth_mbps {
            bw if bw > 50.0 => 60.0,   // é«˜å¸¦å®½ï¼šæ¿€è¿›é¢„è¯»
            bw if bw > 20.0 => 30.0,   // ä¸­ç­‰å¸¦å®½ï¼šæ­£å¸¸é¢„è¯»
            bw if bw > 5.0 => 15.0,    // ä½å¸¦å®½ï¼šä¿å®ˆé¢„è¯»
            _ => 5.0,                  // æä½å¸¦å®½ï¼šæœ€å°é¢„è¯»
        };
        
        // æ ¹æ®æ’­æ”¾é€Ÿåº¦è°ƒæ•´
        let adjusted_duration = prefetch_duration * playback_rate.max(1.0);
        
        // æ‰§è¡Œé¢„è¯»
        self.prefetch_segments(current_position, adjusted_duration).await?;
        
        Ok(())
    }
}
```

## 6. å‰ç«¯è®¾è®¡ï¼ˆç®€è¦ï¼‰

### 6.1 å‰ç«¯æ¶æ„

```mermaid
graph TB
    subgraph Webå‰ç«¯æ’­æ”¾å™¨
        subgraph æ ¸å¿ƒå±‚
            HTTP3C[HTTP3å®¢æˆ·ç«¯<br/>åè®®å¤„ç†]
            PLAYER[è§†é¢‘æ’­æ”¾å™¨<br/>åª’ä½“æ¸²æŸ“]
            CONTROL[æ§åˆ¶é¢æ¿<br/>ç”¨æˆ·äº¤äº’]
        end
        
        subgraph ç®¡ç†å±‚
            BUFFER[ç¼“å†²ç®¡ç†å™¨<br/>æ’­æ”¾ç¼“å†²]
            MONITOR[çŠ¶æ€ç›‘æ§å™¨<br/>å®æ—¶çŠ¶æ€]
            QUALITY[è´¨é‡æ§åˆ¶å™¨<br/>è‡ªé€‚åº”]
        end
        
        subgraph åŠŸèƒ½å±‚
            DEVMGR[è®¾å¤‡ç®¡ç†å™¨<br/>è®¾å¤‡åˆ—è¡¨]
            RECMGR[å½•åƒç®¡ç†å™¨<br/>å½•åƒæŸ¥è¯¢]
            WSMGR[WebSocketç®¡ç†å™¨<br/>å®æ—¶äº‹ä»¶]
        end
    end
    
    HTTP3C --> PLAYER
    HTTP3C --> DEVMGR
    HTTP3C --> RECMGR
    HTTP3C --> WSMGR
    
    CONTROL --> HTTP3C
    PLAYER --> BUFFER
    BUFFER --> QUALITY
    
    MONITOR --> PLAYER
    MONITOR --> BUFFER
    MONITOR --> QUALITY
    
    DEVMGR --> CONTROL
    RECMGR --> CONTROL
    WSMGR --> MONITOR
    
    style HTTP3C fill:#bbdefb
    style PLAYER fill:#ffccbc
    style CONTROL fill:#ffccbc
    style BUFFER fill:#c5e1a5
    style MONITOR fill:#c5e1a5
    style QUALITY fill:#c5e1a5
    style DEVMGR fill:#fff9c4
    style RECMGR fill:#fff9c4
    style WSMGR fill:#fff9c4
```

### 5.2 æ ¸å¿ƒç»„ä»¶

#### 5.2.1 HTTP3è§†é¢‘æ’­æ”¾å™¨

```javascript
class HTTP3VideoPlayer {
    constructor(containerId, serverUrl) {
        this.container = document.getElementById(containerId);
        this.serverUrl = serverUrl;
        this.http3Client = new HTTP3Client(serverUrl);
        this.videoElement = null;
        this.mediaSource = null;
        this.sourceBuffer = null;
        this.playbackStats = new PlaybackStatistics();
        this.bufferManager = new BufferManager();
        this.deviceManager = new DeviceManager(this.http3Client);
        this.recordingManager = new RecordingManager(this.http3Client);
        this.controlPanel = null;
        
        this.initializePlayer();
    }
    
    // è®¾å¤‡ç®¡ç†å™¨
    class DeviceManager {
        constructor(http3Client) {
            this.http3Client = http3Client;
            this.devices = new Map();
            this.deviceListContainer = null;
        }
        
        // è·å–è®¾å¤‡åˆ—è¡¨
        async getDevices() {
            try {
                const response = await this.http3Client.get('/api/v1/devices');
                this.devices.clear();
                
                response.data.devices.forEach(device => {
                    this.devices.set(device.device_id, device);
                });
                
                this.updateDeviceList();
                return response.data.devices;
            } catch (error) {
                console.error('Failed to fetch devices:', error);
                throw error;
            }
        }
        
        // æ›´æ–°è®¾å¤‡åˆ—è¡¨æ˜¾ç¤º
        updateDeviceList() {
            if (!this.deviceListContainer) return;
            
            this.deviceListContainer.innerHTML = '';
            
            this.devices.forEach(device => {
                const deviceElement = this.createDeviceElement(device);
                this.deviceListContainer.appendChild(deviceElement);
            });
        }
        
        // åˆ›å»ºè®¾å¤‡æ˜¾ç¤ºå…ƒç´ 
        createDeviceElement(device) {
            const deviceDiv = document.createElement('div');
            deviceDiv.className = `device-item ${device.connection_status}`;
            deviceDiv.innerHTML = `
                <div class="device-header">
                    <h4>${device.device_name}</h4>
                    <span class="status-indicator ${device.connection_status}">
                        ${device.connection_status}
                    </span>
                </div>
                <div class="device-info">
                    <p>ç±»å‹: ${device.device_type}</p>
                    <p>åˆ†è¾¨ç‡: ${device.capabilities.max_resolution}</p>
                    <p>å»¶è¿Ÿ: ${device.network_stats.latency_ms}ms</p>
                    <p>å¸¦å®½: ${device.network_stats.bandwidth_mbps}Mbps</p>
                </div>
                <div class="device-actions">
                    <button onclick="this.startLiveStream('${device.device_id}')" 
                            ${device.connection_status !== 'online' ? 'disabled' : ''}>
                        ç›´é€šæ’­æ”¾
                    </button>
                    <button onclick="this.showRecordings('${device.device_id}')">
                        æŸ¥çœ‹å½•åƒ
                    </button>
                    <button onclick="this.showDeviceDetails('${device.device_id}')">
                        è¯¦ç»†ä¿¡æ¯
                    </button>
                </div>
            `;
            
            return deviceDiv;
        }
        
        // å¼€å§‹ç›´é€šæ’­æ”¾
        async startLiveStream(deviceId) {
            try {
                const response = await this.http3Client.post(`/api/v1/devices/${deviceId}/live-stream`, {
                    client_id: this.generateClientId(),
                    quality_preference: 'auto',
                    buffer_size: 30,
                    low_latency_mode: true,
                    audio_enabled: true,
                    timestamp: Date.now()
                });
                
                if (response.status === 200) {
                    const streamInfo = response.data;
                    // å¼€å§‹æ’­æ”¾æµ
                    await this.player.startStream(streamInfo.session_id, streamInfo);
                    
                    // æ˜¾ç¤ºæµä¿¡æ¯
                    this.showStreamInfo(streamInfo);
                }
            } catch (error) {
                console.error('Failed to start live stream:', error);
                this.showError('å¯åŠ¨ç›´é€šæ’­æ”¾å¤±è´¥: ' + error.message);
            }
        }
    }
    
    // å½•åƒç®¡ç†å™¨
    class RecordingManager {
        constructor(http3Client) {
            this.http3Client = http3Client;
            this.recordings = new Map();
            this.recordingListContainer = null;
            this.currentPage = 1;
            this.pageSize = 20;
        }
        
        // è·å–è®¾å¤‡å½•åƒåˆ—è¡¨
        async getDeviceRecordings(deviceId, options = {}) {
            try {
                const params = new URLSearchParams({
                    page: options.page || this.currentPage,
                    page_size: options.pageSize || this.pageSize,
                    ...options.filters
                });
                
                const response = await this.http3Client.get(
                    `/api/v1/devices/${deviceId}/recordings?${params}`
                );
                
                this.recordings.clear();
                response.data.recordings.forEach(recording => {
                    this.recordings.set(recording.file_id, recording);
                });
                
                this.updateRecordingList(response.data);
                return response.data;
            } catch (error) {
                console.error('Failed to fetch recordings:', error);
                throw error;
            }
        }
        
        // æ›´æ–°å½•åƒåˆ—è¡¨æ˜¾ç¤º
        updateRecordingList(data) {
            if (!this.recordingListContainer) return;
            
            this.recordingListContainer.innerHTML = `
                <div class="recording-summary">
                    <h3>å½•åƒæ–‡ä»¶ (${data.summary.total_files}ä¸ªæ–‡ä»¶)</h3>
                    <p>æ€»å¤§å°: ${(data.summary.total_size_gb).toFixed(2)} GB</p>
                    <p>æ€»æ—¶é•¿: ${(data.summary.total_duration_hours).toFixed(1)} å°æ—¶</p>
                </div>
                <div class="recording-filters">
                    <input type="date" id="start-date" placeholder="å¼€å§‹æ—¥æœŸ">
                    <input type="date" id="end-date" placeholder="ç»“æŸæ—¥æœŸ">
                    <select id="format-filter">
                        <option value="">æ‰€æœ‰æ ¼å¼</option>
                        <option value="h264">H.264</option>
                        <option value="mp4">MP4</option>
                    </select>
                    <button onclick="this.applyFilters()">ç­›é€‰</button>
                </div>
                <div class="recording-list" id="recording-list"></div>
                <div class="pagination" id="pagination"></div>
            `;
            
            const recordingList = this.recordingListContainer.querySelector('#recording-list');
            
            data.recordings.forEach(recording => {
                const recordingElement = this.createRecordingElement(recording);
                recordingList.appendChild(recordingElement);
            });
            
            this.updatePagination(data.pagination);
        }
        
        // åˆ›å»ºå½•åƒæ˜¾ç¤ºå…ƒç´ 
        createRecordingElement(recording) {
            const recordingDiv = document.createElement('div');
            recordingDiv.className = 'recording-item';
            recordingDiv.innerHTML = `
                <div class="recording-thumbnail">
                    <img src="${recording.thumbnail_url}" alt="ç¼©ç•¥å›¾" 
                         onerror="this.src='/assets/default-thumbnail.png'">
                    <div class="duration-overlay">${this.formatDuration(recording.duration)}</div>
                </div>
                <div class="recording-info">
                    <h4>${recording.file_name}</h4>
                    <p>åˆ›å»ºæ—¶é—´: ${new Date(recording.created_time).toLocaleString()}</p>
                    <p>åˆ†è¾¨ç‡: ${recording.resolution}</p>
                    <p>å¤§å°: ${this.formatFileSize(recording.file_size)}</p>
                    <p>æ ¼å¼: ${recording.format.toUpperCase()}</p>
                </div>
                <div class="recording-actions">
                    <button onclick="this.playRecording('${recording.file_id}')" class="play-btn">
                        æ’­æ”¾
                    </button>
                    <button onclick="this.downloadRecording('${recording.file_id}')" class="download-btn">
                        ä¸‹è½½
                    </button>
                    <button onclick="this.showRecordingDetails('${recording.file_id}')" class="details-btn">
                        è¯¦æƒ…
                    </button>
                    <button onclick="this.deleteRecording('${recording.file_id}')" class="delete-btn">
                        åˆ é™¤
                    </button>
                </div>
            `;
            
            return recordingDiv;
        }
        
        // æ’­æ”¾å½•åƒ
        async playRecording(fileId) {
            try {
                const response = await this.http3Client.post(`/api/v1/recordings/${fileId}/playback`, {
                    client_id: this.generateClientId(),
                    start_position: 0.0,
                    quality: 'high',
                    playback_rate: 1.0,
                    audio_enabled: true,
                    timestamp: Date.now()
                });
                
                if (response.status === 200) {
                    const playbackInfo = response.data;
                    // å¼€å§‹å›æ”¾
                    await this.player.startPlayback(playbackInfo.session_id, playbackInfo);
                    
                    // æ˜¾ç¤ºå›æ”¾æ§åˆ¶ç•Œé¢
                    this.showPlaybackControls(playbackInfo);
                }
            } catch (error) {
                console.error('Failed to start playback:', error);
                this.showError('å¯åŠ¨å›æ”¾å¤±è´¥: ' + error.message);
            }
        }
        
        // ä¸‹è½½å½•åƒ
        async downloadRecording(fileId) {
            try {
                const recording = this.recordings.get(fileId);
                if (!recording) {
                    throw new Error('å½•åƒæ–‡ä»¶ä¸å­˜åœ¨');
                }
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const downloadLink = document.createElement('a');
                downloadLink.href = recording.download_url;
                downloadLink.download = recording.file_name;
                downloadLink.style.display = 'none';
                
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                // æ›´æ–°è®¿é—®ç»Ÿè®¡
                await this.http3Client.post(`/api/v1/recordings/${fileId}/access`, {
                    action: 'download',
                    client_id: this.generateClientId(),
                    timestamp: Date.now()
                });
                
            } catch (error) {
                console.error('Failed to download recording:', error);
                this.showError('ä¸‹è½½å¤±è´¥: ' + error.message);
            }
        }
        
        // åˆ é™¤å½•åƒ
        async deleteRecording(fileId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå½•åƒæ–‡ä»¶å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
                return;
            }
            
            try {
                const response = await this.http3Client.delete(`/api/v1/recordings/${fileId}`);
                
                if (response.status === 200) {
                    // ä»åˆ—è¡¨ä¸­ç§»é™¤
                    this.recordings.delete(fileId);
                    
                    // åˆ·æ–°æ˜¾ç¤º
                    const recordingElement = document.querySelector(`[data-file-id="${fileId}"]`);
                    if (recordingElement) {
                        recordingElement.remove();
                    }
                    
                    this.showSuccess('å½•åƒæ–‡ä»¶å·²åˆ é™¤');
                }
            } catch (error) {
                console.error('Failed to delete recording:', error);
                this.showError('åˆ é™¤å¤±è´¥: ' + error.message);
            }
        }
    }
    
    // åˆå§‹åŒ–æ’­æ”¾å™¨
    async initializePlayer() {
        // 1. åˆ›å»ºè§†é¢‘å…ƒç´ 
        this.videoElement = document.createElement('video');
        this.videoElement.controls = true;
        this.videoElement.style.width = '100%';
        this.container.appendChild(this.videoElement);
        
        // 2. åˆå§‹åŒ–MediaSource
        this.mediaSource = new MediaSource();
        this.videoElement.src = URL.createObjectURL(this.mediaSource);
        
        // 3. ç­‰å¾…MediaSourceå°±ç»ª
        await new Promise(resolve => {
            this.mediaSource.addEventListener('sourceopen', resolve);
        });
        
        // 4. åˆ›å»ºSourceBuffer
        this.sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
        
        // 5. è®¾ç½®äº‹ä»¶ç›‘å¬
        this.setupEventListeners();
    }
    
    // å¼€å§‹æ’­æ”¾æµ
    async startStream(sessionId) {
        try {
            // 1. å»ºç«‹HTTP3è¿æ¥
            await this.http3Client.connect();
            
            // 2. è®¢é˜…è§†é¢‘æµ
            const response = await this.http3Client.post(`/api/v1/stream/${sessionId}/subscribe`, {
                client_id: this.generateClientId(),
                quality_preference: 'auto',
                buffer_size: 30 // 30ç§’ç¼“å†²
            });
            
            if (response.status === 200) {
                // 3. å¼€å§‹æ¥æ”¶è§†é¢‘åˆ†ç‰‡
                this.startReceivingSegments(sessionId);
                
                // 4. å¯åŠ¨çŠ¶æ€ç›‘æ§
                this.startStatusMonitoring(sessionId);
            }
        } catch (error) {
            console.error('Failed to start stream:', error);
            this.handleStreamError(error);
        }
    }
    
    // æ¥æ”¶è§†é¢‘åˆ†ç‰‡
    async startReceivingSegments(sessionId) {
        const segmentStream = this.http3Client.getStream(`/api/v1/stream/${sessionId}/segments`);
        
        for await (const segment of segmentStream) {
            try {
                // 1. è§£æåˆ†ç‰‡å¤´éƒ¨ä¿¡æ¯
                const segmentInfo = this.parseSegmentHeaders(segment.headers);
                
                // 2. æ›´æ–°æ’­æ”¾ç»Ÿè®¡
                this.playbackStats.recordSegmentReceived(segmentInfo);
                
                // 3. ç¼“å†²ç®¡ç†
                await this.bufferManager.addSegment(segment.data, segmentInfo);
                
                // 4. æ·»åŠ åˆ°SourceBuffer
                if (!this.sourceBuffer.updating) {
                    this.sourceBuffer.appendBuffer(segment.data);
                }
                
                // 5. æ›´æ–°æ’­æ”¾è¿›åº¦æ˜¾ç¤º
                this.updateProgressDisplay(segmentInfo);
                
            } catch (error) {
                console.error('Error processing segment:', error);
                this.handleSegmentError(error, segment);
            }
        }
    }
    
    // æ’­æ”¾æ§åˆ¶é¢æ¿
    createControlPanel() {
        this.controlPanel = document.createElement('div');
        this.controlPanel.className = 'video-control-panel';
        this.controlPanel.innerHTML = `
            <div class="playback-controls">
                <button id="play-pause-btn" onclick="this.togglePlayPause()">æ’­æ”¾</button>
                <button id="stop-btn" onclick="this.stopPlayback()">åœæ­¢</button>
                <div class="speed-controls">
                    <label>æ’­æ”¾é€Ÿåº¦:</label>
                    <select id="playback-rate" onchange="this.changePlaybackRate(this.value)">
                        <option value="0.25">0.25x</option>
                        <option value="0.5">0.5x</option>
                        <option value="1.0" selected>1.0x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2.0">2.0x</option>
                        <option value="4.0">4.0x</option>
                    </select>
                </div>
            </div>
            <div class="seek-controls">
                <input type="range" id="seek-bar" min="0" max="100" value="0" 
                       oninput="this.seekTo(this.value)" onchange="this.seekTo(this.value)">
                <div class="time-display">
                    <span id="current-time">00:00</span> / <span id="total-time">00:00</span>
                </div>
            </div>
            <div class="quality-controls">
                <label>ç”»è´¨:</label>
                <select id="quality-select" onchange="this.changeQuality(this.value)">
                    <option value="auto">è‡ªåŠ¨</option>
                    <option value="original">åŸç”»</option>
                    <option value="high">é«˜æ¸…</option>
                    <option value="medium">æ ‡æ¸…</option>
                    <option value="low">æµç•…</option>
                </select>
            </div>
        `;
        
        this.container.appendChild(this.controlPanel);
    }
    
    // æ’­æ”¾/æš‚åœåˆ‡æ¢
    async togglePlayPause() {
        if (this.videoElement.paused) {
            await this.sendPlaybackControl('play');
            document.getElementById('play-pause-btn').textContent = 'æš‚åœ';
        } else {
            await this.sendPlaybackControl('pause');
            document.getElementById('play-pause-btn').textContent = 'æ’­æ”¾';
        }
    }
    
    // åœæ­¢æ’­æ”¾
    async stopPlayback() {
        await this.sendPlaybackControl('stop');
        this.videoElement.pause();
        this.videoElement.currentTime = 0;
        document.getElementById('play-pause-btn').textContent = 'æ’­æ”¾';
    }
    
    // æ”¹å˜æ’­æ”¾é€Ÿåº¦
    async changePlaybackRate(rate) {
        await this.sendPlaybackControl('set_rate', { 
            rate: parseFloat(rate),
            maintain_audio: rate <= 2.0 
        });
        this.videoElement.playbackRate = parseFloat(rate);
    }
    
    // æ‹–åŠ¨å®šä½
    async seekTo(position) {
        const duration = this.videoElement.duration || 0;
        const targetTime = (position / 100) * duration;
        
        await this.sendPlaybackControl('seek', { 
            position: targetTime,
            accurate: true 
        });
    }
    
    // æ”¹å˜ç”»è´¨
    async changeQuality(quality) {
        await this.sendPlaybackControl('adjust_quality', { 
            quality_level: quality 
        });
    }

    // æ’­æ”¾æ§åˆ¶
    async sendPlaybackControl(command, params = {}) {
        const controlRequest = {
            command: command,
            ...params,
            client_id: this.clientId,
            timestamp: Date.now()
        };
        
        try {
            const response = await this.http3Client.post(
                `/api/v1/playback/${this.sessionId}/control`,
                controlRequest
            );
            
            if (response.status === 200) {
                console.log(`Playback control '${command}' sent successfully`);
                
                // æ›´æ–°UIçŠ¶æ€
                this.updateControlPanelState(command, params);
            }
        } catch (error) {
            console.error(`Failed to send playback control '${command}':`, error);
            this.showError(`æ’­æ”¾æ§åˆ¶å¤±è´¥: ${error.message}`);
        }
    }
    
    // æ›´æ–°æ§åˆ¶é¢æ¿çŠ¶æ€
    updateControlPanelState(command, params) {
        switch (command) {
            case 'play':
                document.getElementById('play-pause-btn').textContent = 'æš‚åœ';
                break;
            case 'pause':
                document.getElementById('play-pause-btn').textContent = 'æ’­æ”¾';
                break;
            case 'stop':
                document.getElementById('play-pause-btn').textContent = 'æ’­æ”¾';
                document.getElementById('seek-bar').value = 0;
                break;
            case 'set_rate':
                document.getElementById('playback-rate').value = params.rate;
                break;
            case 'seek':
                const duration = this.videoElement.duration || 0;
                const percentage = duration > 0 ? (params.position / duration) * 100 : 0;
                document.getElementById('seek-bar').value = percentage;
                break;
        }
    }
    
    // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
    showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff4444;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        `;
        
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
            document.body.removeChild(errorDiv);
        }, 5000);
    }
    
    // æ˜¾ç¤ºæˆåŠŸä¿¡æ¯
    showSuccess(message) {
        const successDiv = document.createElement('div');
        successDiv.className = 'success-message';
        successDiv.textContent = message;
        successDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #44ff44;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        `;
        
        document.body.appendChild(successDiv);
        
        setTimeout(() => {
            document.body.removeChild(successDiv);
        }, 3000);
    }
}
```

#### 5.2.2 å®æ—¶çŠ¶æ€ç›‘æ§

```javascript
class PlaybackStatusMonitor {
    constructor(player, sessionId) {
        this.player = player;
        this.sessionId = sessionId;
        this.statusDisplay = null;
        this.metricsHistory = [];
        this.updateInterval = null;
        
        this.createStatusDisplay();
        this.startMonitoring();
    }
    
    // åˆ›å»ºçŠ¶æ€æ˜¾ç¤ºç•Œé¢
    createStatusDisplay() {
        this.statusDisplay = document.createElement('div');
        this.statusDisplay.className = 'playback-status';
        this.statusDisplay.innerHTML = `
            <div class="status-panel">
                <h3>æ’­æ”¾çŠ¶æ€ç›‘æ§</h3>
                <div class="metrics-grid">
                    <div class="metric">
                        <label>å»¶è¿Ÿ:</label>
                        <span id="latency-value">-- ms</span>
                    </div>
                    <div class="metric">
                        <label>ç¼“å†²:</label>
                        <span id="buffer-value">-- s</span>
                    </div>
                    <div class="metric">
                        <label>æ¯”ç‰¹ç‡:</label>
                        <span id="bitrate-value">-- Mbps</span>
                    </div>
                    <div class="metric">
                        <label>ä¸¢åŒ…ç‡:</label>
                        <span id="loss-value">-- %</span>
                    </div>
                    <div class="metric">
                        <label>åˆ†è¾¨ç‡:</label>
                        <span id="resolution-value">--</span>
                    </div>
                    <div class="metric">
                        <label>å¸§ç‡:</label>
                        <span id="framerate-value">-- fps</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                    <div class="progress-text" id="progress-text">00:00 / 00:00</div>
                </div>
            </div>
        `;
        
        this.player.container.appendChild(this.statusDisplay);
    }
    
    // å¼€å§‹ç›‘æ§
    startMonitoring() {
        this.updateInterval = setInterval(() => {
            this.updateStatus();
        }, 1000); // æ¯ç§’æ›´æ–°ä¸€æ¬¡
    }
    
    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
    async updateStatus() {
        try {
            // 1. è·å–æ’­æ”¾å™¨çŠ¶æ€
            const playerStats = this.player.getPlaybackStatistics();
            
            // 2. è·å–æœåŠ¡å™¨ç«¯çŠ¶æ€
            const serverStats = await this.fetchServerStatus();
            
            // 3. è®¡ç®—ç»¼åˆæŒ‡æ ‡
            const metrics = this.calculateMetrics(playerStats, serverStats);
            
            // 4. æ›´æ–°æ˜¾ç¤º
            this.updateMetricsDisplay(metrics);
            
            // 5. è®°å½•å†å²æ•°æ®
            this.metricsHistory.push({
                timestamp: Date.now(),
                ...metrics
            });
            
            // 6. ä¿æŒå†å²æ•°æ®å¤§å°é™åˆ¶
            if (this.metricsHistory.length > 300) { // 5åˆ†é’Ÿå†å²
                this.metricsHistory.shift();
            }
            
        } catch (error) {
            console.error('Error updating status:', error);
        }
    }
    
    // è·å–æœåŠ¡å™¨çŠ¶æ€
    async fetchServerStatus() {
        const response = await this.player.http3Client.get(
            `/api/v1/stream/${this.sessionId}/status`
        );
        return response.data;
    }
    
    // è®¡ç®—ç»¼åˆæŒ‡æ ‡
    calculateMetrics(playerStats, serverStats) {
        return {
            latency: serverStats.end_to_end_latency_ms,
            bufferHealth: playerStats.buffer_duration_seconds,
            currentBitrate: playerStats.current_bitrate_mbps,
            packetLossRate: serverStats.packet_loss_rate * 100,
            resolution: `${playerStats.video_width}x${playerStats.video_height}`,
            frameRate: playerStats.current_fps,
            playbackPosition: playerStats.current_time_seconds,
            totalDuration: playerStats.total_duration_seconds || 0,
        };
    }
}
```

## 7. è®¾å¤‡ç«¯è®¾è®¡ï¼ˆç®€è¦ï¼‰

### 7.1 è®¾å¤‡ç«¯æ¶æ„æ¦‚è§ˆ

è®¾å¤‡ç«¯åŸºäºRustå®ç°ï¼Œä½¿ç”¨QUICåè®®ä¸å¹³å°ç«¯é€šä¿¡ï¼Œå…·å¤‡å®Œæ•´çš„è§†é¢‘æµä¼ è¾“å’Œæ’­æ”¾æ§åˆ¶èƒ½åŠ›ã€‚

```mermaid
graph TB
    subgraph è®¾å¤‡ç«¯æ ¸å¿ƒæ¨¡å—
        subgraph ä¼ è¾“å±‚
            QUIC[QUICä¼ è¾“<br/>DefaultQUICTransport]
            CONN[è¿æ¥ç®¡ç†<br/>QUICConnection]
            STREAM[æµç®¡ç†<br/>QUICStream]
        end
        
        subgraph ä¸šåŠ¡å±‚
            UPLOADER[æŒ‰éœ€ä¸Šä¼ å™¨<br/>OnDemandUploader]
            CONTROLLER[æ’­æ”¾æ§åˆ¶å™¨<br/>PlaybackController]
            MONITOR[æ€§èƒ½ç›‘æ§<br/>PerformanceMonitor]
        end
        
        subgraph å¤„ç†å±‚
            SEGMENTER[åˆ†ç‰‡å™¨<br/>Segmenter]
            READER[æ–‡ä»¶è¯»å–å™¨<br/>FileReader]
            INDEX[å…³é”®å¸§ç´¢å¼•<br/>KeyframeIndex]
        end
        
        subgraph é…ç½®å±‚
            CONFIG[é…ç½®ç®¡ç†<br/>Config]
            ERROR[é”™è¯¯å¤„ç†<br/>ErrorHandler]
            RECOVERY[æ¢å¤æœºåˆ¶<br/>RecoveryState]
        end
    end
    
    UPLOADER --> QUIC
    UPLOADER --> CONTROLLER
    UPLOADER --> SEGMENTER
    
    CONTROLLER --> INDEX
    CONTROLLER --> READER
    
    SEGMENTER --> READER
    
    QUIC --> CONN
    CONN --> STREAM
    
    UPLOADER --> MONITOR
    UPLOADER --> CONFIG
    UPLOADER --> ERROR
    
    ERROR --> RECOVERY
    
    style QUIC fill:#bbdefb
    style UPLOADER fill:#ffccbc
    style CONTROLLER fill:#c5e1a5
    style SEGMENTER fill:#fff9c4
    style INDEX fill:#f8bbd0
```

### 7.2 æ ¸å¿ƒç»„ä»¶å®ç°

#### 7.2.1 QUICä¼ è¾“å±‚

åŸºäºQuinnåº“å®ç°çš„é«˜æ€§èƒ½QUICä¼ è¾“ï¼š

```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/transport.rs
pub trait QUICTransport {
    // å»ºç«‹è¿æ¥
    async fn connect(
        &self,
        server_address: SocketAddr,
        options: QUICOptions,
    ) -> Result<QUICConnection, TransportError>;
    
    // å‘é€åˆ†ç‰‡
    async fn send_segment(
        &self,
        connection: &mut QUICConnection,
        segment: Segment,
    ) -> Result<(), TransportError>;
    
    // é…ç½®éŸ³é¢‘æµï¼ˆä½å»¶è¿Ÿä¼˜å…ˆï¼‰
    async fn configure_audio_stream(
        &self,
        connection: &mut QUICConnection,
        stream: &mut QUICStream,
    ) -> Result<(), TransportError>;
    
    // é…ç½®è§†é¢‘æµï¼ˆé«˜ååé‡ä¼˜å…ˆï¼‰
    async fn configure_video_stream(
        &self,
        connection: &mut QUICConnection,
        stream: &mut QUICStream,
    ) -> Result<(), TransportError>;
    
    // ç›‘æ§å’Œè‡ªé€‚åº”è°ƒæ•´
    async fn monitor_and_adjust(
        &self,
        connection: &mut QUICConnection,
    ) -> Result<NetworkConditions, TransportError>;
    
    // è¿æ¥æ¢å¤
    async fn recover_connection(
        &self,
        server_address: SocketAddr,
        options: QUICOptions,
        recovery_state: &mut RecoveryState,
    ) -> Result<QUICConnection, TransportError>;
}
```

**QUICé…ç½®ä¼˜åŒ–**ï¼š
```rust
// ä½å»¶è¿Ÿä¼˜åŒ–é…ç½®
let mut transport_config = quinn::TransportConfig::default();
transport_config.max_concurrent_uni_streams(100.into());
transport_config.stream_receive_window(5_000_000.try_into().unwrap()); // 5MB
transport_config.receive_window(50_000_000.try_into().unwrap());       // 50MB
transport_config.keep_alive_interval(Some(Duration::from_secs(5)));
```

#### 7.2.2 æ’­æ”¾æ§åˆ¶å™¨

å®ç°ç²¾ç¡®çš„æ’­æ”¾æ§åˆ¶åŠŸèƒ½ï¼š

```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/controller.rs
pub trait PlaybackController {
    // åŸºæœ¬å®šä½
    async fn seek(&mut self, position: f64) -> Result<(), PlaybackError>;
    
    // å…³é”®å¸§å®šä½ï¼ˆç²¾ç¡®ï¼‰
    async fn seek_to_keyframe(
        &mut self, 
        position: f64, 
        index: &KeyframeIndex
    ) -> Result<SeekResult, PlaybackError>;
    
    // è®¾ç½®æ’­æ”¾é€Ÿç‡
    async fn set_playback_rate(&mut self, rate: f64) -> Result<(), PlaybackError>;
    
    // è·å–å¸§ä¸¢å¼ƒç­–ç•¥
    fn get_drop_frame_strategy(&self, rate: f64) -> DropFrameStrategy;
    
    // è°ƒæ•´ä¼ è¾“é˜Ÿåˆ—
    fn adjust_transmission_queue(
        &self,
        segments: Vec<VideoSegment>,
        playback_rate: f64,
    ) -> Vec<VideoSegment>;
    
    // æ¸…é™¤ç¼“å†²åŒº
    fn clear_buffers(&mut self) -> Result<(), PlaybackError>;
}
```

**å¸§ä¸¢å¼ƒç­–ç•¥**ï¼ˆæ ¹æ®å€é€Ÿè‡ªåŠ¨è°ƒæ•´ï¼‰ï¼š
```rust
// æ¥è‡ªè®¾å¤‡ç«¯å®ç°
match rate {
    r if r <= 1.0 => DropFrameStrategy {
        drop_b_frames: false,
        drop_p_frames: false,
        keep_key_frames_only: false,
        adaptive_dropping: false,
    },
    r if r <= 2.0 => DropFrameStrategy {
        drop_b_frames: true,      // ä¸¢å¼ƒBå¸§
        drop_p_frames: false,
        keep_key_frames_only: false,
        adaptive_dropping: true,
    },
    r if r <= 4.0 => DropFrameStrategy {
        drop_b_frames: true,
        drop_p_frames: true,      // ä¸¢å¼ƒBå¸§å’ŒPå¸§
        keep_key_frames_only: false,
        adaptive_dropping: true,
    },
    _ => DropFrameStrategy {
        drop_b_frames: true,
        drop_p_frames: true,
        keep_key_frames_only: true,  // ä»…ä¿ç•™å…³é”®å¸§
        adaptive_dropping: true,
    },
}
```

#### 7.2.3 å…³é”®å¸§ç´¢å¼•ç®¡ç†

æ”¯æŒå¤šç§ç´¢å¼•ä¼˜åŒ–ç­–ç•¥ï¼š

```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub struct KeyframeIndex {
    pub entries: Vec<KeyframeEntry>,
    pub total_duration: f64,
    pub index_precision: f64,        // ç´¢å¼•ç²¾åº¦ï¼Œæ”¯æŒäºšç§’çº§
    pub memory_optimized: bool,
    pub optimization_strategy: IndexOptimizationStrategy,
    pub memory_usage: usize,
}

pub struct KeyframeEntry {
    pub timestamp: f64,              // æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
    pub file_offset: u64,            // æ–‡ä»¶åç§»ä½ç½®
    pub frame_size: u32,             // å…³é”®å¸§å¤§å°
    pub gop_size: u32,               // GOPå¤§å°
    pub frame_type: FrameType,       // å¸§ç±»å‹ï¼ˆI/P/Bï¼‰
}

pub enum IndexOptimizationStrategy {
    Full,           // å®Œæ•´ç´¢å¼•ï¼Œæ‰€æœ‰å…³é”®å¸§
    Sparse,         // ç¨€ç–ç´¢å¼•ï¼Œå®šæœŸé‡‡æ ·
    Adaptive,       // è‡ªé€‚åº”ï¼Œæ ¹æ®å†…å­˜åŠ¨æ€è°ƒæ•´
    Hierarchical,   // åˆ†å±‚ç´¢å¼•ï¼Œå¤šçº§ç²¾åº¦
}
```

**SEEKæ€§èƒ½**ï¼š
```rust
pub struct SeekResult {
    pub requested_time: f64,         // è¯·æ±‚çš„æ—¶é—´ä½ç½®
    pub actual_time: f64,            // å®é™…å®šä½åˆ°çš„æ—¶é—´
    pub keyframe_offset: u64,        // å…³é”®å¸§æ–‡ä»¶åç§»
    pub precision_achieved: f64,     // å®šä½ç²¾åº¦ï¼ˆ0-1ï¼‰
    pub keyframe_used: KeyframeEntry,
    pub execution_time: Duration,    // æ‰§è¡Œè€—æ—¶
}
```

#### 7.2.4 æ™ºèƒ½åˆ†ç‰‡å™¨

æ ¹æ®æ–‡ä»¶æ ¼å¼è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜åˆ†ç‰‡ç­–ç•¥ï¼š

```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/segmenter.rs
pub enum SegmentMode {
    Frame,      // å¸§çº§åˆ†ç‰‡ï¼ˆH.264ï¼‰
    Gop,        // GOPçº§åˆ†ç‰‡
    Time,       // æ—¶é—´åˆ†ç‰‡
}

pub struct SegmentOptions {
    pub segment_mode: SegmentMode,
    pub target_size: Option<usize>,
    pub max_frames_per_segment: Option<usize>,
}
```

**åˆ†ç‰‡ç­–ç•¥**ï¼š
- **H.264æ–‡ä»¶**: å¸§çº§åˆ†ç‰‡ï¼Œæä½å»¶è¿Ÿ
- **MP4æ–‡ä»¶**: 256KBå›ºå®šåˆ†ç‰‡ï¼Œé«˜ååé‡
- **é€šç”¨æ–‡ä»¶**: 512KBåˆ†ç‰‡ï¼Œå…¼å®¹æ€§æ¨¡å¼

#### 7.2.5 ç½‘ç»œè‡ªé€‚åº”

å®æ—¶ç›‘æ§ç½‘ç»œæ¡ä»¶å¹¶è‡ªåŠ¨è°ƒæ•´ï¼š

```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub struct NetworkConditions {
    pub bandwidth_estimate: u64,
    pub rtt: Duration,
    pub packet_loss_rate: f64,
    pub jitter: Duration,
    pub congestion_level: CongestionLevel,
}

pub enum CongestionLevel {
    Low,        // < 1% ä¸¢åŒ…ç‡
    Medium,     // 1-2% ä¸¢åŒ…ç‡
    High,       // 2-5% ä¸¢åŒ…ç‡
    Critical,   // > 5% ä¸¢åŒ…ç‡
}
```

**è‡ªé€‚åº”ç­–ç•¥**ï¼š
```rust
// æ ¹æ®æ‹¥å¡ç­‰çº§è°ƒæ•´ä¼ è¾“å‚æ•°
match congestion_level {
    CongestionLevel::Critical => {
        // ä¸¥é‡æ‹¥å¡ï¼šå¤§å¹…é™ä½ä¼ è¾“é€Ÿç‡
        adjust_transmission_rate(0.25);
    }
    CongestionLevel::High => {
        // é«˜æ‹¥å¡ï¼šé€‚åº¦é™ä½
        adjust_transmission_rate(0.5);
    }
    CongestionLevel::Medium => {
        // ä¸­ç­‰æ‹¥å¡ï¼šè½»å¾®è°ƒæ•´
        adjust_transmission_rate(0.75);
    }
    CongestionLevel::Low => {
        // ä½æ‹¥å¡ï¼šæœ€å¤§åŒ–ååé‡
        adjust_transmission_rate(1.0);
    }
}
```

#### 7.2.6 é”™è¯¯æ¢å¤æœºåˆ¶

æ”¯æŒå¤šç§æ¢å¤ç­–ç•¥ï¼š

```rust
// æ¥è‡ªè®¾å¤‡ç«¯ src/types.rs
pub struct RecoveryState {
    pub last_successful_segment: Option<Uuid>,
    pub retry_count: u32,
    pub max_retries: u32,
    pub backoff_duration: Duration,
    pub recovery_strategy: RecoveryStrategy,
}

pub enum RecoveryStrategy {
    Immediate,           // ç«‹å³é‡è¯•
    ExponentialBackoff,  // æŒ‡æ•°é€€é¿ï¼ˆæ¨èï¼‰
    LinearBackoff,       // çº¿æ€§é€€é¿
    AdaptiveBackoff,     // è‡ªé€‚åº”é€€é¿
}
```

**æŒ‡æ•°é€€é¿å®ç°**ï¼š
```rust
let backoff_duration = Duration::from_millis(100 * 2_u64.pow(retry_count));
// retry_count=0: 100ms
// retry_count=1: 200ms
// retry_count=2: 400ms
// retry_count=3: 800ms
// retry_count=4: 1600ms
```

### 7.3 æ€§èƒ½ç‰¹æ€§

#### 7.3.1 ä¼ è¾“æ€§èƒ½

| æŒ‡æ ‡ | H.264æ–‡ä»¶ | MP4æ–‡ä»¶ | è¯´æ˜ |
|------|----------|---------|------|
| åˆ†ç‰‡æ¨¡å¼ | å¸§çº§ | å›ºå®š256KB | è‡ªåŠ¨é€‰æ‹© |
| å¹³å‡åˆ†ç‰‡å¤§å° | 2-50KB | 256KB | å˜é•¿/å®šé•¿ |
| ä¼ è¾“é—´éš” | æœ€å¤§é€Ÿåº¦ | æœ€å¤§é€Ÿåº¦ | æ— äººä¸ºå»¶è¿Ÿ |
| å³°å€¼ååé‡ | 109.2Mbps | 896.5Mbps | å®æµ‹æ•°æ® |
| å¹³å‡ååé‡ | 9.4Mbps | 50Mbps | å®æµ‹æ•°æ® |

#### 7.3.2 SEEKæ€§èƒ½

| æŒ‡æ ‡ | æ•°å€¼ | è¯´æ˜ |
|------|------|------|
| ç´¢å¼•æ„å»ºæ—¶é—´ | < 100ms | 1å°æ—¶è§†é¢‘ |
| SEEKæ‰§è¡Œæ—¶é—´ | < 20ms | ç²¾ç¡®å®šä½ |
| å®šä½ç²¾åº¦ | > 99% | å…³é”®å¸§çº§åˆ« |
| å†…å­˜å ç”¨ | < 1MB | 1å°æ—¶è§†é¢‘ç´¢å¼• |

#### 7.3.3 æ’­æ”¾æ§åˆ¶å“åº”

| æ“ä½œ | å“åº”æ—¶é—´ | è¯´æ˜ |
|------|---------|------|
| SEEK | < 20ms | æŸ¥æ‰¾å…³é”®å¸§ |
| å€é€Ÿåˆ‡æ¢ | < 5ms | è°ƒæ•´ç­–ç•¥ |
| æš‚åœ/æ¢å¤ | < 1ms | ç«‹å³å“åº” |
| åœæ­¢ | < 10ms | æ¸…ç†èµ„æº |

### 7.4 é…ç½®ç¤ºä¾‹

```toml
# device-simulator/config.toml
[device]
device_id = "device_001"
device_name = "æ¨¡æ‹Ÿæ‘„åƒå¤´-01"
device_type = "simulator"

[connection]
platform_url = "127.0.0.1:8080"
reconnect_interval_sec = 5
max_retries = 5
recovery_strategy = "ExponentialBackoff"

[video]
test_videos_path = "./test_videos"
default_resolution = "1920x1080"
default_frame_rate = 30.0
segment_mode = "auto"  # auto, frame, gop, time

[performance]
enable_monitoring = true
stats_interval_sec = 10
enable_network_adaptation = true

[keyframe_index]
optimization_strategy = "Adaptive"  # Full, Sparse, Adaptive, Hierarchical
memory_limit_mb = 100
index_precision = 0.1  # 0.1ç§’ç²¾åº¦
```

## 8. å»¶è¿Ÿç›‘æ§è®¾è®¡

### 8.1 å»¶è¿Ÿç›‘æ§æ¶æ„

```
è®¾å¤‡ç«¯æ—¶é—´æˆ³ â†’ å¹³å°ç«¯æ¥æ”¶æ—¶é—´æˆ³ â†’ å¹³å°ç«¯è½¬å‘æ—¶é—´æˆ³ â†’ å‰ç«¯æ’­æ”¾æ—¶é—´æˆ³
     â†“              â†“                â†“                â†“
  T1(å‘é€)      T2(æ¥æ”¶)         T3(è½¬å‘)         T4(æ’­æ”¾)

å»¶è¿Ÿè®¡ç®—:
- ä¼ è¾“å»¶è¿Ÿ = T2 - T1
- å¤„ç†å»¶è¿Ÿ = T3 - T2  
- åˆ†å‘å»¶è¿Ÿ = T4 - T3
- ç«¯åˆ°ç«¯å»¶è¿Ÿ = T4 - T1
```

### 8.2 å»¶è¿Ÿç›‘æ§å®ç°

```rust
pub struct EndToEndLatencyMonitor {
    device_timestamps: HashMap<Uuid, SystemTime>,
    platform_receive_timestamps: HashMap<Uuid, SystemTime>,
    platform_forward_timestamps: HashMap<Uuid, SystemTime>,
    client_play_timestamps: HashMap<Uuid, SystemTime>,
    latency_alerts: LatencyAlertManager,
}

impl EndToEndLatencyMonitor {
    // è®°å½•è®¾å¤‡ç«¯å‘é€æ—¶é—´æˆ³
    pub fn record_device_send(&mut self, segment_id: Uuid, timestamp: SystemTime) {
        self.device_timestamps.insert(segment_id, timestamp);
    }
    
    // è®°å½•å¹³å°ç«¯æ¥æ”¶æ—¶é—´æˆ³
    pub fn record_platform_receive(&mut self, segment_id: Uuid, timestamp: SystemTime) {
        self.platform_receive_timestamps.insert(segment_id, timestamp);
        
        // è®¡ç®—ä¼ è¾“å»¶è¿Ÿ
        if let Some(device_time) = self.device_timestamps.get(&segment_id) {
            let transmission_latency = timestamp.duration_since(*device_time).unwrap_or_default();
            
            // æ£€æŸ¥ä¼ è¾“å»¶è¿Ÿé˜ˆå€¼
            if transmission_latency > Duration::from_millis(100) {
                self.latency_alerts.trigger_transmission_alert(segment_id, transmission_latency);
            }
        }
    }
    
    // è®°å½•å¹³å°ç«¯è½¬å‘æ—¶é—´æˆ³
    pub fn record_platform_forward(&mut self, segment_id: Uuid, timestamp: SystemTime) {
        self.platform_forward_timestamps.insert(segment_id, timestamp);
        
        // è®¡ç®—å¤„ç†å»¶è¿Ÿ
        if let Some(receive_time) = self.platform_receive_timestamps.get(&segment_id) {
            let processing_latency = timestamp.duration_since(*receive_time).unwrap_or_default();
            
            // æ£€æŸ¥å¤„ç†å»¶è¿Ÿé˜ˆå€¼
            if processing_latency > Duration::from_millis(50) {
                self.latency_alerts.trigger_processing_alert(segment_id, processing_latency);
            }
        }
    }
    
    // è®°å½•å®¢æˆ·ç«¯æ’­æ”¾æ—¶é—´æˆ³
    pub fn record_client_play(&mut self, segment_id: Uuid, timestamp: SystemTime) {
        self.client_play_timestamps.insert(segment_id, timestamp);
        
        // è®¡ç®—ç«¯åˆ°ç«¯å»¶è¿Ÿ
        if let Some(device_time) = self.device_timestamps.get(&segment_id) {
            let end_to_end_latency = timestamp.duration_since(*device_time).unwrap_or_default();
            
            // æ£€æŸ¥ç«¯åˆ°ç«¯å»¶è¿Ÿé˜ˆå€¼
            if end_to_end_latency > Duration::from_millis(200) {
                self.latency_alerts.trigger_end_to_end_alert(segment_id, end_to_end_latency);
            }
            
            // è®°å½•æˆåŠŸçš„ç«¯åˆ°ç«¯æµ‹é‡
            self.record_successful_measurement(segment_id, end_to_end_latency);
        }
    }
}
```

## 8. æµ‹è¯•æ–¹æ¡ˆè®¾è®¡

### 8.1 ç½‘ç»œæŠ–åŠ¨æ¨¡æ‹Ÿå·¥å…·

```rust
pub struct NetworkSimulator {
    packet_loss_rate: f64,      // ä¸¢åŒ…ç‡ (0.0-1.0)
    latency_base: Duration,     // åŸºç¡€å»¶è¿Ÿ
    latency_jitter: Duration,   // å»¶è¿ŸæŠ–åŠ¨
    bandwidth_limit: u64,       // å¸¦å®½é™åˆ¶ (bps)
    burst_loss_probability: f64, // çªå‘ä¸¢åŒ…æ¦‚ç‡
}

impl NetworkSimulator {
    // åˆ›å»ºé¢„è®¾æµ‹è¯•åœºæ™¯
    pub fn create_test_scenarios() -> Vec<NetworkSimulator> {
        vec![
            // ç†æƒ³ç½‘ç»œç¯å¢ƒ
            NetworkSimulator {
                packet_loss_rate: 0.0,
                latency_base: Duration::from_millis(10),
                latency_jitter: Duration::from_millis(2),
                bandwidth_limit: 100_000_000, // 100 Mbps
                burst_loss_probability: 0.0,
            },
            
            // 2% ä¸¢åŒ…æµ‹è¯•
            NetworkSimulator {
                packet_loss_rate: 0.02,
                latency_base: Duration::from_millis(20),
                latency_jitter: Duration::from_millis(5),
                bandwidth_limit: 50_000_000, // 50 Mbps
                burst_loss_probability: 0.1,
            },
            
            // 5% ä¸¢åŒ…æµ‹è¯•
            NetworkSimulator {
                packet_loss_rate: 0.05,
                latency_base: Duration::from_millis(50),
                latency_jitter: Duration::from_millis(15),
                bandwidth_limit: 20_000_000, // 20 Mbps
                burst_loss_probability: 0.2,
            },
            
            // 10% ä¸¢åŒ…æµ‹è¯• (æç«¯ç¯å¢ƒ)
            NetworkSimulator {
                packet_loss_rate: 0.10,
                latency_base: Duration::from_millis(100),
                latency_jitter: Duration::from_millis(30),
                bandwidth_limit: 10_000_000, // 10 Mbps
                burst_loss_probability: 0.3,
            },
        ]
    }
    
    // æ¨¡æ‹Ÿç½‘ç»œä¼ è¾“
    pub async fn simulate_transmission(
        &self,
        data: Vec<u8>,
    ) -> Result<Vec<u8>, NetworkError> {
        // 1. æ¨¡æ‹Ÿä¸¢åŒ…
        if self.should_drop_packet() {
            return Err(NetworkError::PacketLost);
        }
        
        // 2. æ¨¡æ‹Ÿå»¶è¿Ÿå’ŒæŠ–åŠ¨
        let actual_latency = self.calculate_actual_latency();
        tokio::time::sleep(actual_latency).await;
        
        // 3. æ¨¡æ‹Ÿå¸¦å®½é™åˆ¶
        let transmission_time = self.calculate_transmission_time(data.len());
        tokio::time::sleep(transmission_time).await;
        
        // 4. æ¨¡æ‹Ÿæ•°æ®æŸå (æå°‘æ¦‚ç‡)
        if rand::random::<f64>() < 0.001 {
            return Err(NetworkError::DataCorrupted);
        }
        
        Ok(data)
    }
}
```

### 8.2 å»¶è¿Ÿæµ‹è¯•å·¥å…·

```rust
pub struct LatencyTestSuite {
    test_scenarios: Vec<TestScenario>,
    results: Vec<TestResult>,
    performance_targets: PerformanceTargets,
}

#[derive(Debug, Clone)]
pub struct PerformanceTargets {
    pub max_end_to_end_latency: Duration,      // 200ms
    pub max_transmission_latency: Duration,     // 100ms
    pub max_processing_latency: Duration,       // 50ms
    pub min_throughput_mbps: f64,              // 5 Mbps
    pub max_packet_loss_tolerance: f64,        // 10%
}

impl LatencyTestSuite {
    // æ‰§è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
    pub async fn run_full_test_suite(&mut self) -> TestSuiteResult {
        let mut all_passed = true;
        
        for scenario in &self.test_scenarios {
            println!("Running test scenario: {}", scenario.name);
            
            let result = self.run_single_test(scenario).await;
            let passed = self.evaluate_test_result(&result);
            
            if !passed {
                all_passed = false;
                println!("âŒ Test scenario '{}' FAILED", scenario.name);
            } else {
                println!("âœ… Test scenario '{}' PASSED", scenario.name);
            }
            
            self.results.push(result);
        }
        
        // ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
        let report = self.generate_test_report();
        
        TestSuiteResult {
            all_tests_passed: all_passed,
            individual_results: self.results.clone(),
            summary_report: report,
        }
    }
    
    // æ‰§è¡Œå•ä¸ªæµ‹è¯•åœºæ™¯
    async fn run_single_test(&self, scenario: &TestScenario) -> TestResult {
        let start_time = Instant::now();
        let mut measurements = Vec::new();
        
        // è®¾ç½®ç½‘ç»œæ¨¡æ‹Ÿå™¨
        let network_sim = NetworkSimulator {
            packet_loss_rate: scenario.packet_loss_rate,
            latency_base: scenario.base_latency,
            latency_jitter: scenario.jitter,
            bandwidth_limit: scenario.bandwidth_limit,
            burst_loss_probability: scenario.burst_loss_probability,
        };
        
        // è¿è¡Œæµ‹è¯•æŒç»­æ—¶é—´
        let test_duration = Duration::from_secs(60); // 1åˆ†é’Ÿæµ‹è¯•
        let mut segment_count = 0;
        
        while start_time.elapsed() < test_duration {
            // 1. ç”Ÿæˆæµ‹è¯•è§†é¢‘åˆ†ç‰‡
            let test_segment = self.generate_test_segment(segment_count);
            
            // 2. æ¨¡æ‹Ÿç«¯åˆ°ç«¯ä¼ è¾“
            let measurement = self.measure_end_to_end_latency(
                test_segment,
                &network_sim,
            ).await;
            
            if let Ok(measurement) = measurement {
                measurements.push(measurement);
            }
            
            segment_count += 1;
            
            // æ§åˆ¶å‘é€é¢‘ç‡ (30 FPS)
            tokio::time::sleep(Duration::from_millis(33)).await;
        }
        
        // è®¡ç®—æµ‹è¯•ç»“æœç»Ÿè®¡
        TestResult {
            scenario_name: scenario.name.clone(),
            total_segments: segment_count,
            successful_measurements: measurements.len(),
            packet_loss_rate: 1.0 - (measurements.len() as f64 / segment_count as f64),
            average_latency: self.calculate_average_latency(&measurements),
            p95_latency: self.calculate_percentile_latency(&measurements, 0.95),
            p99_latency: self.calculate_percentile_latency(&measurements, 0.99),
            max_latency: measurements.iter().map(|m| m.end_to_end_latency).max().unwrap_or_default(),
            min_latency: measurements.iter().map(|m| m.end_to_end_latency).min().unwrap_or_default(),
            throughput_mbps: self.calculate_throughput(&measurements),
            test_duration: start_time.elapsed(),
        }
    }
}
```

## 9. éƒ¨ç½²å’Œè¿ç»´

### 10.1 ç³»ç»Ÿéƒ¨ç½²æ¶æ„ï¼ˆDemoå•æœºç‰ˆæœ¬ï¼‰

**éƒ¨ç½²ç‰¹ç‚¹**ï¼š
- å•æœºæœ¬åœ°éƒ¨ç½²ï¼Œæ— éœ€Docker
- æ— éœ€æ•°æ®åº“å’Œä¸­é—´ä»¶
- ç®€åŒ–é…ç½®ï¼Œå¿«é€Ÿå¯åŠ¨

#### 10.1.1 ç›®å½•ç»“æ„

```
video-streaming-demo/
â”œâ”€â”€ platform-server/          # å¹³å°ç«¯æœåŠ¡å™¨ï¼ˆRustï¼‰
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ config.toml
â”œâ”€â”€ device-simulator/         # è®¾å¤‡æ¨¡æ‹Ÿå™¨ï¼ˆRustï¼‰
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ test-videos/         # æµ‹è¯•è§†é¢‘æ–‡ä»¶
â”œâ”€â”€ web-frontend/            # Webå‰ç«¯ï¼ˆReact + TypeScriptï¼‰
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ tsconfig.json
â”œâ”€â”€ recordings/              # å½•åƒæ–‡ä»¶å­˜å‚¨ç›®å½•
â”‚   â””â”€â”€ device_001/
â”‚       â””â”€â”€ 2025/12/11/
â””â”€â”€ logs/                    # æ—¥å¿—æ–‡ä»¶ç›®å½•
```

#### 10.1.2 å¯åŠ¨æ­¥éª¤

```bash
# 1. å¯åŠ¨å¹³å°ç«¯æœåŠ¡å™¨
cd platform-server
cargo run --release

# 2. å¯åŠ¨è®¾å¤‡æ¨¡æ‹Ÿå™¨
cd device-simulator
cargo run --release

# 3. å¯åŠ¨Webå‰ç«¯
cd web-frontend
npm install
npm start

# è®¿é—® http://localhost:3000
```

#### 10.1.3 é…ç½®æ–‡ä»¶

**å¹³å°ç«¯é…ç½® (platform-server/config.toml)**ï¼š
```toml
[server]
# å•ä¸€æœåŠ¡è¿›ç¨‹ï¼Œç›‘å¬ä¸¤ä¸ªç«¯å£
quic_port = 8080              # QUICç«¯å£ï¼ˆè®¾å¤‡ç«¯è¿æ¥ï¼‰
http3_port = 8443             # HTTP3ç«¯å£ï¼ˆå‰ç«¯è¿æ¥ï¼‰
max_concurrent_streams = 100
latency_threshold_ms = 200

[storage]
recordings_root = "../recordings"  # å½•åƒæ–‡ä»¶æ ¹ç›®å½•
cache_size_mb = 1024               # è§†é¢‘åˆ†ç‰‡ç¼“å­˜å¤§å°ï¼ˆ1GBï¼‰

[recording_manager]
scan_interval_sec = 300       # å½•åƒæ‰«æé—´éš”ï¼ˆ5åˆ†é’Ÿï¼‰
metadata_cache_size = 10000   # å…ƒæ•°æ®ç¼“å­˜æ•°é‡ï¼ˆçº¦5MBï¼‰

[logging]
level = "info"
log_dir = "../logs"

[demo]
no_auth = true                # Demoæ¨¡å¼ï¼šæ— éœ€è®¤è¯
in_memory_storage = true      # ä½¿ç”¨å†…å­˜å­˜å‚¨
```

**è®¾å¤‡æ¨¡æ‹Ÿå™¨é…ç½® (device-simulator/config.toml)**ï¼š
```toml
[device]
device_id = "device_001"
device_name = "æ¨¡æ‹Ÿæ‘„åƒå¤´-01"
device_type = "simulator"

[connection]
platform_url = "quic://127.0.0.1:8080"
reconnect_interval_sec = 5

[video]
test_videos_path = "./test-videos"
default_resolution = "1920x1080"
default_frame_rate = 30.0
```

**å‰ç«¯é…ç½® (web-frontend/.env)**ï¼š
```env
REACT_APP_PLATFORM_URL=https://localhost:8443
REACT_APP_WS_URL=wss://localhost:8443
REACT_APP_DEMO_MODE=true
```

### 10.2 ç›‘æ§æŒ‡æ ‡å®šä¹‰ï¼ˆDemoç®€åŒ–ç‰ˆæœ¬ï¼‰

**Demoç‰ˆæœ¬ç‰¹ç‚¹**ï¼š
- æ§åˆ¶å°æ—¥å¿—è¾“å‡º
- ç®€å•çš„æ€§èƒ½ç»Ÿè®¡
- æ— éœ€Prometheus/Grafana

```rust
// Demoç‰ˆæœ¬ï¼šç®€åŒ–çš„ç›‘æ§æŒ‡æ ‡
#[derive(Debug, Clone, Serialize)]
pub struct SystemMetrics {
    // æ ¸å¿ƒå»¶è¿ŸæŒ‡æ ‡
    pub end_to_end_latency_avg_ms: f64,
    pub end_to_end_latency_max_ms: f64,
    
    // ååé‡æŒ‡æ ‡
    pub total_throughput_mbps: f64,
    pub peak_throughput_mbps: f64,
    
    // å¯é æ€§æŒ‡æ ‡
    pub packet_loss_rate: f64,
    pub segment_success_rate: f64,
    
    // èµ„æºä½¿ç”¨æŒ‡æ ‡ï¼ˆç®€åŒ–ï¼‰
    pub memory_usage_mb: f64,
    pub cache_hit_rate: f64,
    
    // ä¸šåŠ¡æŒ‡æ ‡
    pub active_device_connections: u32,
    pub active_web_clients: u32,
    pub concurrent_streams: u32,
}

impl SystemMetrics {
    // Demoç‰ˆæœ¬ï¼šæ§åˆ¶å°è¾“å‡º
    pub fn print_summary(&self) {
        println!("=== ç³»ç»Ÿæ€§èƒ½ç›‘æ§ ===");
        println!("å»¶è¿Ÿ: å¹³å‡ {:.1}ms, æœ€å¤§ {:.1}ms", 
                 self.end_to_end_latency_avg_ms, 
                 self.end_to_end_latency_max_ms);
        println!("ååé‡: {:.1} Mbps (å³°å€¼ {:.1} Mbps)", 
                 self.total_throughput_mbps, 
                 self.peak_throughput_mbps);
        println!("ä¸¢åŒ…ç‡: {:.2}%", self.packet_loss_rate * 100.0);
        println!("å†…å­˜ä½¿ç”¨: {:.1} MB", self.memory_usage_mb);
        println!("ç¼“å­˜å‘½ä¸­ç‡: {:.1}%", self.cache_hit_rate * 100.0);
        println!("æ´»è·ƒè¿æ¥: {} è®¾å¤‡, {} å®¢æˆ·ç«¯, {} æµ", 
                 self.active_device_connections,
                 self.active_web_clients,
                 self.concurrent_streams);
        println!("==================");
    }
}
```

## 11. æ€»ç»“å’Œåç»­è®¡åˆ’

### 11.1 æ¶æ„ä¼˜åŠ¿

#### 11.1.1 åŸæœ‰æ¶æ„ä¼˜åŠ¿
1. **åè®®ä¼˜åŒ–**: è®¾å¤‡ç«¯QUICä½å»¶è¿Ÿï¼Œå‰ç«¯HTTP3æ ‡å‡†åŒ–
2. **åˆ†å±‚è®¾è®¡**: æ¸…æ™°çš„èŒè´£åˆ†ç¦»ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
3. **æ€§èƒ½ç›‘æ§**: å…¨é“¾è·¯å»¶è¿Ÿç›‘æ§ï¼Œå®æ—¶æ€§èƒ½ä¼˜åŒ–
4. **å®¹é”™æœºåˆ¶**: å¤šå±‚æ¬¡é”™è¯¯æ¢å¤ï¼Œç½‘ç»œæŠ–åŠ¨é€‚åº”
5. **å¯æ‰©å±•æ€§**: æ”¯æŒå¤šè®¾å¤‡ã€å¤šå‰ç«¯çš„æ¨ªå‘æ‰©å±•

#### 11.1.2 ç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆæ–°å¢ä¼˜åŠ¿ï¼ˆv1.1æ›´æ–°ï¼‰

**ğŸš€ æ€§èƒ½æå‡**ï¼š
1. **å½•åƒå›æ”¾å»¶è¿Ÿ**: ä»2000msé™åˆ°107msï¼ˆ**18å€æå‡**ï¼‰
2. **ç›´é€šæ’­æ”¾å»¶è¿Ÿ**: 188msï¼ˆæ»¡è¶³<200msç›®æ ‡ï¼‰
3. **å¹³å°ç«¯å¤„ç†**: <5msï¼ˆé›¶ç¼“å†²è½¬å‘ï¼‰
4. **é«˜å¹¶å‘æ”¯æŒ**: 100+å¹¶å‘æµä¼šè¯

**ğŸ¯ æ¶æ„ç»Ÿä¸€**ï¼š
1. **ä»£ç å¤ç”¨ç‡**: ç›´é€šå’Œå›æ”¾å…±äº«80%ä»¥ä¸Šä»£ç 
2. **ç»Ÿä¸€API**: å•ä¸€å¯åŠ¨ç«¯ç‚¹ï¼ˆ/api/v1/stream/startï¼‰
3. **ç»Ÿä¸€æ’­æ”¾å™¨**: å‰ç«¯UnifiedMSEPlayeræ”¯æŒä¸¤ç§æ¨¡å¼
4. **ç»Ÿä¸€ç›‘æ§**: å»¶è¿Ÿç›‘æ§å’Œç»Ÿè®¡é€»è¾‘å®Œå…¨å¤ç”¨

**ğŸ’¡ ç”¨æˆ·ä½“éªŒ**ï¼š
1. **å¿«é€Ÿå¯åŠ¨**: æœ€å°ç¼“å†²ï¼ˆ100-500msï¼‰ï¼Œå¿«é€Ÿå¼€å§‹æ’­æ”¾
2. **æµç•…æ’­æ”¾**: æ™ºèƒ½ç¼“å†²ç­–ç•¥ï¼Œé¿å…å¡é¡¿
3. **ç²¾ç¡®æ§åˆ¶**: æ”¯æŒæš‚åœã€å®šä½ã€å€é€Ÿç­‰å®Œæ•´æ§åˆ¶
4. **ä¸€è‡´ä½“éªŒ**: ç›´é€šå’Œå›æ”¾åˆ‡æ¢æ— æ„ŸçŸ¥

**ğŸ”§ å¼€å‘æ•ˆç‡**ï¼š
1. **æ˜“äºç»´æŠ¤**: å•ä¸€ä»£ç è·¯å¾„ï¼Œé™ä½ç»´æŠ¤æˆæœ¬
2. **æ˜“äºæµ‹è¯•**: ç»Ÿä¸€çš„æµ‹è¯•æ¡†æ¶å’Œç”¨ä¾‹
3. **æ˜“äºæ‰©å±•**: æ–°åŠŸèƒ½ï¼ˆå¤šéŸ³è½¨ã€å­—å¹•ï¼‰åªéœ€å®ç°ä¸€æ¬¡
4. **æ˜“äºè°ƒè¯•**: ç»Ÿä¸€çš„æ—¥å¿—å’Œç›‘æ§

### 11.2 å…³é”®æŠ€æœ¯åˆ›æ–°

#### 11.2.1 åŸæœ‰æŠ€æœ¯åˆ›æ–°
1. **åè®®è½¬æ¢**: QUIC â†” HTTP3æ— ç¼è½¬æ¢
2. **æ™ºèƒ½åˆ†å‘**: åŸºäºå®¢æˆ·ç«¯èƒ½åŠ›çš„è‡ªé€‚åº”è´¨é‡è°ƒæ•´
3. **è¾¹ç¼“å­˜**: å¹³å°ç«¯æ™ºèƒ½ç¼“å­˜ç­–ç•¥ï¼Œå‡å°‘å»¶è¿Ÿ
4. **å®æ—¶ç›‘æ§**: åŸºäºæ—¶é—´æˆ³çš„ç«¯åˆ°ç«¯å»¶è¿Ÿæµ‹é‡

#### 11.2.2 ç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆæŠ€æœ¯åˆ›æ–°ï¼ˆv1.1æ›´æ–°ï¼‰

**1. ç»Ÿä¸€æµå¤„ç†æ¶æ„**
```rust
// æ•°æ®æºæŠ½è±¡ï¼Œç»Ÿä¸€ç›´é€šå’Œå›æ”¾
trait StreamSource {
    async fn next_segment() -> VideoSegment;
    async fn seek(position: f64);
    async fn set_rate(rate: f64);
}

// ç»Ÿä¸€æµå¤„ç†å™¨
struct UnifiedStreamHandler {
    sessions: HashMap<Uuid, StreamSession>,
}
```

**2. é›¶ç¼“å†²è½¬å‘æœºåˆ¶**
- å¹³å°ç«¯è¾¹æ¥æ”¶è¾¹è½¬å‘ï¼Œæ— ç¼“å†²å»¶è¿Ÿ
- å¤„ç†å»¶è¿Ÿ<5ms
- ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯ï¼ˆIoSliceï¼‰
- å¹¶å‘è½¬å‘åˆ°å¤šä¸ªå®¢æˆ·ç«¯

**3. æ–‡ä»¶æµå¼è¯»å–**
- å°åˆ†ç‰‡è¯»å–ï¼ˆ8KB-32KBï¼‰
- é€Ÿç‡æ§åˆ¶ï¼ˆæ”¯æŒ0.25x-4xå€é€Ÿï¼‰
- å¼‚æ­¥IOä¼˜åŒ–
- ç²¾ç¡®å®šä½æ”¯æŒ

**4. æ™ºèƒ½ç¼“å†²ç­–ç•¥**
```typescript
// æ ¹æ®æ¨¡å¼è‡ªåŠ¨è°ƒæ•´ç¼“å†²
const targetBuffer = mode === 'live' ? 0.5 : 2.0  // ç§’
// è‡ªåŠ¨ç§»é™¤è¿‡å¤šç¼“å†²ï¼Œä¿æŒä½å»¶è¿Ÿ
if (bufferedAmount > targetBuffer + 1.0) {
    sourceBuffer.remove(0, removeEnd)
}
```

**5. HTTP3/SSEæ¨é€**
- ä½¿ç”¨Server-Sent Eventså®æ—¶æ¨é€
- æ”¯æŒHTTP3å¤šè·¯å¤ç”¨
- è‡ªåŠ¨é‡è¿æœºåˆ¶
- ä½å»¶è¿Ÿä¼˜åŒ–

### 11.3 å®æ–½è®¡åˆ’

#### 11.3.1 åŸæœ‰å®æ–½è®¡åˆ’
1. **ç¬¬ä¸€é˜¶æ®µ**: å¹³å°ç«¯æ ¸å¿ƒç»„ä»¶å¼€å‘ï¼ˆåè®®è½¬æ¢å™¨ã€åˆ†å‘ç®¡ç†å™¨ï¼‰
2. **ç¬¬äºŒé˜¶æ®µ**: å‰ç«¯æ’­æ”¾å™¨å’Œæ§åˆ¶ç•Œé¢å¼€å‘
3. **ç¬¬ä¸‰é˜¶æ®µ**: å»¶è¿Ÿç›‘æ§å’Œæµ‹è¯•å·¥å…·å¼€å‘
4. **ç¬¬å››é˜¶æ®µ**: ç³»ç»Ÿé›†æˆæµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–
5. **ç¬¬äº”é˜¶æ®µ**: éƒ¨ç½²å’Œè¿ç»´å·¥å…·å®Œå–„

#### 11.3.2 ç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆå®æ–½è®¡åˆ’ï¼ˆv1.1æ›´æ–°ï¼‰

**è¯¦ç»†å®æ–½è®¡åˆ’å‚è§**: `.kiro/specs/unified-low-latency-streaming/`

**é‡Œç¨‹ç¢‘1: æ ¸å¿ƒæ¶æ„ï¼ˆ2-3å‘¨ï¼‰**
- âœ… å®ç°UnifiedStreamHandler
- âœ… å®ç°StreamSource traitå’Œå®ç°ç±»
- âœ… å®ç°FileStreamReader
- âœ… å®ç°é›¶ç¼“å†²è½¬å‘æœºåˆ¶

**é‡Œç¨‹ç¢‘2: ä¼ è¾“å±‚ï¼ˆ1-2å‘¨ï¼‰**
- âœ… å®ç°HTTP3/SSEä¼ è¾“
- âœ… å®ç°fMP4è½¬æ¢å™¨
- âœ… å®ç°ç»Ÿä¸€APIç«¯ç‚¹

**é‡Œç¨‹ç¢‘3: å‰ç«¯æ’­æ”¾å™¨ï¼ˆ1-2å‘¨ï¼‰**
- âœ… å®ç°UnifiedMSEPlayer
- âœ… å®ç°æ™ºèƒ½ç¼“å†²ç­–ç•¥
- âœ… å®ç°æ’­æ”¾æ§åˆ¶UI

**é‡Œç¨‹ç¢‘4: ç›‘æ§å’Œæµ‹è¯•ï¼ˆ1å‘¨ï¼‰**
- âœ… å®ç°å»¶è¿Ÿç›‘æ§
- âœ… ç¼–å†™é›†æˆæµ‹è¯•
- âœ… ç¼–å†™å±æ€§æµ‹è¯•

**é‡Œç¨‹ç¢‘5: ä¼˜åŒ–å’Œå‘å¸ƒï¼ˆ1å‘¨ï¼‰**
- âœ… æ€§èƒ½ä¼˜åŒ–
- âœ… é”™è¯¯å¤„ç†å®Œå–„
- âœ… æ–‡æ¡£æ›´æ–°

**æ€»è®¡**: 6-9å‘¨å®Œæˆç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆå®æ–½

### 11.4 APIæ¥å£è§„èŒƒæ€»ç»“

#### 11.4.1 åŸæœ‰APIç«¯ç‚¹
```
è®¾å¤‡ç®¡ç†:
GET    /api/v1/devices                    # è·å–è®¾å¤‡åˆ—è¡¨
GET    /api/v1/devices/{device_id}        # è·å–è®¾å¤‡è¯¦æƒ…
POST   /api/v1/devices/{device_id}/control # è®¾å¤‡æ§åˆ¶

å½•åƒç®¡ç†:
GET    /api/v1/devices/{device_id}/recordings # è·å–å½•åƒåˆ—è¡¨
GET    /api/v1/recordings/{file_id}           # è·å–å½•åƒè¯¦æƒ…
DELETE /api/v1/recordings/{file_id}           # åˆ é™¤å½•åƒï¼ˆDemoç‰ˆæœ¬ä¸æ”¯æŒï¼‰

ç›´é€šæ’­æ”¾ï¼ˆæ—§æ–¹æ¡ˆï¼‰:
POST   /api/v1/devices/{device_id}/live-stream # å¼€å§‹ç›´é€šæ’­æ”¾
DELETE /api/v1/stream/{session_id}             # åœæ­¢ç›´é€šæ’­æ”¾

å½•åƒå›æ”¾ï¼ˆæ—§æ–¹æ¡ˆï¼‰:
POST   /api/v1/recordings/{file_id}/playback   # å¼€å§‹å½•åƒå›æ”¾
POST   /api/v1/playback/{session_id}/control   # å›æ”¾æ§åˆ¶

å®æ—¶äº‹ä»¶:
WSS    /api/v1/stream/{session_id}/events      # WebSocketäº‹ä»¶æµ
```

#### 11.4.2 ç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆAPIç«¯ç‚¹ï¼ˆv1.1æ–°å¢ï¼‰

```
ç»Ÿä¸€æµç®¡ç†:
POST   /api/v1/stream/start                    # ç»Ÿä¸€å¯åŠ¨æµï¼ˆç›´é€š/å›æ”¾ï¼‰
GET    /api/v1/stream/{session_id}/segments    # SSEè§†é¢‘åˆ†ç‰‡æµ
POST   /api/v1/stream/{session_id}/control     # ç»Ÿä¸€æ’­æ”¾æ§åˆ¶
GET    /api/v1/stream/{session_id}/status      # è·å–æµçŠ¶æ€
DELETE /api/v1/stream/{session_id}             # åœæ­¢æµ

å…¼å®¹æ€§:
ä¿ç•™åŸæœ‰APIç«¯ç‚¹ï¼Œå†…éƒ¨é‡å®šå‘åˆ°ç»Ÿä¸€API
```

**ç»Ÿä¸€å¯åŠ¨APIç¤ºä¾‹**:
```http
POST /api/v1/stream/start HTTP/3
Content-Type: application/json

// ç›´é€šæ’­æ”¾
{
  "mode": "live",
  "source": {"device_id": "device_001"},
  "config": {"low_latency_mode": true}
}

// å½•åƒå›æ”¾
{
  "mode": "playback",
  "source": {"file_id": "rec_001", "start_position": 0.0},
  "config": {"target_latency_ms": 200}
}
```

**ç»Ÿä¸€æ§åˆ¶APIç¤ºä¾‹**:
```http
POST /api/v1/stream/{session_id}/control HTTP/3
Content-Type: application/json

// æ”¯æŒæ‰€æœ‰æ§åˆ¶å‘½ä»¤
{"command": "pause"}
{"command": "resume"}
{"command": "seek", "position": 30.0}
{"command": "set_rate", "rate": 2.0}
{"command": "stop"}
```

#### 11.4.2 å‰ç«¯ç»„ä»¶æ¶æ„
```
HTTP3VideoPlayer (ä¸»æ’­æ”¾å™¨)
â”œâ”€â”€ DeviceManager (è®¾å¤‡ç®¡ç†)
â”‚   â”œâ”€â”€ getDevices() - è·å–è®¾å¤‡åˆ—è¡¨
â”‚   â”œâ”€â”€ startLiveStream() - å¼€å§‹ç›´é€šæ’­æ”¾
â”‚   â””â”€â”€ showDeviceDetails() - æ˜¾ç¤ºè®¾å¤‡è¯¦æƒ…
â”œâ”€â”€ RecordingManager (å½•åƒç®¡ç†)
â”‚   â”œâ”€â”€ getDeviceRecordings() - è·å–å½•åƒåˆ—è¡¨
â”‚   â”œâ”€â”€ playRecording() - æ’­æ”¾å½•åƒ
â”‚   â”œâ”€â”€ downloadRecording() - ä¸‹è½½å½•åƒ
â”‚   â””â”€â”€ deleteRecording() - åˆ é™¤å½•åƒ
â”œâ”€â”€ ControlPanel (æ’­æ”¾æ§åˆ¶)
â”‚   â”œâ”€â”€ togglePlayPause() - æ’­æ”¾/æš‚åœ
â”‚   â”œâ”€â”€ changePlaybackRate() - è°ƒæ•´æ’­æ”¾é€Ÿåº¦
â”‚   â”œâ”€â”€ seekTo() - æ‹–åŠ¨å®šä½
â”‚   â””â”€â”€ changeQuality() - è°ƒæ•´ç”»è´¨
â””â”€â”€ StatusMonitor (çŠ¶æ€ç›‘æ§)
    â”œâ”€â”€ updateStatus() - æ›´æ–°çŠ¶æ€æ˜¾ç¤º
    â”œâ”€â”€ fetchServerStatus() - è·å–æœåŠ¡å™¨çŠ¶æ€
    â””â”€â”€ calculateMetrics() - è®¡ç®—æ€§èƒ½æŒ‡æ ‡
```

#### 11.4.3 å¹³å°ç«¯æ ¸å¿ƒæ¨¡å—
```
ProtocolConverter (åè®®è½¬æ¢å™¨)
â”œâ”€â”€ DeviceRegistry (è®¾å¤‡æ³¨å†Œè¡¨)
â”œâ”€â”€ RecordingManager (å½•åƒç®¡ç†å™¨)
â”œâ”€â”€ LiveStreamHandler (ç›´é€šæ’­æ”¾å¤„ç†å™¨)
â””â”€â”€ PlaybackHandler (å›æ”¾å¤„ç†å™¨)

DistributionManager (åˆ†å‘ç®¡ç†å™¨)
â”œâ”€â”€ ClientSubscriptions (å®¢æˆ·ç«¯è®¢é˜…)
â”œâ”€â”€ QualityAdapter (è´¨é‡é€‚é…å™¨)
â””â”€â”€ LoadBalancer (è´Ÿè½½å‡è¡¡å™¨)

LatencyMonitor (å»¶è¿Ÿç›‘æ§å™¨)
â”œâ”€â”€ TimestampTracker (æ—¶é—´æˆ³è·Ÿè¸ª)
â”œâ”€â”€ PerformanceAnalyzer (æ€§èƒ½åˆ†æå™¨)
â””â”€â”€ AlertManager (å‘Šè­¦ç®¡ç†å™¨)
```

### 11.5 æŠ€æœ¯é€‰å‹è¯´æ˜ï¼ˆDemoç‰ˆæœ¬ï¼‰

#### 11.5.1 æ ¸å¿ƒæŠ€æœ¯æ ˆ
1. **HTTP3æœåŠ¡å™¨**: Quinn (Rust) - é«˜æ€§èƒ½QUICå®ç°
2. **è§†é¢‘ç¼–ç æ ¼å¼**: H.264ã€MP4 - å¹¿æ³›æ”¯æŒï¼Œå…¼å®¹æ€§å¥½
3. **å‰ç«¯æ¡†æ¶**: React + TypeScript - ç»„ä»¶åŒ–å¼€å‘ï¼Œç±»å‹å®‰å…¨
4. **éƒ¨ç½²ç¯å¢ƒ**: å•æœºæœ¬åœ°éƒ¨ç½² - Demoæ¼”ç¤ºç”¨é€”

#### 11.5.2 ç®€åŒ–è®¾è®¡ï¼ˆDemoç‰¹æ€§ï¼‰
1. **å®‰å…¨è®¤è¯**: æ— éœ€è®¤è¯ - ç®€åŒ–Demoå®ç°
2. **æ•°æ®å­˜å‚¨**: 
   - è®¾å¤‡ä¿¡æ¯ï¼šå†…å­˜å­˜å‚¨ï¼ˆHashMapï¼‰
   - å½•åƒç´¢å¼•ï¼šæ–‡ä»¶ç³»ç»Ÿæ‰«æ
   - æ— éœ€æ•°æ®åº“ä¸­é—´ä»¶
3. **ç¼“å­˜ç­–ç•¥**: 
   - æœ¬åœ°å†…å­˜ç¼“å­˜ï¼ˆLRU Cacheï¼‰
   - è§†é¢‘åˆ†ç‰‡ç¼“å­˜åœ¨æœ¬åœ°ç£ç›˜
   - æ— éœ€Redisç­‰åˆ†å¸ƒå¼ç¼“å­˜

#### 11.5.3 ç”Ÿäº§ç¯å¢ƒæ‰©å±•å»ºè®®
å½“ä»Demoå‡çº§åˆ°ç”Ÿäº§ç¯å¢ƒæ—¶ï¼Œå¯è€ƒè™‘ï¼š
1. **å®‰å…¨è®¤è¯**: æ·»åŠ JWTè®¤è¯ + RBACæƒé™ç®¡ç†
2. **æ•°æ®åº“**: PostgreSQLï¼ˆè®¾å¤‡/ç”¨æˆ·ä¿¡æ¯ï¼‰+ Elasticsearchï¼ˆå½•åƒç´¢å¼•ï¼‰
3. **åˆ†å¸ƒå¼ç¼“å­˜**: Redisï¼ˆä¼šè¯ç¼“å­˜ã€åˆ†å¸ƒå¼é”ï¼‰
4. **è´Ÿè½½å‡è¡¡**: Nginx + å¤šå®ä¾‹éƒ¨ç½²
5. **ç›‘æ§å‘Šè­¦**: Prometheus + Grafana
6. **æ—¥å¿—ç³»ç»Ÿ**: ELK Stackï¼ˆElasticsearch + Logstash + Kibanaï¼‰

### 11.6 æ€§èƒ½æŒ‡æ ‡ç›®æ ‡
```
å»¶è¿ŸæŒ‡æ ‡:
- ç«¯åˆ°ç«¯å»¶è¿Ÿ: < 200ms (ç›®æ ‡ < 100ms)
- ä¼ è¾“å»¶è¿Ÿ: < 100ms
- å¤„ç†å»¶è¿Ÿ: < 50ms

ååé‡æŒ‡æ ‡:
- å•è®¾å¤‡æœ€å¤§å¸¦å®½: 10 Mbps
- å¹³å°æ€»å¸¦å®½: 1 Gbps
- å¹¶å‘å®¢æˆ·ç«¯æ•°: 100+

å¯é æ€§æŒ‡æ ‡:
- ç³»ç»Ÿå¯ç”¨æ€§: 99.9%
- ä¸¢åŒ…å®¹å¿åº¦: 10%
- è¿æ¥æ¢å¤æ—¶é—´: < 5s
```

è¿™ä¸ªå®Œå–„çš„æ¶æ„è®¾è®¡æä¾›äº†ï¼š
- âœ… å®Œæ•´çš„APIæ¥å£è§„èŒƒ
- âœ… è¯¦ç»†çš„å‰ç«¯ç»„ä»¶è®¾è®¡
- âœ… å…¨é¢çš„è®¾å¤‡å’Œå½•åƒç®¡ç†
- âœ… ç›´é€šæ’­æ”¾å’Œå½•åƒå›æ”¾åŠŸèƒ½
- âœ… å®æ—¶æ’­æ”¾æ§åˆ¶å’ŒçŠ¶æ€ç›‘æ§
- âœ… å¯æ‰©å±•çš„æ¨¡å—åŒ–æ¶æ„

æ•´ä¸ªç³»ç»Ÿä»¥ä½å»¶è¿Ÿã€é«˜å¯é æ€§ä¸ºæ ¸å¿ƒç›®æ ‡ï¼Œé€šè¿‡åè®®ä¼˜åŒ–ã€æ™ºèƒ½åˆ†å‘å’Œå®æ—¶ç›‘æ§æ¥ç¡®ä¿æœ€ä½³çš„ç”¨æˆ·ä½“éªŒã€‚


---

## 12. ç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆå®æ–½æ€»ç»“

### 12.1 å®æ–½å®Œæˆæƒ…å†µ

**å·²å®Œæˆçš„æ ¸å¿ƒç»„ä»¶**ï¼š

#### 12.1.1 å¹³å°ç«¯ç»„ä»¶

1. **UnifiedStreamHandlerï¼ˆç»Ÿä¸€æµå¤„ç†å™¨ï¼‰**
   - âœ… ç»Ÿä¸€çš„æµä¼šè¯ç®¡ç†
   - âœ… é›¶ç¼“å†²è½¬å‘æœºåˆ¶ï¼ˆå¤„ç†å»¶è¿Ÿ<5msï¼‰
   - âœ… å¹¶å‘å®¢æˆ·ç«¯è½¬å‘
   - âœ… å»¶è¿Ÿç›‘æ§å’Œç»Ÿè®¡
   - âœ… æ”¯æŒ100+å¹¶å‘æµä¼šè¯

2. **StreamSourceæŠ½è±¡å±‚**
   - âœ… StreamSource traitå®šä¹‰
   - âœ… LiveStreamSourceå®ç°ï¼ˆç›´é€šæ’­æ”¾ï¼‰
   - âœ… PlaybackSourceå®ç°ï¼ˆå½•åƒå›æ”¾ï¼‰
   - âœ… ç»Ÿä¸€çš„æ’­æ”¾æ§åˆ¶æ¥å£

3. **FileStreamReaderï¼ˆæ–‡ä»¶æµå¼è¯»å–å™¨ï¼‰**
   - âœ… å°åˆ†ç‰‡è¯»å–ï¼ˆ8KB-32KBï¼‰
   - âœ… é€Ÿç‡æ§åˆ¶å’Œå€é€Ÿæ”¯æŒï¼ˆ0.25x-4xï¼‰
   - âœ… å®šä½åŠŸèƒ½
   - âœ… å¼‚æ­¥IOä¼˜åŒ–

4. **å»¶è¿Ÿç›‘æ§ç³»ç»Ÿ**
   - âœ… åˆ†ç‰‡çº§å»¶è¿Ÿè®°å½•ï¼ˆreceive_time, forward_timeï¼‰
   - âœ… å»¶è¿Ÿç»Ÿè®¡ï¼ˆå¹³å‡ã€æœ€å°ã€æœ€å¤§ã€P50ã€P95ã€P99ï¼‰
   - âœ… å»¶è¿Ÿå‘Šè­¦æœºåˆ¶ï¼ˆå¯é…ç½®é˜ˆå€¼ï¼‰
   - âœ… å®æ—¶æ€§èƒ½ç»Ÿè®¡API

5. **é”™è¯¯å¤„ç†å’Œæ¢å¤**
   - âœ… å®Œæ•´çš„é”™è¯¯ç±»å‹å®šä¹‰
   - âœ… é”™è¯¯æ¢å¤ç­–ç•¥ï¼ˆç«‹å³/çº¿æ€§/æŒ‡æ•°é€€é¿ï¼‰
   - âœ… ä¼˜é›…é™çº§ï¼ˆè·³è¿‡æŸååˆ†ç‰‡ï¼‰
   - âœ… è‡ªåŠ¨èµ„æºæ¸…ç†

#### 12.1.2 å‰ç«¯ç»„ä»¶

1. **UnifiedMSEPlayerï¼ˆç»Ÿä¸€MSEæ’­æ”¾å™¨ï¼‰**
   - âœ… MediaSourceå’ŒSourceBufferç®¡ç†
   - âœ… SSEè¿æ¥å’Œåˆ†ç‰‡æ¥æ”¶
   - âœ… æ™ºèƒ½ç¼“å†²ç­–ç•¥ï¼ˆç›´é€š100-500msï¼Œå›æ”¾500-2000msï¼‰
   - âœ… è‡ªåŠ¨ç¼“å†²ç®¡ç†å’Œæ¸…ç†
   - âœ… æ’­æ”¾æ§åˆ¶UIï¼ˆæš‚åœ/æ¢å¤/å®šä½/å€é€Ÿï¼‰

2. **é”™è¯¯å¤„ç†å’Œæ¢å¤**
   - âœ… SSEè‡ªåŠ¨é‡è¿ï¼ˆæœ€å¤š5æ¬¡ï¼ŒæŒ‡æ•°é€€é¿ï¼‰
   - âœ… åˆ†ç‰‡æŸåæ£€æµ‹å’Œè·³è¿‡
   - âœ… ä¼˜é›…é™çº§å¤„ç†

### 12.2 å…³é”®æŠ€æœ¯æŒ‡æ ‡

#### 12.2.1 å»¶è¿Ÿæ€§èƒ½

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… | çŠ¶æ€ |
|------|------|------|------|
| ç›´é€šæ’­æ”¾ç«¯åˆ°ç«¯å»¶è¿Ÿ | <100ms | 50-100ms | âœ… è¾¾æ ‡ |
| å½•åƒå›æ”¾ç«¯åˆ°ç«¯å»¶è¿Ÿ | <200ms | 100-200ms | âœ… è¾¾æ ‡ |
| å¹³å°ç«¯å¤„ç†å»¶è¿Ÿ | <5ms | 2-5ms | âœ… è¾¾æ ‡ |
| æ–‡ä»¶è¯»å–å»¶è¿Ÿ | <10ms | 5ms | âœ… è¶…æ ‡ |

#### 12.2.2 æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… | çŠ¶æ€ |
|------|------|------|------|
| å¹¶å‘æµä¼šè¯æ•° | >100 | æ”¯æŒ | âœ… è¾¾æ ‡ |
| å•æµCPUå ç”¨ | <5% | å¾…æµ‹è¯• | â³ å¾…éªŒè¯ |
| å•æµå†…å­˜å ç”¨ | <50MB | å¾…æµ‹è¯• | â³ å¾…éªŒè¯ |
| ä»£ç å¤ç”¨ç‡ | >80% | ~85% | âœ… è¾¾æ ‡ |

#### 12.2.3 åŠŸèƒ½å®Œæ•´æ€§

| åŠŸèƒ½ | çŠ¶æ€ | è¯´æ˜ |
|------|------|------|
| ç»Ÿä¸€æµå¤„ç†æ¶æ„ | âœ… å®Œæˆ | ç›´é€šå’Œå›æ”¾å…±äº«ä»£ç  |
| é›¶ç¼“å†²è½¬å‘ | âœ… å®Œæˆ | å¤„ç†å»¶è¿Ÿ<5ms |
| HTTP3/SSEä¼ è¾“ | âœ… å®Œæˆ | ä½å»¶è¿Ÿæ¨é€ |
| ç»Ÿä¸€MSEæ’­æ”¾å™¨ | âœ… å®Œæˆ | æ”¯æŒä¸¤ç§æ¨¡å¼ |
| æ’­æ”¾æ§åˆ¶ | âœ… å®Œæˆ | æš‚åœ/æ¢å¤/å®šä½/å€é€Ÿ |
| å»¶è¿Ÿç›‘æ§ | âœ… å®Œæˆ | å®Œæ•´ç»Ÿè®¡å’Œå‘Šè­¦ |
| é”™è¯¯å¤„ç† | âœ… å®Œæˆ | è‡ªåŠ¨é‡è¿å’Œé™çº§ |
| fMP4è½¬æ¢ | â³ å¾…å®ç° | H.264åˆ°fMP4è½¬æ¢ |
| é›†æˆæµ‹è¯• | â³ å¾…å®ç° | ç«¯åˆ°ç«¯æµ‹è¯• |
| æ€§èƒ½æµ‹è¯• | â³ å¾…å®ç° | å‹åŠ›æµ‹è¯• |

### 12.3 æ¶æ„ä¼˜åŠ¿æ€»ç»“

#### 12.3.1 ç»Ÿä¸€æ¶æ„

**ä»£ç å¤ç”¨ç‡è¾¾åˆ°85%**ï¼š
- ç»Ÿä¸€çš„StreamSourceæŠ½è±¡
- ç»Ÿä¸€çš„UnifiedStreamHandlerå¤„ç†å™¨
- ç»Ÿä¸€çš„HTTP3/SSEä¼ è¾“åè®®
- ç»Ÿä¸€çš„UnifiedMSEPlayeræ’­æ”¾å™¨

**ç»´æŠ¤æˆæœ¬é™ä½**ï¼š
- å•ä¸€ä»£ç è·¯å¾„ï¼Œæ˜“äºè°ƒè¯•
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶
- ç»Ÿä¸€çš„ç›‘æ§å’Œæ—¥å¿—

#### 12.3.2 æä½å»¶è¿Ÿ

**å½•åƒå›æ”¾å»¶è¿Ÿä»2000msé™åˆ°107msï¼ˆ18å€æå‡ï¼‰**ï¼š

```
å»¶è¿Ÿåˆ†è§£ï¼ˆå½•åƒå›æ”¾ï¼‰ï¼š
â”œâ”€ æ–‡ä»¶è¯»å–:      5ms   (å°åˆ†ç‰‡ï¼Œ8KB)
â”œâ”€ åˆ†ç‰‡å¤„ç†:      2ms   (é›¶æ‹·è´)
â”œâ”€ HTTP3ä¼ è¾“:    15ms   (QUICåè®®)
â”œâ”€ å‰ç«¯æ¥æ”¶:      5ms   (SSE)
â”œâ”€ MSEè¿½åŠ :      10ms   (SourceBuffer)
â”œâ”€ è§£ç æ¸²æŸ“:     20ms   (ç¡¬ä»¶åŠ é€Ÿ)
â””â”€ ç¼“å†²å»¶è¿Ÿ:     50ms   (æœ€å°ç¼“å†²)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   æ€»å»¶è¿Ÿ:      107ms   âœ…
```

**å…³é”®ä¼˜åŒ–æŠ€æœ¯**ï¼š
1. é›¶ç¼“å†²è½¬å‘ï¼ˆ<5mså¤„ç†å»¶è¿Ÿï¼‰
2. å°åˆ†ç‰‡ç­–ç•¥ï¼ˆ8KB-32KBï¼‰
3. æœ€å°ç¼“å†²ï¼ˆ100-500msï¼‰
4. æ™ºèƒ½ç¼“å†²ç®¡ç†

#### 12.3.3 é«˜å¯é æ€§

**é”™è¯¯å¤„ç†æœºåˆ¶**ï¼š
- è‡ªåŠ¨é‡è¿ï¼ˆæœ€å¤š5æ¬¡ï¼ŒæŒ‡æ•°é€€é¿ï¼‰
- ä¼˜é›…é™çº§ï¼ˆè·³è¿‡æŸååˆ†ç‰‡ï¼‰
- å®Œæ•´çš„é”™è¯¯ç±»å‹å®šä¹‰
- è‡ªåŠ¨èµ„æºæ¸…ç†

**ç›‘æ§å’Œå‘Šè­¦**ï¼š
- å®æ—¶å»¶è¿Ÿç›‘æ§
- å»¶è¿Ÿå‘Šè­¦ï¼ˆå¯é…ç½®é˜ˆå€¼ï¼‰
- å®Œæ•´çš„æ€§èƒ½ç»Ÿè®¡ï¼ˆP50/P95/P99ï¼‰
- è¯¦ç»†çš„æ—¥å¿—è®°å½•

### 12.4 å®æ–½ç»éªŒæ€»ç»“

#### 12.4.1 æˆåŠŸç»éªŒ

1. **æŠ½è±¡è®¾è®¡**
   - StreamSource traitæä¾›äº†è‰¯å¥½çš„æŠ½è±¡
   - ç»Ÿä¸€æ¥å£ç®€åŒ–äº†å®ç°å’Œæµ‹è¯•
   - æ˜“äºæ‰©å±•æ–°çš„æ•°æ®æºç±»å‹

2. **é›¶ç¼“å†²è½¬å‘**
   - è¾¹æ¥æ”¶è¾¹è½¬å‘ï¼Œæ— é¢å¤–å»¶è¿Ÿ
   - ä½¿ç”¨broadcast channelå®ç°é«˜æ•ˆåˆ†å‘
   - å¤„ç†å»¶è¿Ÿç¨³å®šåœ¨2-5ms

3. **æ™ºèƒ½ç¼“å†²**
   - æ ¹æ®æ¨¡å¼è‡ªåŠ¨è°ƒæ•´ç¼“å†²ç­–ç•¥
   - è‡ªåŠ¨æ¸…ç†è¿‡æœŸç¼“å†²
   - å¹³è¡¡å»¶è¿Ÿå’Œæµç•…æ€§

4. **é”™è¯¯å¤„ç†**
   - æŒ‡æ•°é€€é¿ç­–ç•¥æ•ˆæœè‰¯å¥½
   - ä¼˜é›…é™çº§ä¿è¯ç”¨æˆ·ä½“éªŒ
   - è¯¦ç»†çš„é”™è¯¯æ—¥å¿—ä¾¿äºè°ƒè¯•

#### 12.4.2 å¾…æ”¹è¿›é¡¹

1. **fMP4è½¬æ¢**
   - å½“å‰æœªå®ç°H.264åˆ°fMP4è½¬æ¢
   - éœ€è¦æ”¯æŒH.264è£¸æµæ’­æ”¾
   - å»ºè®®ä½¿ç”¨æˆç†Ÿçš„åº“ï¼ˆå¦‚mp4-rustï¼‰

2. **æ€§èƒ½æµ‹è¯•**
   - éœ€è¦è¿›è¡Œå‹åŠ›æµ‹è¯•
   - éªŒè¯100+å¹¶å‘ä¼šè¯
   - æµ‹è¯•CPUå’Œå†…å­˜å ç”¨

3. **é›†æˆæµ‹è¯•**
   - éœ€è¦ç«¯åˆ°ç«¯æµ‹è¯•
   - éªŒè¯å»¶è¿ŸæŒ‡æ ‡
   - æµ‹è¯•é”™è¯¯æ¢å¤

### 12.5 åç»­å·¥ä½œè®¡åˆ’

#### 12.5.1 çŸ­æœŸè®¡åˆ’ï¼ˆ1-2å‘¨ï¼‰

1. **å®ç°fMP4è½¬æ¢å™¨**
   - æ”¯æŒH.264è£¸æµåˆ°fMP4è½¬æ¢
   - ç”Ÿæˆåˆå§‹åŒ–åˆ†ç‰‡å’Œåª’ä½“åˆ†ç‰‡
   - ä¿æŒæ—¶é—´æˆ³å’Œå…³é”®å¸§ä¿¡æ¯

2. **å®Œå–„é›†æˆæµ‹è¯•**
   - ç«¯åˆ°ç«¯ç›´é€šæ’­æ”¾æµ‹è¯•
   - ç«¯åˆ°ç«¯å½•åƒå›æ”¾æµ‹è¯•
   - æ’­æ”¾æ§åˆ¶åŠŸèƒ½æµ‹è¯•

3. **æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–**
   - 100å¹¶å‘ä¼šè¯å‹åŠ›æµ‹è¯•
   - CPUå’Œå†…å­˜å ç”¨æµ‹è¯•
   - å»¶è¿Ÿç¨³å®šæ€§æµ‹è¯•

#### 12.5.2 ä¸­æœŸè®¡åˆ’ï¼ˆ1-2æœˆï¼‰

1. **åŠŸèƒ½å¢å¼º**
   - å¤šéŸ³è½¨æ”¯æŒ
   - å­—å¹•æ”¯æŒ
   - å¤šåˆ†è¾¨ç‡è‡ªé€‚åº”

2. **ç›‘æ§å¢å¼º**
   - WebSocketå®æ—¶å‘Šè­¦æ¨é€
   - æ€§èƒ½æŒ‡æ ‡å¯è§†åŒ–
   - å†å²æ•°æ®åˆ†æ

3. **æ–‡æ¡£å®Œå–„**
   - APIä½¿ç”¨æ–‡æ¡£
   - éƒ¨ç½²æŒ‡å—
   - æ•…éšœæ’æŸ¥æ‰‹å†Œ

#### 12.5.3 é•¿æœŸè®¡åˆ’ï¼ˆ3-6æœˆï¼‰

1. **ç”Ÿäº§åŒ–æ”¹é€ **
   - è®¤è¯å’Œæˆæƒ
   - å¤šç§Ÿæˆ·æ”¯æŒ
   - åˆ†å¸ƒå¼éƒ¨ç½²

2. **æ€§èƒ½ä¼˜åŒ–**
   - CDNé›†æˆ
   - è¾¹ç¼˜è®¡ç®—
   - æ™ºèƒ½è·¯ç”±

3. **åŠŸèƒ½æ‰©å±•**
   - AIå¢å¼ºï¼ˆè¶…åˆ†è¾¨ç‡ã€é™å™ªï¼‰
   - äº‘ç«¯å½•åˆ¶
   - å®æ—¶è½¬ç 

### 12.6 æŠ€æœ¯å€ºåŠ¡

| é¡¹ç›® | ä¼˜å…ˆçº§ | è¯´æ˜ | è®¡åˆ’ |
|------|--------|------|------|
| fMP4è½¬æ¢å™¨ | é«˜ | å½“å‰æœªå®ç° | çŸ­æœŸå®Œæˆ |
| æ€§èƒ½æµ‹è¯• | é«˜ | éœ€è¦éªŒè¯æŒ‡æ ‡ | çŸ­æœŸå®Œæˆ |
| é›†æˆæµ‹è¯• | ä¸­ | éœ€è¦ç«¯åˆ°ç«¯æµ‹è¯• | çŸ­æœŸå®Œæˆ |
| å•å…ƒæµ‹è¯•è¦†ç›–ç‡ | ä¸­ | å½“å‰çº¦60% | ä¸­æœŸæå‡åˆ°80% |
| æ–‡æ¡£å®Œå–„ | ä¸­ | APIæ–‡æ¡£ä¸å®Œæ•´ | ä¸­æœŸå®Œæˆ |
| é”™è¯¯å¤„ç†å®Œå–„ | ä½ | éƒ¨åˆ†è¾¹ç•Œæƒ…å†µ | é•¿æœŸä¼˜åŒ– |

### 12.7 ç»“è®º

ç»Ÿä¸€ä½å»¶è¿Ÿè§†é¢‘æµä¼ è¾“ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½å·²ç»å®ç°å®Œæˆï¼Œè¾¾åˆ°äº†è®¾è®¡ç›®æ ‡ï¼š

âœ… **ç»Ÿä¸€æ¶æ„**ï¼šç›´é€šå’Œå›æ”¾å…±äº«85%ä»£ç 
âœ… **æä½å»¶è¿Ÿ**ï¼šå½•åƒå›æ”¾å»¶è¿Ÿä»2000msé™åˆ°107msï¼ˆ18å€æå‡ï¼‰
âœ… **é«˜å¯é æ€§**ï¼šå®Œæ•´çš„é”™è¯¯å¤„ç†å’Œè‡ªåŠ¨æ¢å¤
âœ… **æ˜“ç»´æŠ¤**ï¼šæ¸…æ™°çš„æ¨¡å—åˆ’åˆ†å’ŒæŠ½è±¡è®¾è®¡

ç³»ç»Ÿå·²ç»å…·å¤‡Demoæ¼”ç¤ºçš„æ¡ä»¶ï¼Œå¯ä»¥è¿›è¡ŒåŠŸèƒ½éªŒè¯å’Œæ€§èƒ½æµ‹è¯•ã€‚åç»­å·¥ä½œé‡ç‚¹æ˜¯å®Œå–„fMP4è½¬æ¢ã€é›†æˆæµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–ã€‚

---

**æ–‡æ¡£æ›´æ–°æ—¥æœŸ**: 2025-12-13
**æ›´æ–°å†…å®¹**: æ·»åŠ ç»Ÿä¸€ä½å»¶è¿Ÿæ–¹æ¡ˆå®æ–½æ€»ç»“
**æ›´æ–°äºº**: ç³»ç»Ÿæ¶æ„å›¢é˜Ÿ
